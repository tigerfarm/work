/// <reference types="node" />
import { EventEmitter } from "events";
/**
 * Provides retrier service
 */
declare class Retrier extends EventEmitter {
    private readonly minDelay;
    private maxDelay;
    private readonly initialDelay;
    private readonly maxAttemptsCount;
    private readonly maxAttemptsTime;
    private readonly randomness;
    // fibonacci strategy
    private prevDelay;
    private currDelay;
    private timeout;
    private inProgress;
    private attemptNum;
    private startTimestamp;
    /**
     * Creates a new Retrier instance
     */
    constructor(options: {
        min: number;
        max: number;
        initial?: number;
        maxAttemptsCount?: number;
        maxAttemptsTime?: number;
        randomness?: number;
    });
    private attempt;
    private nextDelay;
    private randomize;
    private scheduleAttempt;
    private cleanup;
    start(): void;
    cancel(): void;
    // @todo Must be a T here, so the entire Retrier must be typed on this value type.
    // eslint-disable-next-line
    succeeded(arg?: any): void;
    failed(err: Error, nextAttemptDelayOverride?: number): void;
}
/**
 * Run retrier as an async function with possibility to await for it.
 * Example:
 * ```
 * const result = AsyncRetrier.run(async () => somePromise);
 * ```
 */
declare class AsyncRetrier extends EventEmitter {
    private retrier;
    // This any must be T typed directly on the AsyncRetrier
    // eslint-disable-next-line
    private resolve;
    private reject;
    constructor(options: {
        min: number;
        max: number;
        initial?: number;
        maxAttemptsCount?: number;
        maxAttemptsTime?: number;
        randomness?: number;
    });
    run<T>(handler: () => Promise<T>): Promise<T>;
    cancel(): void;
}
interface BackoffOptions {
    initialDelay?: number;
    maxDelay?: number;
    randomisationFactor?: number;
    factor?: number;
}
declare class Backoff extends EventEmitter {
    private readonly maxDelay;
    private readonly initialDelay;
    private readonly factor;
    private readonly randomisationFactor;
    private backoffDelay;
    private nextBackoffDelay;
    private backoffNumber;
    private timeoutID;
    private maxNumberOfRetry;
    constructor(options: BackoffOptions);
    static exponential(options: BackoffOptions): Backoff;
    backoff(err?: Error): void;
    reset(): void;
    failAfter(maxNumberOfRetry: number): void;
    next(): number;
    onBackoff(): void;
}
export { Retrier, AsyncRetrier, Backoff };
