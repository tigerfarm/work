'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var _defineProperty = require('@babel/runtime/helpers/defineProperty');
require('core-js/modules/es.promise.js');
var events = require('events');

function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

var _defineProperty__default = /*#__PURE__*/_interopDefaultLegacy(_defineProperty);

/**
 * Provides retrier service
 */

class Retrier extends events.EventEmitter {
  // fibonacci strategy

  /**
   * Creates a new Retrier instance
   */
  constructor(options) {
    super();

    _defineProperty__default['default'](this, "timeout", null);

    _defineProperty__default['default'](this, "startTimestamp", -1);

    this.minDelay = options.min;
    this.maxDelay = options.max;
    this.initialDelay = options.initial || 0;
    this.maxAttemptsCount = options.maxAttemptsCount || 0;
    this.maxAttemptsTime = options.maxAttemptsTime || 0;
    this.randomness = options.randomness || 0;
    this.inProgress = false;
    this.attemptNum = 0;
    this.prevDelay = 0;
    this.currDelay = 0;
  }

  attempt() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }

    this.attemptNum++;
    this.emit("attempt", this);
  }

  nextDelay(delayOverride) {
    if (typeof delayOverride === "number") {
      this.prevDelay = 0;
      this.currDelay = delayOverride;
      return delayOverride;
    }

    if (this.attemptNum == 0) {
      return this.initialDelay;
    }

    if (this.attemptNum == 1) {
      this.currDelay = this.minDelay;
      return this.currDelay;
    }

    this.prevDelay = this.currDelay;
    var delay = this.currDelay + this.prevDelay;

    if (this.maxDelay && delay > this.maxDelay) {
      this.currDelay = this.maxDelay;
      delay = this.maxDelay;
    }

    this.currDelay = delay;
    return delay;
  }

  randomize(delay) {
    var area = delay * this.randomness;
    var corr = Math.round(Math.random() * area * 2 - area);
    return Math.max(0, delay + corr);
  }

  scheduleAttempt(delayOverride) {
    if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {
      this.cleanup();
      this.emit("failed", new Error("Maximum attempt count limit reached"));
      return;
    }

    var delay = this.nextDelay(delayOverride);
    delay = this.randomize(delay);

    if (this.maxAttemptsTime && this.startTimestamp + this.maxAttemptsTime < Date.now() + delay) {
      this.cleanup();
      this.emit("failed", new Error("Maximum attempt time limit reached"));
      return;
    }

    this.timeout = setTimeout(() => this.attempt(), delay);
  }

  cleanup() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
    }

    this.inProgress = false;
    this.attemptNum = 0;
    this.prevDelay = 0;
    this.currDelay = 0;
  }

  start() {
    if (this.inProgress) {
      throw new Error("Retrier is already in progress");
    }

    this.inProgress = true;
    this.startTimestamp = Date.now();
    this.scheduleAttempt(this.initialDelay);
  }

  cancel() {
    if (this.timeout) {
      clearTimeout(this.timeout);
      this.timeout = null;
      this.inProgress = false;
      this.emit("cancelled");
    }
  } // @todo Must be a T here, so the entire Retrier must be typed on this value type.
  // eslint-disable-next-line


  succeeded(arg) {
    this.emit("succeeded", arg);
  }

  failed(err, nextAttemptDelayOverride) {
    if (this.timeout) {
      throw new Error("Retrier attempt is already in progress");
    }

    this.scheduleAttempt(nextAttemptDelayOverride);
  }

}
/**
 * Run retrier as an async function with possibility to await for it.
 * Example:
 * ```
 * const result = AsyncRetrier.run(async () => somePromise);
 * ```
 */


class AsyncRetrier extends events.EventEmitter {
  // This any must be T typed directly on the AsyncRetrier
  // eslint-disable-next-line
  constructor(options) {
    super();

    _defineProperty__default['default'](this, "resolve", () => void 0);

    _defineProperty__default['default'](this, "reject", () => void 0);

    this.retrier = new Retrier(options);
  }

  run(handler) {
    this.retrier.on("attempt", () => {
      handler().then(v => this.retrier.succeeded(v)).catch(e => this.retrier.failed(e));
    });
    this.retrier.on("succeeded", arg => this.resolve(arg));
    this.retrier.on("cancelled", () => this.reject(new Error("Cancelled")));
    this.retrier.on("failed", err => this.reject(err));
    return new Promise((resolve, reject) => {
      this.resolve = resolve;
      this.reject = reject;
      this.retrier.start();
    });
  }

  cancel() {
    this.retrier.cancel();
  }

}

function isDef(value) {
  return value !== undefined && value !== null;
}

class Backoff extends events.EventEmitter {
  constructor(options) {
    super();

    _defineProperty__default['default'](this, "backoffDelay", 0);

    _defineProperty__default['default'](this, "nextBackoffDelay", 0);

    _defineProperty__default['default'](this, "backoffNumber", 0);

    _defineProperty__default['default'](this, "timeoutID", null);

    _defineProperty__default['default'](this, "maxNumberOfRetry", -1);

    options = options || {};
    var _options = options,
        initialDelay = _options.initialDelay,
        maxDelay = _options.maxDelay,
        randomisationFactor = _options.randomisationFactor,
        factor = _options.factor;

    if (isDef(initialDelay) && initialDelay < 1) {
      throw new Error("The initial timeout must be equal to or greater than 1.");
    }

    if (isDef(maxDelay) && maxDelay <= 1) {
      throw new Error("The maximal timeout must be greater than 1.");
    }

    if (isDef(randomisationFactor) && (randomisationFactor < 0 || randomisationFactor > 1)) {
      throw new Error("The randomisation factor must be between 0 and 1.");
    }

    if (isDef(factor) && factor <= 1) {
      throw new Error("Exponential factor should be greater than 1.");
    }

    this.initialDelay = initialDelay || 100;
    this.maxDelay = maxDelay || 10000;

    if (this.maxDelay <= this.initialDelay) {
      throw new Error("The maximal backoff delay must be greater than the initial backoff delay.");
    }

    this.randomisationFactor = randomisationFactor || 0;
    this.factor = factor || 2;
    this.reset();
  }

  static exponential(options) {
    return new Backoff(options);
  }

  backoff(err) {
    if (this.timeoutID == null) {
      if (this.backoffNumber === this.maxNumberOfRetry) {
        this.emit("fail", err);
        this.reset();
      } else {
        this.backoffDelay = this.next();
        this.timeoutID = setTimeout(this.onBackoff.bind(this), this.backoffDelay);
        this.emit("backoff", this.backoffNumber, this.backoffDelay, err);
      }
    }
  }

  reset() {
    this.backoffDelay = 0;
    this.nextBackoffDelay = this.initialDelay;
    this.backoffNumber = 0;

    if (this.timeoutID) {
      clearTimeout(this.timeoutID);
    }

    this.timeoutID = null;
  }

  failAfter(maxNumberOfRetry) {
    if (maxNumberOfRetry <= 0) {
      throw new Error("Expected a maximum number of retry greater than 0 but got ".concat(maxNumberOfRetry));
    }

    this.maxNumberOfRetry = maxNumberOfRetry;
  }

  next() {
    this.backoffDelay = Math.min(this.nextBackoffDelay, this.maxDelay);
    this.nextBackoffDelay = this.backoffDelay * this.factor;
    var randomisationMultiple = 1 + Math.random() * this.randomisationFactor;
    return Math.min(this.maxDelay, Math.round(this.backoffDelay * randomisationMultiple));
  }

  onBackoff() {
    this.timeoutID = null;
    this.emit("ready", this.backoffNumber, this.backoffDelay);
    this.backoffNumber++;
  }

}

exports.AsyncRetrier = AsyncRetrier;
exports.Backoff = Backoff;
exports.Retrier = Retrier;
//# sourceMappingURL=lib.js.map
