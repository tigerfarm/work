/// <reference types="node" />
import { EventEmitter } from "events";
import { SyncClient } from "twilio-sync";
import { Twilsock as TwilsockClient } from "twilsock";
import { ChannelType, Notifications } from "twilio-notifications";
import { Notifications as NotificationClient } from "twilio-notifications";
import { ConnectionState as NotificationConnectionState } from "twilio-notifications";
import { McsClient } from "twilio-mcs-client";
interface ConfigurationResponse {
    options: {
        consumption_report_interval: string;
        user_infos_to_subscribe: number;
        reachability_enabled: boolean;
        http_cache_interval: string;
        my_conversations_page_size: number;
    };
    sync_objects: {
        my_conversations: string;
        my_user_info: string;
    };
    links: {
        my_conversations: string;
        conversations: string;
        users: string;
        current_user: string;
        typing: string;
        media_service: string;
        messages_receipts: string;
    };
    identity: string;
    url: string;
}
// twilio-chat is used by Flex SDK. Please DO NOT change
declare class Logger {
    private prefix;
    private constructor();
    static scope(prefix: string): Logger;
    setLevel(level: any): void;
    static setLevel(level: any): void;
    trace(...args: any[]): void;
    debug(...args: any[]): void;
    info(...args: any[]): void;
    warn(...args: any[]): void;
    error(...args: any[]): void;
    static trace(...args: any[]): void;
    static debug(...args: any[]): void;
    static info(...args: any[]): void;
    static warn(...args: any[]): void;
    static error(...args: any[]): void;
}
interface BackoffConfiguration {
    min: number;
    max: number;
    maxAttemptsCount: number;
}
declare class Configuration {
    readonly links: {
        myConversations: string;
        conversations: string;
        users: string;
        currentUser: string;
        typing: string;
        mediaService: string;
        messagesReceipts: string;
    };
    readonly productId?: string;
    readonly typingIndicatorTimeoutOverride?: number;
    readonly typingIndicatorTimeoutDefault: number;
    readonly backoffConfiguration: BackoffConfiguration;
    readonly retryWhenThrottled: boolean;
    readonly consumptionReportInterval: number;
    readonly userInfosToSubscribe: number;
    readonly httpCacheInterval: number;
    readonly reachabilityEnabled: boolean;
    readonly userIdentity: string;
    readonly userInfo: string;
    readonly myConversations: string;
    constructor(options: Record<string, any>, configurationResponse: ConfigurationResponse, logger: Logger);
}
interface Result<T> {
    status: {
        code: number;
        status: string;
    };
    headers: {
        [id: string]: string;
    };
    body?: T;
}
interface Transport extends EventEmitter {
    readonly isConnected: boolean;
    readonly state: string;
    get<T>(url: string, headers: any, grant?: string): Promise<Result<T>>;
    post<T>(url: string, headers: any, body: any, grant?: string): Promise<Result<T>>;
    put<T>(url: string, headers: any, body: any, grant?: string): Promise<Result<T>>;
    delete<T>(url: string, headers: any, grant?: string): Promise<Result<T>>;
}
interface CommandExecutorServices {
    transport: Transport;
}
declare class CommandExecutor {
    private _serviceUrl;
    private _services;
    private _productId?;
    constructor(_serviceUrl: string, _services: CommandExecutorServices, _productId?: string);
    private _preProcessUrl;
    private _makeRequest;
    fetchResource<REQ = void, RESP = void>(url: string, requestBody?: REQ): Promise<RESP>;
    mutateResource<REQ = void, RESP = void>(method: "post" | "delete", url: string, requestBody?: REQ): Promise<RESP>;
}
interface UserServices {
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
interface UserLinks {
    self: string;
}
declare namespace User {
    type SubscriptionState = "initializing" | "subscribed" | "unsubscribed";
    type UpdateReason = "friendlyName" | "attributes" | "online" | "notifiable";
    interface UpdatedEventArgs {
        user: User;
        updateReasons: User.UpdateReason[];
    }
}
/**
 * @classdesc Extended user information.
 * Note that <code>online</code> and <code>notifiable</code> properties are eligible
 * to use only if reachability function is enabled.
 * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.
 *
 * @property {String} identity - User identity
 * @property {String} friendlyName - User friendly name, null if not set
 * @property {any} attributes - Object with custom attributes for user
 * @property {Boolean} online - User real-time channel connection status
 * @property {Boolean} notifiable - User push notification registration status
 * @property {Boolean} isSubscribed - Check if this user receives real-time status updates
 *
 * @fires User#updated
 * @fires User#userSubscribed
 * @fires User#userUnsubscribed
 *
 * @constructor
 * @param {String} identity - Identity of user
 * @param {String} entityId - id of user's object
 * @param {Object} datasync - datasync service
 */
declare class User extends EventEmitter {
    private readonly links;
    private readonly configuration;
    private readonly services;
    private entity;
    private state;
    private promiseToFetch;
    private subscribed;
    constructor(identity: string, entityName: string, links: UserLinks, configuration: Configuration, services: UserServices);
    /**
     * The update reason for <code>updated</code> event emitted on User
     * @typedef {('friendlyName' | 'attributes' | 'online' | 'notifiable')} User#UpdateReason
     */
    get identity(): string;
    set identity(identity: string);
    set entityName(name: string);
    get attributes(): any;
    get friendlyName(): string;
    get online(): boolean;
    get notifiable(): boolean;
    get isSubscribed(): boolean;
    // Handles service updates
    _update(key: string, value: any): void;
    // Fetch reachability info
    private _updateReachabilityInfo;
    // Fetch user
    _fetch(): Promise<User>;
    _ensureFetched(): Promise<User>;
    /**
     * Updates user attributes.
     * @param {any} attributes new attributes for User.
     * @returns {Promise<User>}
     */
    updateAttributes(attributes: any): Promise<User>;
    /**
     * Update Users friendlyName.
     * @param {String} friendlyName - Updated friendlyName
     * @returns {Promise<User>}
     */
    updateFriendlyName(friendlyName: any): Promise<User>;
    /**
     * Removes User from subscription list.
     * @returns {Promise<void>} Promise of completion
     */
    unsubscribe(): Promise<void>;
}
/**
 * Pagination helper class.
 *
 * @interface
 * @property {Array} items Elements on current page
 * @property {boolean} hasNextPage Indicates the existence of next page
 * @property {boolean} hasPrevPage Indicates the existence of previous page
 * @function {Promise<Paginator>} nextPage() Request next page. Does not modify existing object
 * @function {Promise<Paginator>} prevPage() Request previous page. Does not modify existing object
 */
interface Paginator<T> {
    hasNextPage: boolean;
    hasPrevPage: boolean;
    items: Array<T>;
    /**
     * Request next page.
     * Does not modify existing object.
     * @return {Promise<Paginator<T>>}
     */
    nextPage(): Promise<Paginator<T>>;
    /**
     * Request previous page.
     * Does not modify existing object.
     * @return {Promise<Paginator<T>>}
     */
    prevPage(): Promise<Paginator<T>>;
}
interface NetworkServices {
    transport: Transport;
}
declare class Network {
    private readonly configuration;
    private readonly services;
    private readonly cacheLifetime;
    private readonly cache;
    private timer;
    constructor(configuration: Configuration, services: NetworkServices);
    private isExpired;
    private cleanupCache;
    pokeTimer(): void;
    private executeWithRetry;
    get(url: string): Promise<any>;
}
interface UsersServices {
    network: Network;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
/**
 * @classdesc Container for known users
 * @fires Users#userUpdated
 */
declare class Users extends EventEmitter {
    private readonly configuration;
    private readonly services;
    private userDescriptors;
    private subscribedUsers;
    private fifoStack;
    readonly myself: User;
    constructor(configuration: Configuration, services: UsersServices);
    private handleUnsubscribeUser;
    private handleSubscribeUser;
    /**
     * Gets user, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the FIFO stack
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string, entityName?: string): Promise<User>;
    /**
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    getUserDescriptor(identity: string): Promise<UserDescriptor>;
    /**
     * @returns {Promise<Paginator<UserDescriptor>>} Users descriptors page for given channel sid
     */
    getChannelUserDescriptors(channelSid: string): Promise<Paginator<UserDescriptor>>;
    /**
     * @returns {Promise<Array<User>>} returns list of subscribed User objects {@see User}
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
interface UserDescriptorServices {
    users: Users;
}
/**
 * @classdesc Extended user information.
 * Note that <code>online</code> and <code>notifiable</code> properties are eligible
 * to use only if reachability function is enabled.
 * You may check if it is enabled by reading value of {@link Client}'s <code>reachabilityEnabled</code> property.
 *
 * @property {String} identity - User identity
 * @property {String} friendlyName - User friendly name, null if not set
 * @property {any} attributes - Object with custom attributes for user
 * @property {Boolean} online - User real-time channel connection status
 * @property {Boolean} notifiable - User push notification registration status
 *
 * @constructor
 * @param {Users} users Users instance
 * @param {Object} descriptor User descriptor data object
 */
declare class UserDescriptor {
    private services;
    private descriptor;
    readonly identity: string;
    readonly friendlyName: string;
    readonly attributes: any;
    readonly online: boolean;
    readonly notifiable: boolean;
    /**
     * @param {UserDescriptorServices} services - services, needed for UserDescriptor
     * @param {Object} descriptor User descriptor data object
     * @private
     */
    constructor(services: UserDescriptorServices, descriptor: any);
    /**
     * Gets User object from descriptor and subscribes to it.
     * @returns {Promise<User>}
     */
    subscribe(): Promise<User>;
    _getDescriptor(): any;
}
interface MemberDescriptor {
    attributes?: Object;
    dateCreated: any;
    dateUpdated: any;
    identity: string;
    roleSid?: string;
    lastConsumedMessageIndex: number;
    lastConsumptionTimestamp: number;
    type?: Member.Type;
    userInfo: string;
}
interface MemberServices {
    users: Users;
    commandExecutor: CommandExecutor;
}
interface MemberLinks {
    self: string;
}
declare namespace Member {
    type UpdateReason = "attributes" | "dateCreated" | "dateUpdated" | "roleSid" | "lastConsumedMessageIndex" | "lastConsumptionTimestamp";
    type Type = "chat" | "sms" | "whatsapp";
    interface UpdatedEventArgs {
        member: Member;
        updateReasons: Member.UpdateReason[];
    }
}
/**
 * @classdesc A Member represents a remote Client in a Channel.
 * @property {any} attributes - Object with custom attributes for Member
 * @property {Channel} channel - The Channel the remote Client is a Member of
 * @property {Date} dateCreated - The Date this Member was created
 * @property {Date} dateUpdated - The Date this Member was last updated
 * @property {String} identity - The identity of the remote Client
 * @property {Boolean} isTyping - Whether or not this Member is currently typing
 * @property {Number} lastConsumedMessageIndex - Latest consumed Message index by this Member.
 * Note that just retrieving messages on a client endpoint does not mean that messages are consumed/read,
 * please consider reading about [Consumption Horizon feature]{@link https://www.twilio.com/docs/api/chat/guides/consumption-horizon}
 * to find out how to mark messages as consumed.
 * @property {Date} lastConsumptionTimestamp - Date when Member has updated their consumption horizon
 * @property {String} sid - The server-assigned unique identifier for the Member
 * @property {Member#Type} type - The type of Member
 * @fires Member#typingEnded
 * @fires Member#typingStarted
 * @fires Member#updated
 */
declare class Member extends EventEmitter {
    readonly channel: Channel;
    private readonly links;
    private readonly services;
    private state;
    constructor(data: MemberDescriptor, sid: string, channel: Channel, links: MemberLinks, services: MemberServices);
    /**
     * The update reason for <code>updated</code> event emitted on Member
     * @typedef {('attributes' | 'dateCreated' | 'dateUpdated' | 'roleSid' |
     'lastConsumedMessageIndex' | 'lastConsumptionTimestamp')} Member#UpdateReason
     */
    /**
     * The type of Member
     * @typedef {('chat' | 'sms' | 'whatsapp')} Member#Type
     */
    get sid(): string;
    get attributes(): Object;
    get dateCreated(): Date;
    get dateUpdated(): Date;
    get identity(): string;
    get isTyping(): boolean;
    get lastConsumedMessageIndex(): number | null;
    get lastConsumptionTimestamp(): Date;
    get roleSid(): string;
    get type(): Member.Type;
    /**
     * Private method used to start or reset the typing indicator timeout (with event emitting)
     * @private
     */
    _startTyping(timeout: any): this;
    /**
     * Private method function used to stop typing indicator (with event emitting)
     * @private
     */
    _endTyping(): void;
    /**
     * Private method function used update local object's property roleSid with new value
     * @private
     */
    _update(data: any): this;
    /**
     * Gets User Descriptor for this member. Supported only for <code>chat</code> type of Members
     * @returns {Promise<UserDescriptor>}
     */
    getUserDescriptor(): Promise<UserDescriptor>;
    /**
     * Gets User for this member and subscribes to it. Supported only for <code>chat</code> type of Members
     * @returns {Promise<User>}
     */
    getUser(): Promise<User>;
    /**
     * Remove Member from the Channel.
     * @returns {Promise<void>}
     */
    remove(): Promise<void>;
    /**
     * Edit member attributes.
     * @param {any} attributes new attributes for Member.
     * @returns {Promise<Member>}
     */
    updateAttributes(attributes: any): Promise<Member>;
}
interface MediaState {
    sid: string;
    filename?: string;
    contentType: string;
    size: number;
}
interface MediaServices {
    mcsClient: McsClient;
}
/**
 * @classdesc A Media represents a media information for Message in a Channel.
 * @property {String} contentType - content type of media
 * @property {String} sid - The server-assigned unique identifier for Media
 * @property {Number} size - Size of media, bytes
 * @property {String} [filename] - file name if present, null otherwise
 */
declare class Media {
    private state;
    private services;
    private mcsMedia;
    constructor(data: MediaState, services: MediaServices);
    get sid(): string;
    get filename(): string;
    get contentType(): string;
    get size(): number;
    /**
     * Returns direct content URL for the media.
     *
     * This URL is impermanent, it will expire in several minutes and cannot be cached.
     * If the URL becomes expired, you need to request a new one.
     * Each call to this function produces a new temporary URL.
     *
     * @returns {Promise<String>}
     */
    getContentTemporaryUrl(): Promise<string>;
}
declare namespace Message {
    type Type = "text" | "media";
}
interface MessageServices {
    mcsClient: McsClient;
    commandExecutor: CommandExecutor;
}
interface MessageLinks {
    self: string;
    conversation: string;
    messages_receipts: string;
}
declare namespace Message {
    type UpdateReason = "body" | "lastUpdatedBy" | "dateCreated" | "dateUpdated" | "attributes" | "author";
    interface UpdatedEventArgs {
        message: Message;
        updateReasons: Message.UpdateReason[];
    }
}
/**
 * @classdesc A Message represents a Message in a Channel.
 * @property {String} author - The name of the user that sent Message
 * @property {String} body - The body of the Message. Is null if Message is Media Message
 * @property {any} attributes - Message custom attributes
 * @property {Channel} channel - Channel Message belongs to
 * @property {Date} dateCreated - When Message was created
 * @property {Date} dateUpdated - When Message was updated
 * @property {Number} index - Index of Message in the Channel's messages list
 * @property {String} lastUpdatedBy - Identity of the last user that updated Message
 * @property {Media} media - Contains Media information (if present)
 * @property {String} memberSid - Authoring Member's server-assigned unique identifier
 * @property {String} sid - The server-assigned unique identifier for Message
 * @property {'text' | 'media' } type - Type of message: 'text' or 'media'
 * @fires Message#updated
 */
declare class Message extends EventEmitter {
    readonly channel: Channel;
    private readonly links;
    private readonly configuration;
    private readonly services;
    private state;
    constructor(index: number, data: any, channel: Channel, links: MessageLinks, configuration: Configuration, services: MessageServices);
    /**
     * The update reason for <code>updated</code> event emitted on Message
     * @typedef {('body' | 'lastUpdatedBy' | 'dateCreated' | 'dateUpdated' | 'attributes' | 'author')} Message#UpdateReason
     */
    get sid(): string;
    get author(): string;
    get body(): string;
    get dateUpdated(): Date;
    get index(): number;
    get lastUpdatedBy(): string;
    get dateCreated(): Date;
    get attributes(): Object;
    get type(): Message.Type;
    get media(): Media;
    get memberSid(): string;
    _update(data: any): void;
    /**
     * Get Member who is author of the Message
     * @returns {Promise<Member>}
     */
    getMember(): Promise<Member>;
    /**
     * Remove the Message.
     * @returns {Promise<Message>}
     */
    remove(): Promise<Message>;
    /**
     * Edit message body.
     * @param {String} body - new body of Message.
     * @returns {Promise<Message>}
     */
    updateBody(body: string): Promise<Message>;
    /**
     * Edit message attributes.
     * @param {any} attributes new attributes for Message.
     * @returns {Promise<Message>}
     */
    updateAttributes(attributes: any): Promise<Message>;
}
interface TypingIndicatorServices {
    transport: Transport;
    notificationClient: Notifications;
}
/**
 * An important note in regards to typing timeout timers. There are two places that the SDK can get the "typing_timeout" attribute from. The first
 * place that the attribute appears in is the response received from POST -> /v1/typing REST call. In the body of that response, the value of the
 * "typing_timeout" attribute will be exactly the same as defined in the console. The second place that the attribute appears in is from a
 * notification of type "twilio.ipmsg.typing_indicator". In this case, the "typing_timeout" value will be +1 of that in the console. This
 * intentional. The timeout returned from the POST -> /v1/typing call should be used to disable further calls for that period of time. On contrary,
 * the timeout returned from the notification should be used as the timeout for the "typingEnded" event, +1 is to account for latency.
 *
 * @private
 */
/**
 * @class TypingIndicator
 *
 * @constructor
 * @private
 */
declare class TypingIndicator {
    private readonly getChannel;
    private readonly configuration;
    private readonly services;
    private sentUpdates;
    private serviceTypingTimeout;
    constructor(getChannel: any, configuration: Configuration, services: TypingIndicatorServices);
    get typingTimeout(): number;
    /**
     * Initialize TypingIndicator controller
     * Registers for needed message types and sets listeners
     * @private
     */
    initialize(): void;
    /**
     * Remote members typing events handler
     * @private
     */
    handleRemoteTyping(message: any): void;
    /**
     * Send typing event for the given channel sid
     * @param {String} channelSid
     */
    send(channelSid: string): Promise<void>;
    private _send;
}
interface ChannelServices {
    users: Users;
    typingIndicator: TypingIndicator;
    network: Network;
    mcsClient: McsClient;
    syncClient: SyncClient;
    commandExecutor: CommandExecutor;
}
interface ChannelDescriptor {
    channel: string;
    entityName: string;
    uniqueName: string;
    attributes: any;
    createdBy?: string;
    friendlyName: string;
    lastConsumedMessageIndex: number;
    dateCreated: any;
    dateUpdated: any;
    type: Channel.Type;
    notificationLevel?: Channel.NotificationLevel;
}
interface ChannelLinks {
    self: string;
    messages: string;
    participants: string;
    invites: string;
}
declare namespace Channel {
    type UpdateReason = "attributes" | "createdBy" | "dateCreated" | "dateUpdated" | "friendlyName" | "lastConsumedMessageIndex" | "state" | "status" | "uniqueName" | "lastMessage" | "notificationLevel";
    type Status = "unknown" | "notParticipating" | "invited" | "joined";
    type Type = "public" | "private";
    type NotificationLevel = "default" | "muted";
    type State = {
        current: "active" | "inactive" | "closed";
        dateUpdated: Date;
    } | undefined;
    interface UpdatedEventArgs {
        channel: Channel;
        updateReasons: Channel.UpdateReason[];
    }
    interface SendMediaOptions {
        contentType: string;
        media: string | Buffer;
    }
    interface LastMessage {
        index?: number;
        dateCreated?: Date;
    }
}
/**
 * @classdesc A Channel represents a remote channel of communication between multiple Programmable Chat Clients
 * @property {any} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created this Channel
 * @property {Date} dateCreated - The Date this Channel was created
 * @property {Date} dateUpdated - The Date this Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in this Channel
 * @property {Channel#LastMessage} lastMessage - Last Message sent to this Channel
 * @property {Channel#NotificationLevel} notificationLevel - User Notification level for this Channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {Channel#State} state - The Channel's state
 * @property {Channel#Status} status - The Channel's status
 * @property {Channel#Type} type - The Channel's type
 * @property {String} uniqueName - The Channel's unique name (tag)
 * @fires Channel#memberJoined
 * @fires Channel#memberLeft
 * @fires Channel#memberUpdated
 * @fires Channel#messageAdded
 * @fires Channel#messageRemoved
 * @fires Channel#messageUpdated
 * @fires Channel#typingEnded
 * @fires Channel#typingStarted
 * @fires Channel#updated
 * @fires Channel#removed
 */
declare class Channel extends EventEmitter {
    readonly sid: string;
    readonly links: ChannelLinks;
    private readonly configuration;
    private readonly services;
    private channelState;
    private statusSource;
    private entityPromise;
    private entityName;
    private entity;
    private messagesEntity;
    private membersEntity;
    private members;
    constructor(descriptor: ChannelDescriptor, sid: string, links: ChannelLinks, configuration: Configuration, services: ChannelServices);
    /**
     * The Channel's state. Set to undefined if the channel is not a conversation.
     * @typedef {Object | undefined} Channel#State
     * @property {('active' | 'inactive' | 'closed')} current - the current state
     * @property {Date} dateUpdated - date at which the latest channel state update happened
     */
    /**
     * These options can be passed to {@link Channel#sendMessage}.
     * @typedef {Object} Channel#SendMediaOptions
     * @property {String} contentType - content type of media
     * @property {String | Buffer} media - content to post
     */
    /**
     * The update reason for <code>updated</code> event emitted on Channel
     * @typedef {('attributes' | 'createdBy' | 'dateCreated' | 'dateUpdated' |
     'friendlyName' | 'lastConsumedMessageIndex' | 'state' | 'status' | 'uniqueName' | 'lastMessage' |
     'notificationLevel' )} Channel#UpdateReason
     */
    /**
     * The status of the Channel, relative to the Client: whether the Channel
     * is <code>notParticipating</code> to local Client, Client is <code>invited</code> to or
     * is <code>joined</code> to this Channel
     * @typedef {('unknown' | 'notParticipating' | 'invited' | 'joined')} Channel#Status
     */
    /**
     * The type of Channel (<code>public</code> or <code>private</code>).
     * @typedef {('public' | 'private')} Channel#Type
     */
    /**
     * The User's Notification level for Channel, determines whether the currently logged-in User will receive
     * pushes for events in this Channel. Can be either <code>muted</code> or <code>default</code>,
     * where <code>default</code> defers to global Service push configuration.
     * @typedef {('default' | 'muted')} Channel#NotificationLevel
     */
    get status(): Channel.Status;
    get type(): Channel.Type;
    get uniqueName(): string;
    get isPrivate(): boolean;
    get friendlyName(): string;
    get dateUpdated(): any;
    get dateCreated(): any;
    get createdBy(): string;
    get attributes(): Object;
    get lastConsumedMessageIndex(): number | null;
    get lastMessage(): Channel.LastMessage;
    get notificationLevel(): Channel.NotificationLevel;
    get state(): Channel.State;
    /**
     * The Channel's last message's information.
     * @typedef {Object} Channel#LastMessage
     * @property {Number} index - Message's index
     * @property {Date} dateCreated - Message's creation date
     */
    /**
     * Load and Subscribe to this Channel and do not subscribe to its Members and Messages.
     * This or _subscribeStreams will need to be called before any events on Channel will fire.
     * @returns {Promise}
     * @private
     */
    _subscribe(): Promise<any>;
    /**
     * Load the attributes of this Channel and instantiate its Members and Messages.
     * This or _subscribe will need to be called before any events on Channel will fire.
     * This will need to be called before any events on Members or Messages will fire
     * @returns {Promise}
     * @private
     */
    _subscribeStreams(): Promise<void>;
    /**
     * Stop listening for and firing events on this Channel.
     * @returns {Promise}
     * @private
     */
    _unsubscribe(): Promise<[
        void,
        any
    ]>;
    /**
     * Set channel status
     * @private
     */
    _setStatus(status: Channel.Status, source: Channels.DataSource): void;
    /**
     * If channel's status update source
     * @private
     * @return {Channels.DataSource}
     */
    _statusSource(): Channels.DataSource;
    private static preprocessUpdate;
    /**
     * Updates local channel object with new values
     * @private
     */
    _update(update: any): void;
    /**
     * @private
     */
    private _onMessageAdded;
    private _setLastConsumedMessageIndex;
    /**
     * Add a participant to the Channel by its Identity.
     * @param {String} identity - Identity of the Client to add
     * @returns {Promise<void>}
     */
    add(identity: string): Promise<void>;
    /**
     * Advance last consumed Channel's Message index to current consumption horizon.
     * Rejects if User is not Member of Channel.
     * Last consumed Message index is updated only if new index value is higher than previous.
     * @param {Number} index - Message index to advance to as last read
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    advanceLastConsumedMessageIndex(index: number): Promise<number>;
    /**
     * Decline an invitation to the Channel and unsubscribe from its events.
     * @returns {Promise<Channel>}
     */
    decline(): Promise<Channel>;
    /**
     * Delete the Channel and unsubscribe from its events.
     * @returns {Promise<Channel>}
     */
    delete(): Promise<Channel>;
    /**
     * Get the custom attributes of this Channel.<br/>
     *
     * <i>NOTE: {@link Channel}'s <code>attributes</code> property will be empty for public channels until this function is called.</i>
     * @returns {Promise<any>} attributes of this Channel
     */
    getAttributes(): Promise<any>;
    /**
     * Returns messages from channel using paginator interface.
     * @param {Number} [pageSize=30] Number of messages to return in single chunk
     * @param {Number} [anchor] - Index of newest Message to fetch. From the end by default
     * @param {('backwards'|'forward')} [direction=backwards] - Query direction. By default it query backwards
     *                                                          from newer to older. 'forward' will query in opposite direction
     * @returns {Promise<Paginator<Message>>} page of messages
     */
    getMessages(pageSize?: number, anchor?: number, direction?: "backwards" | "forward"): Promise<Paginator<Message>>;
    /**
     * Get a list of all Members joined to this Channel.
     * @returns {Promise<Member[]>}
     */
    getMembers(): Promise<Member[]>;
    /**
     * Get channel members count.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number>}
     */
    getMembersCount(): Promise<number>;
    /**
     * Get a Member by its SID.
     * @param {String} memberSid - Member sid
     * @returns {Promise<Member>}
     */
    getMemberBySid(memberSid: string): Promise<Member>;
    /**
     * Get a Member by its identity.
     * @param {String} identity - Member identity
     * @returns {Promise<Member>}
     */
    getMemberByIdentity(identity: string): Promise<Member>;
    /**
     * Get total message count in a channel.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any UI badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number>}
     */
    getMessagesCount(): Promise<number>;
    /**
     * Get unconsumed messages count for a User if they are a Member of this Channel.
     * Rejects if the User is not a Member of the Channel.
     * <br/>
     * This method is semi-realtime. This means that this data will be eventually correct,
     * but will also possibly be incorrect for a few seconds. The Chat system does not
     * provide real time events for counter values changes.
     * <br/>
     * So this is quite useful for any “unread messages count” badges, but is not recommended
     * to build any core application logic based on these counters being accurate in real time.
     * @returns {Promise<number|null>}
     */
    getUnconsumedMessagesCount(): Promise<number | null>;
    /**
     * Invite a user to the Channel by their Identity.
     * @param {String} identity - Identity of the user to invite
     * @returns {Promise<void>}
     */
    invite(identity: string): Promise<void>;
    /**
     * Join the Channel and subscribe to its events.
     * @returns {Promise<Channel>}
     */
    join(): Promise<Channel>;
    /**
     * Leave the Channel.
     * @returns {Promise<Channel>}
     */
    leave(): Promise<Channel>;
    /**
     * Remove a Member from the Channel.
     * @param {String|Member} member - Member to remove. Could either be an identity string or a Member instance.
     * @returns {Promise<void>}
     */
    removeMember(member: string | Member): Promise<void>;
    /**
     * Send a Message in the Channel.
     * @param {String|FormData|Channel#SendMediaOptions|null} message - The message body for text message,
     * FormData or MediaOptions for media content. Sending FormData supported only with browser engine
     * @param {any} [messageAttributes] - attributes for the message
     * @returns {Promise<number>} new Message's index in the Channel's messages list
     */
    sendMessage(message: string | FormData | Channel.SendMediaOptions | null, messageAttributes?: any): Promise<number>;
    /**
     * Set last consumed Channel's Message index to last known Message's index in this Channel.
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    setAllMessagesConsumed(): Promise<number>;
    /**
     * Set all messages in the channel unread.
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    setNoMessagesConsumed(): Promise<number>;
    /**
     * Set User Notification level for this channel.
     * @param {Channel#NotificationLevel} notificationLevel - The new user notification level
     * @returns {Promise<void>}
     */
    setUserNotificationLevel(notificationLevel: Channel.NotificationLevel): Promise<void>;
    /**
     * Send a notification to the server indicating that this Client is currently typing in this Channel.
     * Typing ended notification is sent after a while automatically, but by calling again this method you ensure typing ended is not received.
     * @returns {Promise<void>}
     */
    typing(): Promise<void>;
    /**
     * Update the Channel's attributes.
     * @param {any} attributes new attributes for Channel.
     * @returns {Promise<Channel>}
     */
    updateAttributes(attributes: any): Promise<Channel>;
    /**
     * Update the Channel's friendlyName.
     * @param {String} friendlyName - The new Channel friendlyName
     * @returns {Promise<Channel>}
     */
    updateFriendlyName(friendlyName: string): Promise<Channel>;
    /**
     * Set last consumed Channel's Message index to current consumption horizon.
     * @param {Number|null} index - Message index to set as last read.
     * If null provided, then the behavior is identical to {@link Channel#setNoMessagesConsumed}
     * @returns {Promise<number>} resulting unread messages count in the channel
     */
    updateLastConsumedMessageIndex(index: number | null): Promise<number>;
    /**
     * Update the Channel's unique name.
     * @param {String|null} uniqueName - New unique name for the Channel. Setting unique name to null removes it.
     * @returns {Promise<Channel>}
     */
    updateUniqueName(uniqueName: string | null): Promise<Channel>;
    /**
     * Gets User Descriptors for this channel.
     * @returns {Promise<Paginator<UserDescriptor>>}
     */
    getUserDescriptors(): Promise<Paginator<UserDescriptor>>;
}
/**
 * Contains channel information.
 * Unlike {@link Channel}, this information won't be updated in realtime.
 * To have a fresh data, user should query channel descriptors again.
 *
 * @property {any} attributes - The Channel's custom attributes
 * @property {String} createdBy - The identity of the User that created Channel
 * @property {Date} dateCreated - The Date Channel was created
 * @property {Date} dateUpdated - The Date Channel was last updated
 * @property {String} friendlyName - The Channel's name
 * @property {Boolean} isPrivate - Whether the channel is private (as opposed to public)
 * @property {Number} lastConsumedMessageIndex - Index of the last Message the User has consumed in Channel
 * @property {Number} membersCount Number of members in a channel
 * @property {Number} messagesCount Number of messages in a channel
 * @property {String} sid - The Channel's unique system identifier
 * @property {Channel#Status} status - The Channel's status
 * @property {Channel#Type} type - The Channel's type
 * @property {String} uniqueName - The Channel's unique name
 */
declare class ChannelDescriptor$0 {
    client: Client;
    descriptor: any;
    readonly sid: string;
    readonly channel: string;
    readonly uniqueName: string;
    readonly friendlyName: string;
    readonly attributes: any;
    readonly createdBy: string;
    readonly dateCreated: Date;
    readonly dateUpdated: Date;
    readonly messagesCount: number;
    readonly membersCount: number;
    readonly lastConsumedMessageIndex: number;
    readonly status: Channel.Status;
    readonly type: Channel.Type;
    readonly isPrivate: boolean;
    readonly notificationLevel: Channel.NotificationLevel;
    /**
     * @param {Client} client Chat client instance
     * @param {Object} descriptor Channel descriptor data object
     * @private
     */
    constructor(client: Client, descriptor: any);
    /**
     * Get channel object from descriptor.
     * @returns {Promise<Channel>}
     */
    getChannel(): Promise<Channel>;
}
interface ChannelsServices {
    syncClient: SyncClient;
    users: Users;
    typingIndicator: TypingIndicator;
    network: Network;
    mcsClient: McsClient;
    commandExecutor: CommandExecutor;
}
/**
 * Represents channels collection
 * {@see Channel}
 */
declare class Channels extends EventEmitter {
    private readonly configuration;
    private readonly services;
    readonly channels: Map<string, Channel>;
    private readonly tombstones;
    private myChannelsFetched;
    private myChannelsRead;
    constructor(configuration: Configuration, services: ChannelsServices);
    private getMap;
    /**
     * Add channel to server
     * @private
     * @returns {Promise<Channel>} Channel
     */
    addChannel(options: any): Promise<Channel>;
    /**
     * Fetch channels list and instantiate all necessary objects
     */
    fetchChannels(): Promise<this>;
    private _wrapPaginator;
    getChannels(args: any): Promise<any>;
    getChannel(sid: string): Promise<Channel>;
    pushChannel(descriptor: ChannelDescriptor$0): Promise<Channel>;
    private _updateChannel;
    private upsertChannel;
    private onChannelRemoved;
    private registerForEvents;
    private _fetchMyChannels;
}
declare namespace Channels {
    type DataSource = "sync" | "chat" | "rest";
}
declare namespace PushNotification {
    type Type = "twilio.channel.new_message" | "twilio.channel.added_to_channel" | "twilio.channel.invited_to_channel" | "twilio.channel.removed_from_channel";
    interface Descriptor {
        title: string;
        body: string;
        sound: string;
        badge: number;
        action: string;
        type: PushNotification.Type;
        data: Object;
    }
}
/**
 * @classdesc Push notification representation within Chat Client
 * @property {String} [action] - Notification action (`click_action` in FCM/GCM terms and `category` in APN terms)
 * @property {Number} [badge] - Number for the badge
 * @property {String} body - Notification text
 * @property {PushNotification#ChatData} data - Additional Chat data
 * @property {String} [sound] - Notification sound
 * @property {String} [title] - Notification title
 * @property {PushNotification#NotificationType} type - Notification type
 */
declare class PushNotification {
    readonly title: string;
    readonly body: string;
    readonly sound: string;
    readonly badge: number;
    readonly action: string;
    readonly type: PushNotification.Type;
    readonly data: Object;
    /**
     * Chat push notification type
     * @typedef {('twilio.channel.new_message' | 'twilio.channel.added_to_channel'
     | 'twilio.channel.invited_to_channel'  | 'twilio.channel.removed_from_channel')} PushNotification#NotificationType
     */
    /**
     * Additional Chat data for given Push Notification
     * @typedef {Object} PushNotification#ChatData
     * @property {String} [channelSid] - SID of Channel
     * @property {Number} [messageIndex] - Index of Message in Channel
     * @property {String} [messageSid] - SID of Message
     */
    /**
     * @param {PushNotification.Descriptor} data - initial data for PushNotification
     */
    constructor(data: PushNotification.Descriptor);
}
declare namespace Client {
    type ConnectionState = NotificationConnectionState;
    type NotificationsChannelType = ChannelType;
    type LogLevel = "trace" | "debug" | "info" | "warn" | "error" | "silent" | null;
    interface Options {
        region?: string;
        logLevel?: Client.LogLevel;
        productId?: string;
        twilsockClient?: TwilsockClient;
        transport?: Transport;
        notificationsClient?: NotificationClient;
        syncClient?: SyncClient;
        typingIndicatorTimeoutOverride?: number;
        consumptionReportIntervalOverride?: string;
        httpCacheIntervalOverride?: string;
        userInfosToSubscribeOverride?: number;
        retryWhenThrottledOverride?: boolean;
        backoffConfigOverride?: any;
        Chat?: any;
        IPMessaging?: any;
        Sync?: any;
        Notification?: any;
        Twilsock?: any;
        clientMetadata?: any;
        disableDeepClone?: boolean;
    }
    interface CreateChannelOptions {
        attributes?: any;
        friendlyName?: string;
        isPrivate?: boolean;
        uniqueName?: string;
    }
    type ChannelSortingCriteria = "lastMessage" | "friendlyName" | "uniqueName";
    type ChannelSortingOrder = "ascending" | "descending";
    interface ChannelSortingOptions {
        criteria?: ChannelSortingCriteria;
        order?: ChannelSortingOrder;
    }
}
/**
 * A Client is a starting point to access Twilio Programmable Chat functionality.
 *
 * @property {Client#ConnectionState} connectionState - Client connection state
 * @property {Boolean} reachabilityEnabled - Client reachability state
 * @property {User} user - Information for logged in user
 * @property {String} version - Current version of Chat client
 *
 * @fires Client#connectionError
 * @fires Client#connectionStateChanged
 * @fires Client#channelAdded
 * @fires Client#channelInvited
 * @fires Client#channelJoined
 * @fires Client#channelLeft
 * @fires Client#channelRemoved
 * @fires Client#channelUpdated
 * @fires Client#memberJoined
 * @fires Client#memberLeft
 * @fires Client#memberUpdated
 * @fires Client#messageAdded
 * @fires Client#messageRemoved
 * @fires Client#messageUpdated
 * @fires Client#pushNotification
 * @fires Client#tokenAboutToExpire
 * @fires Client#tokenExpired
 * @fires Client#typingEnded
 * @fires Client#typingStarted
 * @fires Client#userSubscribed
 * @fires Client#userUnsubscribed
 * @fires Client#userUpdated
 */
declare class Client extends EventEmitter {
    private readonly options;
    connectionState: Client.ConnectionState;
    private channelsPromise;
    private configurationPromise;
    private fpaToken;
    private configuration;
    private channels;
    private services;
    static readonly version: string;
    readonly version: string;
    private static readonly supportedPushChannels;
    private static readonly supportedPushDataFields;
    private constructor();
    /**
     * These options can be passed to {@link Client#getLocalChannels}.
     * @typedef {Object} Client#ChannelSortingOptions
     * @property {('lastMessage'|'friendlyName'|'uniqueName')} [criteria] - Sorting criteria for Channels array
     * @property {('ascending'|'descending')} [order] - Sorting order. If not present, then default is <code>ascending</code>
     */
    /**
     * These options can be passed to Client constructor.
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * These options can be passed to {@link Client#createChannel}.
     * @typedef {Object} Client#CreateChannelOptions
     * @property {any} [attributes] - Any custom attributes to attach to the Channel
     * @property {String} [friendlyName] - The non-unique display name of the Channel
     * @property {Boolean} [isPrivate] - Whether or not this Channel should be visible to uninvited Clients
     * @property {String} [uniqueName] - The unique identity name of the Channel
     */
    /**
     * Connection state of Client.
     * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied')} Client#ConnectionState
     */
    /**
     * Notifications channel type.
     * @typedef {('gcm'|'fcm'|'apn')} Client#NotificationsChannelType
     */
    /**
     * Factory method to create Chat client instance.
     *
     * @param {String} token - Access token
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     * @returns {Promise<Client>}
     */
    static create(token: string, options?: Client.Options): Promise<Client>;
    get user(): User;
    get reachabilityEnabled(): boolean;
    get token(): string;
    private subscribeToPushNotifications;
    private unsubscribeFromPushNotifications;
    private initialize;
    /**
     * Gracefully shutting down library instance.
     * @public
     * @returns {Promise<void>}
     */
    shutdown(): Promise<void>;
    /**
     * Update the token used by the Client and re-register with Programmable Chat services.
     * @param {String} token - Access token
     * @public
     * @returns {Promise<Client>}
     */
    updateToken(token: string): Promise<Client>;
    /**
     * Get a known Channel by its SID.
     * @param {String} channelSid - Channel sid
     * @returns {Promise<Channel>}
     */
    getChannelBySid(channelSid: string): Promise<Channel>;
    /**
     * Get a known Channel by its unique identifier name.
     * @param {String} uniqueName - The unique identifier name of the Channel to get
     * @returns {Promise<Channel>}
     */
    getChannelByUniqueName(uniqueName: string): Promise<Channel>;
    /**
     * Get the current list of all subscribed Channels.
     * @returns {Promise<Paginator<Channel>>}
     */
    getSubscribedChannels(args?: any): Promise<Paginator<Channel>>;
    /**
     * Get array of Channels locally known to Client in provided sorting order.
     * Locally known channels are the ones created and/or joined during client runtime and currently logged in User subscribed Channels.
     * To ensure full list of subscribed Channels fetched - call the {@link Client#getSubscribedChannels} method
     * and fetch all pages with help of {@link Paginator#nextPage} method.
     * @param {Client#ChannelSortingOptions} [sortingOptions] - Options for the Channel sorting
     * @returns {Promise<Array<Channel>>}
     */
    getLocalChannels(sortingOptions?: Client.ChannelSortingOptions): Promise<Array<Channel>>;
    private static compareChannelsByLastMessage;
    private static compareChannelsByStringProperty;
    /**
     * Get the public channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getPublicChannelDescriptors(): Promise<Paginator<ChannelDescriptor$0>>;
    /**
     * Get the User's (created by, joined or invited to) channels directory content.
     * @returns {Promise<Paginator<ChannelDescriptor>>}
     */
    getUserChannelDescriptors(): Promise<Paginator<ChannelDescriptor$0>>;
    /**
     * Create a Channel on the server and subscribe to its events.
     * Default options are public Channel type with empty uniqueName and friendlyName.
     * @param {Client#CreateChannelOptions} [options] - Options for the Channel
     * @returns {Promise<Channel>}
     */
    createChannel(options?: Client.CreateChannelOptions): Promise<Channel>;
    /**
     * Registers for push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @param {string} registrationId - Push notification id provided by platform
     * @returns {Promise<void>}
     */
    setPushRegistrationId(channelType: Client.NotificationsChannelType, registrationId: string): Promise<void>;
    /**
     * Unregisters from push notifications.
     * @param {Client#NotificationsChannelType} channelType - 'gcm', 'apn' and 'fcm' are supported
     * @returns {Promise<void>}
     */
    unsetPushRegistrationId(channelType: Client.NotificationsChannelType): Promise<void>;
    private static parsePushNotificationChatData;
    /**
     * Static method for push notification payload parsing. Returns parsed push as {@link PushNotification} object
     * @param {Object} notificationPayload - Push notification payload
     * @returns {PushNotification|Error}
     */
    static parsePushNotification(notificationPayload: any): PushNotification;
    parsePushNotification: typeof Client.parsePushNotification;
    /**
     * Handle push notification payload parsing and emits event {@link Client#event:pushNotification} on this {@link Client} instance.
     * @param {Object} notificationPayload - Push notification payload
     * @returns {Promise<void>}
     */
    handlePushNotification(notificationPayload: any): Promise<void>;
    /**
     * Gets user for given identity, if it's in subscribed list - then return the user object from it,
     * if not - then subscribes and adds user to the subscribed list.
     * @param {String} identity - Identity of User
     * @returns {Promise<User>} Fully initialized user
     */
    getUser(identity: string): Promise<User>;
    /**
     * Gets user descriptor for given identity.
     * @param {String} identity - Identity of User
     * @returns {Promise<UserDescriptor>} User descriptor
     */
    getUserDescriptor(identity: string): Promise<UserDescriptor>;
    /**
     * @returns {Promise<Array<User>>} List of subscribed User objects
     */
    getSubscribedUsers(): Promise<Array<User>>;
}
export { Client as default, Client, User, PushNotification };
