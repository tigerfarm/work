"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.McsMedia = exports.Media = exports.McsClient = exports.Client = void 0;
var logger_1 = require("./logger");
var configuration_1 = require("./configuration");
var media_1 = require("./media");
Object.defineProperty(exports, "Media", { enumerable: true, get: function get() {
        return media_1.Media;
    } });
Object.defineProperty(exports, "McsMedia", { enumerable: true, get: function get() {
        return media_1.Media;
    } });
var transport_1 = require("./services/transport");
var network_1 = require("./services/network");
var log = logger_1.Logger.scope('');
//log.setLevel('trace');
var SDK_VERSION = require('./../package.json').version;
var MSG_NO_TOKEN = 'A valid Twilio token should be provided';
/**
 * @classdesc A Client provides an interface for Media Content Service
 */

var Client = function () {
    /**
     * @param {String} token - Access token
     * @param {String} baseUrl - Base URL for Media Content Service, i.e. /v1/Services/{serviceSid}/Media
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     */
    function Client(token, baseUrl) {
        var options = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : {};
        (0, _classCallCheck3.default)(this, Client);

        this.options = options;
        this.options.logLevel = this.options.logLevel || 'silent';
        this.config = new configuration_1.Configuration(token, baseUrl, this.options);
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        log.setLevel(this.options.logLevel);
        this.options.transport = this.options.transport || new transport_1.Transport();
        this.transport = this.options.transport;
        this.network = new network_1.Network(this.config, this.transport);
    }
    /**
     * These options can be passed to Client constructor
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * Update the token used for Client operations
     * @param {String} token - The JWT string of the new token
     * @public
     * @returns {void}
     */


    (0, _createClass3.default)(Client, [{
        key: "updateToken",
        value: function updateToken(token) {
            log.info('updateToken');
            if (!token) {
                throw new Error(MSG_NO_TOKEN);
            }
            this.config.updateToken(token);
        }
        /**
         * Gets media from media service
         * @param {String} sid - Media's SID
         * @public
         * @returns {Promise<Media>}
         */

    }, {
        key: "get",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(sid) {
                var response;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                _context.next = 2;
                                return this.network.get(this.config.baseUrl + "/" + sid);

                            case 2:
                                response = _context.sent;
                                return _context.abrupt("return", new media_1.Media(this.config, this.network, response.body));

                            case 4:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function get(_x2) {
                return _ref.apply(this, arguments);
            }

            return get;
        }()
        /**
         * Posts raw content to media service
         * @param {String} contentType - content type of media
         * @param {String|Buffer} media - content to post
         * @public
         * @returns {Promise<Media>}
         */

    }, {
        key: "post",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(contentType, media) {
                var response;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                _context2.next = 2;
                                return this.network.post(this.config.baseUrl, media, contentType);

                            case 2:
                                response = _context2.sent;
                                return _context2.abrupt("return", new media_1.Media(this.config, this.network, response.body));

                            case 4:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function post(_x3, _x4) {
                return _ref2.apply(this, arguments);
            }

            return post;
        }()
        /**
         * Posts FormData to media service. Can be used only with browser engine's FormData.
         * In non-browser FormData case the method will do promise reject with
         * new TypeError("Posting FormData supported only with browser engine's FormData")
         * @param {FormData} formData - form data to post
         * @public
         * @returns {Promise<Media>}
         */

    }, {
        key: "postFormData",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(formData) {
                var response;
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                _context3.next = 2;
                                return this.network.post(this.config.baseUrl, formData);

                            case 2:
                                response = _context3.sent;
                                return _context3.abrupt("return", new media_1.Media(this.config, this.network, response.body));

                            case 4:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function postFormData(_x5) {
                return _ref3.apply(this, arguments);
            }

            return postFormData;
        }()
    }]);
    return Client;
}();

exports.Client = Client;
exports.McsClient = Client;
Client.version = SDK_VERSION;
exports.default = Client;