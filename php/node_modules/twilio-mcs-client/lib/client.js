"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.McsMedia = exports.Media = exports.McsClient = exports.Client = void 0;
const logger_1 = require("./logger");
const configuration_1 = require("./configuration");
const media_1 = require("./media");
Object.defineProperty(exports, "Media", { enumerable: true, get: function () { return media_1.Media; } });
Object.defineProperty(exports, "McsMedia", { enumerable: true, get: function () { return media_1.Media; } });
const transport_1 = require("./services/transport");
const network_1 = require("./services/network");
const log = logger_1.Logger.scope('');
//log.setLevel('trace');
const SDK_VERSION = require('./../package.json').version;
const MSG_NO_TOKEN = 'A valid Twilio token should be provided';
/**
 * @classdesc A Client provides an interface for Media Content Service
 */
class Client {
    /**
     * @param {String} token - Access token
     * @param {String} baseUrl - Base URL for Media Content Service, i.e. /v1/Services/{serviceSid}/Media
     * @param {Client#ClientOptions} [options] - Options to customize the Client
     */
    constructor(token, baseUrl, options = {}) {
        this.options = options;
        this.options.logLevel = this.options.logLevel || 'silent';
        this.config = new configuration_1.Configuration(token, baseUrl, this.options);
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        log.setLevel(this.options.logLevel);
        this.options.transport = this.options.transport || new transport_1.Transport();
        this.transport = this.options.transport;
        this.network = new network_1.Network(this.config, this.transport);
    }
    /**
     * These options can be passed to Client constructor
     * @typedef {Object} Client#ClientOptions
     * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
     *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
     */
    /**
     * Update the token used for Client operations
     * @param {String} token - The JWT string of the new token
     * @public
     * @returns {void}
     */
    updateToken(token) {
        log.info('updateToken');
        if (!token) {
            throw new Error(MSG_NO_TOKEN);
        }
        this.config.updateToken(token);
    }
    /**
     * Gets media from media service
     * @param {String} sid - Media's SID
     * @public
     * @returns {Promise<Media>}
     */
    async get(sid) {
        let response = await this.network.get(`${this.config.baseUrl}/${sid}`);
        return new media_1.Media(this.config, this.network, response.body);
    }
    /**
     * Posts raw content to media service
     * @param {String} contentType - content type of media
     * @param {String|Buffer} media - content to post
     * @public
     * @returns {Promise<Media>}
     */
    async post(contentType, media) {
        let response = await this.network.post(this.config.baseUrl, media, contentType);
        return new media_1.Media(this.config, this.network, response.body);
    }
    /**
     * Posts FormData to media service. Can be used only with browser engine's FormData.
     * In non-browser FormData case the method will do promise reject with
     * new TypeError("Posting FormData supported only with browser engine's FormData")
     * @param {FormData} formData - form data to post
     * @public
     * @returns {Promise<Media>}
     */
    async postFormData(formData) {
        let response = await this.network.post(this.config.baseUrl, formData);
        return new media_1.Media(this.config, this.network, response.body);
    }
}
exports.Client = Client;
exports.McsClient = Client;
Client.version = SDK_VERSION;
exports.default = Client;
