"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Transport = void 0;
const transporterror_1 = require("./transporterror");
const XHR = global['XMLHttpRequest'] || require('xmlhttprequest').XMLHttpRequest;
function parseResponseHeaders(headerString) {
    if (!headerString) {
        return {};
    }
    return headerString
        .split('\u000d\u000a')
        .map(el => el.split('\u003a\u0020'))
        .filter(el => el.length === 2 && el[1].length > 0)
        .reduce((prev, curr) => {
        prev[curr[0]] = curr[1];
        return prev;
    }, {});
}
function extractBody(xhr) {
    const contentType = xhr.getResponseHeader('Content-Type');
    if (!contentType || contentType.indexOf('application/json') !== 0 || xhr.responseText.length === 0) {
        return xhr.responseText;
    }
    try {
        return JSON.parse(xhr.responseText);
    }
    catch (e) {
        return xhr.responseText;
    }
}
function adaptHttpResponse(response) {
    try {
        response.body = JSON.parse(response.body);
    }
    catch (e) {
    } // eslint-disable-line no-empty
    return response;
}
/**
 * Provides generic network interface
 */
class Transport {
    constructor() {
    }
    static request(method, url, headers, body) {
        return new Promise((resolve, reject) => {
            let xhr = new XHR();
            xhr.open(method, url, true);
            xhr.onreadystatechange = function onreadystatechange() {
                if (xhr.readyState !== 4) {
                    return;
                }
                const headers = parseResponseHeaders(xhr.getAllResponseHeaders());
                const body = extractBody(xhr);
                if (200 <= xhr.status && xhr.status < 300) {
                    resolve({ status: xhr.status, headers, body });
                }
                else {
                    const status = xhr.statusText && xhr.statusText.code ? xhr.statusText.code : 'NONE';
                    let bodyRepresentation;
                    if (typeof body === 'string') {
                        bodyRepresentation = body && body.split('\n', 2).length === 1
                            ? body
                            : '';
                    }
                    else {
                        bodyRepresentation = JSON.stringify(body);
                    }
                    const message = `${xhr.status}: [${status}] ${bodyRepresentation}`;
                    reject(new transporterror_1.TransportError(message, xhr.status, body, status, headers));
                }
            };
            for (let headerName in headers) {
                xhr.setRequestHeader(headerName, headers[headerName]);
                if (headerName === 'Content-Type' && headers[headerName] === 'application/json') {
                    body = JSON.stringify(body);
                }
            }
            xhr.send(body);
        });
    }
    /**
     * Make a GET request by given URL
     */
    get(url, headers) {
        return Transport.request('GET', url, headers);
    }
    /**
     * Make a POST request by given URL
     */
    post(url, headers, body) {
        return Transport.request('POST', url, headers, body);
    }
}
exports.Transport = Transport;
