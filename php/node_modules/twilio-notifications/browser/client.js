"use strict";

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
var events_1 = require("events");
var twilsock_1 = require("twilsock");
var configuration_1 = require("./configuration");
var registrar_1 = require("./registrar");
var logger_1 = require("./logger");
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 */

var Client = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Client, _events_1$EventEmitte);

    function Client(token) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, _classCallCheck3.default)(this, Client);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));

        if (!token || token.length === 0) {
            throw new Error('Token is required for Notifications client');
        }
        options.logLevel = options.logLevel || 'error';
        logger_1.log.setLevel(options.logLevel);
        var minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;
        var productId = options.productId || 'notifications';
        options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);
        options.transport = options.transport || options.twilsockClient;
        _this.services = {
            twilsock: options.twilsockClient,
            transport: options.transport,
            config: new configuration_1.Configuration(null, options)
        };
        _this.registrar = new registrar_1.Registrar(productId, _this.services.transport, _this.services.twilsock, _this.services.config);
        _this.reliableTransportState = {
            overall: false,
            transport: false,
            registration: false,
            lastEmitted: null
        };
        _this._onTransportStateChange(_this.services.twilsock.isConnected);
        _this.registrar.on('transportReady', function (state) {
            _this._onRegistrationStateChange(state ? 'registered' : '');
        });
        _this.registrar.on('stateChanged', function (state) {
            _this._onRegistrationStateChange(state);
        });
        _this.registrar.on('needReliableTransport', _this._onNeedReliableTransport.bind(_this));
        _this.services.twilsock.on('message', function (type, message) {
            return _this._routeMessage(type, message);
        });
        _this.services.twilsock.on('connected', function (notificationId) {
            _this._onTransportStateChange(true);
            _this.registrar.setNotificationId('twilsock', notificationId);
        });
        _this.services.twilsock.on('disconnected', function () {
            _this._onTransportStateChange(false);
        });
        _this.services.config.updateToken(token);
        _this.registrar.updateToken(token);
        return _this;
    }

    (0, _createClass3.default)(Client, [{
        key: "_routeMessage",

        /**
         * Routes messages to the external subscribers
         * @private
         */
        value: function _routeMessage(type, message) {
            logger_1.log.trace('Message arrived: ', type, message);
            this.emit('message', type, message);
        }
    }, {
        key: "_onNeedReliableTransport",
        value: function _onNeedReliableTransport(isNeeded) {
            if (isNeeded) {
                this.services.twilsock.connect();
            } else {
                this.services.twilsock.disconnect();
            }
        }
    }, {
        key: "_onRegistrationStateChange",
        value: function _onRegistrationStateChange(state) {
            this.reliableTransportState.registration = state === 'registered';
            this._updateTransportState();
        }
    }, {
        key: "_onTransportStateChange",
        value: function _onTransportStateChange(connected) {
            this.reliableTransportState.transport = connected;
            this._updateTransportState();
        }
    }, {
        key: "_updateTransportState",
        value: function _updateTransportState() {
            var overallState = this.reliableTransportState.transport && this.reliableTransportState.registration;
            if (this.reliableTransportState.overall !== overallState) {
                this.reliableTransportState.overall = overallState;
                logger_1.log.info('Transport ready:', overallState);
                this.emit('transportReady', overallState);
            }
            if (this.reliableTransportState.lastEmitted !== this.connectionState) {
                this.reliableTransportState.lastEmitted = this.connectionState;
                this.emit('connectionStateChanged', this.connectionState);
            }
        }
        /**
         * Adds the subscription for the given message type
         * @param {string} messageType The type of message that you want to receive
         * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'
         */

    }, {
        key: "subscribe",
        value: function subscribe(messageType) {
            var channelType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'twilsock';

            logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);
            return this.registrar.subscribe(messageType, channelType);
        }
        /**
         * Remove the subscription for the particular message type
         * @param {string} messageType The type of message that you don't want to receive anymore
         * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'
         */

    }, {
        key: "unsubscribe",
        value: function unsubscribe(messageType) {
            var channelType = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'twilsock';

            logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);
            return this.registrar.unsubscribe(messageType, channelType);
        }
        /**
         * Handle incoming push notification.
         * Client application should call this method when it receives push notifications and pass the received data
         * @param {Object} message push message
         * @return {PushNotification}
         */

    }, {
        key: "handlePushNotification",
        value: function handlePushNotification(message) {
            return {
                messageType: message.twi_message_type,
                payload: message.payload
            };
        }
        /**
         * Set APN/GCM/FCM token to enable application register for a push messages
         * @param {string} gcmToken/fcmToken Token received from GCM/FCM system
         */

    }, {
        key: "setPushRegistrationId",
        value: function setPushRegistrationId(registrationId, channelType) {
            logger_1.log.trace('Set push registration id', registrationId, channelType);
            this.registrar.setNotificationId(channelType, registrationId);
        }
        /**
         * Updates auth token for registration
         * @param {string} token Authentication token for registrations
         */

    }, {
        key: "updateToken",
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(token) {
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                logger_1.log.info('authTokenUpdated');

                                if (!(this.services.config.token === token)) {
                                    _context.next = 3;
                                    break;
                                }

                                return _context.abrupt("return");

                            case 3:
                                _context.next = 5;
                                return this.services.twilsock.updateToken(token);

                            case 5:
                                this.services.config.updateToken(token);
                                this.registrar.updateToken(token);

                            case 7:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this);
            }));

            function updateToken(_x4) {
                return _ref.apply(this, arguments);
            }

            return updateToken;
        }()
    }, {
        key: "connectionState",
        get: function get() {
            if (this.services.twilsock.state === 'disconnected') {
                return 'disconnected';
            } else if (this.services.twilsock.state === 'disconnecting') {
                return 'disconnecting';
            } else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {
                return 'connected';
            } else if (this.services.twilsock.state === 'rejected') {
                return 'denied';
            }
            return 'connecting';
        }
    }]);
    return Client;
}(events_1.EventEmitter);

exports.Client = Client;
/**
 * Fired when new message arrived.
 * @param {Object} message`
 * @event Client#message
 */
/**
 * Fired when transport state has changed
 * @param {boolean} transport state
 * @event Client#transportReady
 */
/**
 * Fired when transport state has been changed
 * @param {string} transport state
 * @event Client#connectionStateChanged
 */
/**
 * These options can be passed to Client constructor
 * @typedef {Object} Notifications#ClientOptions
 * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
 *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
 */