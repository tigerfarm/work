"use strict";

var _map = require("babel-runtime/core-js/map");

var _map2 = _interopRequireDefault(_map);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
exports.Registrar = void 0;
var events_1 = require("events");
var registrar_connector_1 = require("./registrar.connector");
var twilsock_connector_1 = require("./twilsock.connector");
/**
 * Provides an interface to the ERS registrar
 */

var Registrar = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Registrar, _events_1$EventEmitte);

    /**
     * Creates the new instance of registrar client
     */
    function Registrar(productId, transport, twilsock, config) {
        (0, _classCallCheck3.default)(this, Registrar);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Registrar.__proto__ || (0, _getPrototypeOf2.default)(Registrar)).call(this));

        _this.config = config;
        _this.connectors = new _map2.default();
        var platform = _this.detectPlatform();
        _this.connectors.set('gcm', new registrar_connector_1.RegistrarConnector('gcm', { protocolVersion: 3, productId: productId, platform: platform }, transport, config));
        _this.connectors.set('fcm', new registrar_connector_1.RegistrarConnector('fcm', { protocolVersion: 3, productId: productId, platform: platform }, transport, config));
        _this.connectors.set('apn', new registrar_connector_1.RegistrarConnector('apn', { protocolVersion: 4, productId: productId, platform: platform }, transport, config));
        _this.connectors.set('twilsock', new twilsock_connector_1.TwilsockConnector({ productId: productId, platform: platform }, twilsock, config));
        _this.connectors.get('twilsock').on('transportReady', function (state) {
            return _this.emit('transportReady', state);
        });
        return _this;
    }
    /**
     *  Sets notification ID.
     *  If new URI is different from previous, it triggers updating of registration for given channel
     *
     *  @param {string} channelType channel type (apn|gcm|fcm|twilsock)
     *  @param {string} notificationId The notification ID
     */


    (0, _createClass3.default)(Registrar, [{
        key: "setNotificationId",
        value: function setNotificationId(channelType, notificationId) {
            this.connector(channelType).setNotificationId(notificationId);
        }
        /**
         * Subscribe for given type of message
         *
         * @param {String} messageType Message type identifier
         * @param {String} channelType Channel type, can be 'twilsock', 'gcm' or 'fcm'
         * @public
         */

    }, {
        key: "subscribe",
        value: function subscribe(messageType, channelType) {
            return this.connector(channelType).subscribe(messageType);
        }
        /**
         * Remove subscription
         * @param {String} messageType Message type
         * @param {String} channelType Channel type (twilsock or gcm/fcm)
         */

    }, {
        key: "unsubscribe",
        value: function unsubscribe(messageType, channelType) {
            return this.connector(channelType).unsubscribe(messageType);
        }
    }, {
        key: "updateToken",
        value: function updateToken(token) {
            this.connectors.forEach(function (connector) {
                return connector.updateToken(token);
            });
        }
        /**
         * @param {String} type Channel type
         * @throws {Error} Error with description
         */

    }, {
        key: "connector",
        value: function connector(type) {
            var connector = this.connectors.get(type);
            if (!connector) {
                throw new Error("Unknown channel type: " + type);
            }
            return connector;
        }
        /**
         * Returns platform string limited to max 128 chars
         */

    }, {
        key: "detectPlatform",
        value: function detectPlatform() {
            var platform = '';
            if (typeof navigator !== 'undefined') {
                platform = 'unknown';
                if (typeof navigator.product !== 'undefined') {
                    platform = navigator.product;
                }
                if (typeof navigator.userAgent !== 'undefined') {
                    platform = navigator.userAgent;
                }
            } else {
                platform = 'web';
            }
            return platform.substring(0, 128);
        }
    }]);
    return Registrar;
}(events_1.EventEmitter);

exports.Registrar = Registrar;