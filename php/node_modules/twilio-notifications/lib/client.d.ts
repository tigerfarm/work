/// <reference types="node" />
import { EventEmitter } from 'events';
import { ChannelType } from './registrar';
declare type ConnectionState = 'connecting' | 'connected' | 'disconnecting' | 'disconnected' | 'denied';
interface PushNotification {
    messageType: string;
    payload: any;
}
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 */
declare class Client extends EventEmitter {
    private readonly registrar;
    private readonly reliableTransportState;
    private services;
    constructor(token: string, options?: any);
    get connectionState(): ConnectionState;
    /**
     * Routes messages to the external subscribers
     * @private
     */
    private _routeMessage;
    private _onNeedReliableTransport;
    private _onRegistrationStateChange;
    private _onTransportStateChange;
    private _updateTransportState;
    /**
     * Adds the subscription for the given message type
     * @param {string} messageType The type of message that you want to receive
     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'
     */
    subscribe(messageType: string, channelType?: ChannelType): Promise<void>;
    /**
     * Remove the subscription for the particular message type
     * @param {string} messageType The type of message that you don't want to receive anymore
     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'
     */
    unsubscribe(messageType: string, channelType?: ChannelType): Promise<void>;
    /**
     * Handle incoming push notification.
     * Client application should call this method when it receives push notifications and pass the received data
     * @param {Object} message push message
     * @return {PushNotification}
     */
    handlePushNotification(message: any): PushNotification;
    /**
     * Set APN/GCM/FCM token to enable application register for a push messages
     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system
     */
    setPushRegistrationId(registrationId: string, channelType: ChannelType): void;
    /**
     * Updates auth token for registration
     * @param {string} token Authentication token for registrations
     */
    updateToken(token: string): Promise<void>;
}
export { ChannelType, ConnectionState, PushNotification, Client };
/**
 * Fired when new message arrived.
 * @param {Object} message`
 * @event Client#message
 */
/**
 * Fired when transport state has changed
 * @param {boolean} transport state
 * @event Client#transportReady
 */
/**
 * Fired when transport state has been changed
 * @param {string} transport state
 * @event Client#connectionStateChanged
 */
/**
 * These options can be passed to Client constructor
 * @typedef {Object} Notifications#ClientOptions
 * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
 *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
 */
