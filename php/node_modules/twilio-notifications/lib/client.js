"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Client = void 0;
const events_1 = require("events");
const twilsock_1 = require("twilsock");
const configuration_1 = require("./configuration");
const registrar_1 = require("./registrar");
const logger_1 = require("./logger");
/**
 * @class
 * @alias Notifications
 * @classdesc The helper library for the notification service.
 * Provides high level api for creating and managing notification subscriptions and receiving messages
 * Creates the instance of Notification helper library
 *
 * @constructor
 * @param {string} token - Twilio access token
 * @param {Notifications#ClientOptions} options - Options to customize client behavior
 */
class Client extends events_1.EventEmitter {
    constructor(token, options = {}) {
        super();
        if (!token || token.length === 0) {
            throw new Error('Token is required for Notifications client');
        }
        options.logLevel = options.logLevel || 'error';
        logger_1.log.setLevel(options.logLevel);
        const minTokenRefreshInterval = options.minTokenRefreshInterval || 10000;
        const productId = options.productId || 'notifications';
        options.twilsockClient = options.twilsockClient || new twilsock_1.TwilsockClient(token, productId, options);
        options.transport = options.transport || options.twilsockClient;
        this.services = {
            twilsock: options.twilsockClient,
            transport: options.transport,
            config: new configuration_1.Configuration(null, options)
        };
        this.registrar = new registrar_1.Registrar(productId, this.services.transport, this.services.twilsock, this.services.config);
        this.reliableTransportState = {
            overall: false,
            transport: false,
            registration: false,
            lastEmitted: null
        };
        this._onTransportStateChange(this.services.twilsock.isConnected);
        this.registrar.on('transportReady', state => {
            this._onRegistrationStateChange(state ? 'registered' : '');
        });
        this.registrar.on('stateChanged', (state) => {
            this._onRegistrationStateChange(state);
        });
        this.registrar.on('needReliableTransport', this._onNeedReliableTransport.bind(this));
        this.services.twilsock.on('message', (type, message) => this._routeMessage(type, message));
        this.services.twilsock.on('connected', (notificationId) => {
            this._onTransportStateChange(true);
            this.registrar.setNotificationId('twilsock', notificationId);
        });
        this.services.twilsock.on('disconnected', () => {
            this._onTransportStateChange(false);
        });
        this.services.config.updateToken(token);
        this.registrar.updateToken(token);
    }
    get connectionState() {
        if (this.services.twilsock.state === 'disconnected') {
            return 'disconnected';
        }
        else if (this.services.twilsock.state === 'disconnecting') {
            return 'disconnecting';
        }
        else if (this.services.twilsock.state === 'connected' && this.reliableTransportState.registration) {
            return 'connected';
        }
        else if (this.services.twilsock.state === 'rejected') {
            return 'denied';
        }
        return 'connecting';
    }
    /**
     * Routes messages to the external subscribers
     * @private
     */
    _routeMessage(type, message) {
        logger_1.log.trace('Message arrived: ', type, message);
        this.emit('message', type, message);
    }
    _onNeedReliableTransport(isNeeded) {
        if (isNeeded) {
            this.services.twilsock.connect();
        }
        else {
            this.services.twilsock.disconnect();
        }
    }
    _onRegistrationStateChange(state) {
        this.reliableTransportState.registration = (state === 'registered');
        this._updateTransportState();
    }
    _onTransportStateChange(connected) {
        this.reliableTransportState.transport = connected;
        this._updateTransportState();
    }
    _updateTransportState() {
        const overallState = this.reliableTransportState.transport
            && this.reliableTransportState.registration;
        if (this.reliableTransportState.overall !== overallState) {
            this.reliableTransportState.overall = overallState;
            logger_1.log.info('Transport ready:', overallState);
            this.emit('transportReady', overallState);
        }
        if (this.reliableTransportState.lastEmitted !== this.connectionState) {
            this.reliableTransportState.lastEmitted = this.connectionState;
            this.emit('connectionStateChanged', this.connectionState);
        }
    }
    /**
     * Adds the subscription for the given message type
     * @param {string} messageType The type of message that you want to receive
     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'
     */
    subscribe(messageType, channelType = 'twilsock') {
        logger_1.log.trace('Add subscriptions for message type: ', messageType, channelType);
        return this.registrar.subscribe(messageType, channelType);
    }
    /**
     * Remove the subscription for the particular message type
     * @param {string} messageType The type of message that you don't want to receive anymore
     * @param {string} channelType. Supported are 'twilsock', 'gcm' and 'fcm'
     */
    unsubscribe(messageType, channelType = 'twilsock') {
        logger_1.log.trace('Remove subscriptions for message type: ', messageType, channelType);
        return this.registrar.unsubscribe(messageType, channelType);
    }
    /**
     * Handle incoming push notification.
     * Client application should call this method when it receives push notifications and pass the received data
     * @param {Object} message push message
     * @return {PushNotification}
     */
    handlePushNotification(message) {
        return {
            messageType: message.twi_message_type,
            payload: message.payload
        };
    }
    /**
     * Set APN/GCM/FCM token to enable application register for a push messages
     * @param {string} gcmToken/fcmToken Token received from GCM/FCM system
     */
    setPushRegistrationId(registrationId, channelType) {
        logger_1.log.trace('Set push registration id', registrationId, channelType);
        this.registrar.setNotificationId(channelType, registrationId);
    }
    /**
     * Updates auth token for registration
     * @param {string} token Authentication token for registrations
     */
    async updateToken(token) {
        logger_1.log.info('authTokenUpdated');
        if (this.services.config.token === token) {
            return;
        }
        await this.services.twilsock.updateToken(token);
        this.services.config.updateToken(token);
        this.registrar.updateToken(token);
    }
}
exports.Client = Client;
/**
 * Fired when new message arrived.
 * @param {Object} message`
 * @event Client#message
 */
/**
 * Fired when transport state has changed
 * @param {boolean} transport state
 * @event Client#transportReady
 */
/**
 * Fired when transport state has been changed
 * @param {string} transport state
 * @event Client#connectionStateChanged
 */
/**
 * These options can be passed to Client constructor
 * @typedef {Object} Notifications#ClientOptions
 * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
 *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace']
 */
