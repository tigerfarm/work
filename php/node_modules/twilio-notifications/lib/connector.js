"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Connector = exports.RegistrationState = void 0;
const events_1 = require("events");
const logger_1 = require("./logger");
class RegistrationState {
    constructor(token = '', notificationId = '', messageTypes = new Set()) {
        this.token = token;
        this.notificationId = notificationId;
        this.messageTypes = messageTypes;
    }
    clone() {
        return new RegistrationState(this.token, this.notificationId, new Set(this.messageTypes));
    }
}
exports.RegistrationState = RegistrationState;
function setDifference(a, b) {
    return [...[...a].filter(x => !b.has(x)),
        ...[...b].filter(x => !a.has(x))];
}
function hasDifference(a, b) {
    let reasons = new Set();
    if (a.notificationId !== b.notificationId) {
        reasons.add('notificationId');
    }
    if (a.token !== b.token) {
        reasons.add('token');
    }
    if (setDifference(a.messageTypes, b.messageTypes).length > 0) {
        reasons.add('messageType');
    }
    return [reasons.size > 0, reasons];
}
class Connector extends events_1.EventEmitter {
    constructor(config) {
        super();
        this.config = config;
        this.desiredState = new RegistrationState();
        this.currentState = new RegistrationState();
        this.hasActiveAttempt = false;
    }
    async subscribe(messageType) {
        if (this.desiredState.messageTypes.has(messageType)) {
            logger_1.log.debug('message type already registered ', messageType);
            return;
        }
        this.desiredState.messageTypes.add(messageType);
        await this.persistRegistration();
    }
    async unsubscribe(messageType) {
        if (!this.desiredState.messageTypes.has(messageType)) {
            return;
        }
        this.desiredState.messageTypes.delete(messageType);
        await this.persistRegistration();
    }
    updateToken(token) {
        this.desiredState.token = token;
        this.persistRegistration();
    }
    async persistRegistration() {
        if (!this.config.token || this.config.token.length === 0) {
            logger_1.log.trace('Can\'t persist registration: token is not set');
            return;
        }
        if (this.hasActiveAttempt) {
            logger_1.log.trace('One registration attempt is already in progress');
            return;
        }
        let [needToUpdate, reasons] = hasDifference(this.desiredState, this.currentState);
        if (!needToUpdate) {
            return;
        }
        if (!this.currentState.notificationId) {
            reasons.delete('notificationId');
        }
        logger_1.log.trace('Persisting registration', reasons, this.desiredState);
        try {
            this.hasActiveAttempt = true;
            let stateToPersist = this.desiredState.clone();
            if (stateToPersist.messageTypes.size > 0) {
                let persistedState = await this.updateRegistration(stateToPersist, reasons);
                this.currentState.token = persistedState.token;
                this.currentState.notificationId = persistedState.notificationId;
                this.currentState.messageTypes = persistedState.messageTypes;
                this.emit('stateChanged', 'registered');
            }
            else {
                await this.removeRegistration();
                this.currentState.token = stateToPersist.token;
                this.currentState.notificationId = stateToPersist.notificationId;
                this.currentState.messageTypes.clear();
                this.emit('stateChanged', 'unregistered');
            }
        }
        finally {
            this.hasActiveAttempt = false;
            setTimeout(() => this.persistRegistration(), 0);
        }
    }
    setNotificationId(notificationId) {
        this.desiredState.notificationId = notificationId;
        this.persistRegistration();
    }
}
exports.Connector = Connector;
