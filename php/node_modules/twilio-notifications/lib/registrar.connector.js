"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.RegistrarConnector = exports.Connector = void 0;
const operation_retrier_1 = require("operation-retrier");
const logger_1 = require("./logger");
const connector_1 = require("./connector");
Object.defineProperty(exports, "Connector", { enumerable: true, get: function () { return connector_1.Connector; } });
let retrierConfig = {
    min: 2000,
    max: 120000,
    randomness: 0.2
};
/**
 * Manages the registrations on ERS service.
 * Deduplicates registrations and manages them automatically
 */
class RegistrarConnector extends connector_1.Connector {
    /**
     * Creates new instance of the ERS registrar
     *
     * @param Object configuration
     * @param string notificationId
     * @param string channelType
     * @param Array messageTypes
     */
    constructor(channelType, context, transport, config) {
        super(config);
        this.channelType = channelType;
        this.context = context;
        this.transport = transport;
    }
    async updateRegistration(registration, reasons) {
        if (reasons.has('notificationId')) {
            await this.removeRegistration();
        }
        if (!registration.notificationId || !registration.notificationId.length) {
            return registration;
        }
        await this.register(registration);
        return registration;
    }
    async removeRegistration() {
        if (!this.registrationId) {
            return;
        }
        const url = `${this.config.registrarUrl}/${this.registrationId}?productId=${this.context.productId}`;
        const headers = {
            'Content-Type': 'application/json',
            'X-Twilio-Token': this.config.token
        };
        try {
            logger_1.log.trace('Removing registration for ', this.channelType);
            await new operation_retrier_1.Retrier(Object.assign(retrierConfig, { maxAttemptsCount: 3 }))
                .run(() => this.transport.delete(url, headers));
            logger_1.log.debug('Registration removed for', this.channelType);
        }
        catch (err) {
            logger_1.log.error('Failed to remove of registration ', this.channelType, err);
            throw err;
        }
    }
    async register(registration) {
        logger_1.log.trace('Registering', this.channelType, registration);
        let registrarRequest = {
            endpoint_platform: this.context.platform,
            channel_type: this.channelType,
            version: this.context.protocolVersion.toString(),
            message_types: Array.from(registration.messageTypes),
            data: {
                registration_id: registration.notificationId
            },
            ttl: 'PT24H'
        };
        const url = `${this.config.registrarUrl}?productId=${this.context.productId}`;
        const headers = {
            'Content-Type': 'application/json',
            'X-Twilio-Token': registration.token
        };
        logger_1.log.trace('Creating registration for channel ', this.channelType);
        try {
            let response = await new operation_retrier_1.Retrier(retrierConfig)
                .run(() => this.transport.post(url, headers, registrarRequest));
            this.registrationId = response.body.id;
            logger_1.log.debug('Registration created: ', response);
        }
        catch (err) {
            logger_1.log.error('Registration failed: ', err);
            throw err;
        }
    }
}
exports.RegistrarConnector = RegistrarConnector;
