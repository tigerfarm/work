"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.Registrar = void 0;
const events_1 = require("events");
const registrar_connector_1 = require("./registrar.connector");
const twilsock_connector_1 = require("./twilsock.connector");
/**
 * Provides an interface to the ERS registrar
 */
class Registrar extends events_1.EventEmitter {
    /**
     * Creates the new instance of registrar client
     */
    constructor(productId, transport, twilsock, config) {
        super();
        this.config = config;
        this.connectors = new Map();
        const platform = this.detectPlatform();
        this.connectors.set('gcm', new registrar_connector_1.RegistrarConnector('gcm', { protocolVersion: 3, productId, platform }, transport, config));
        this.connectors.set('fcm', new registrar_connector_1.RegistrarConnector('fcm', { protocolVersion: 3, productId, platform }, transport, config));
        this.connectors.set('apn', new registrar_connector_1.RegistrarConnector('apn', { protocolVersion: 4, productId, platform }, transport, config));
        this.connectors.set('twilsock', new twilsock_connector_1.TwilsockConnector({ productId, platform }, twilsock, config));
        this.connectors.get('twilsock').on('transportReady', state => this.emit('transportReady', state));
    }
    /**
     *  Sets notification ID.
     *  If new URI is different from previous, it triggers updating of registration for given channel
     *
     *  @param {string} channelType channel type (apn|gcm|fcm|twilsock)
     *  @param {string} notificationId The notification ID
     */
    setNotificationId(channelType, notificationId) {
        this.connector(channelType).setNotificationId(notificationId);
    }
    /**
     * Subscribe for given type of message
     *
     * @param {String} messageType Message type identifier
     * @param {String} channelType Channel type, can be 'twilsock', 'gcm' or 'fcm'
     * @public
     */
    subscribe(messageType, channelType) {
        return this.connector(channelType).subscribe(messageType);
    }
    /**
     * Remove subscription
     * @param {String} messageType Message type
     * @param {String} channelType Channel type (twilsock or gcm/fcm)
     */
    unsubscribe(messageType, channelType) {
        return this.connector(channelType).unsubscribe(messageType);
    }
    updateToken(token) {
        this.connectors.forEach(connector => connector.updateToken(token));
    }
    /**
     * @param {String} type Channel type
     * @throws {Error} Error with description
     */
    connector(type) {
        let connector = this.connectors.get(type);
        if (!connector) {
            throw new Error(`Unknown channel type: ${type}`);
        }
        return connector;
    }
    /**
     * Returns platform string limited to max 128 chars
     */
    detectPlatform() {
        let platform = '';
        if (typeof navigator !== 'undefined') {
            platform = 'unknown';
            if (typeof navigator.product !== 'undefined') {
                platform = navigator.product;
            }
            if (typeof navigator.userAgent !== 'undefined') {
                platform = navigator.userAgent;
            }
        }
        else {
            platform = 'web';
        }
        return platform.substring(0, 128);
    }
}
exports.Registrar = Registrar;
