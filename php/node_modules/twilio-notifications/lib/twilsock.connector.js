"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.TwilsockConnector = void 0;
const uuid = require("uuid");
const connector_1 = require("./connector");
const DEFAULT_TTL = 60 * 60 * 48;
/**
 * Registrar connector implementation for twilsock
 */
class TwilsockConnector extends connector_1.Connector {
    constructor(context, twilsock, config) {
        super(config);
        this.twilsock = twilsock;
        this.context = context;
        context.id = uuid.v4();
        this.twilsock.on('stateChanged', state => {
            if (state !== 'connected') {
                this.emit('transportReady', false);
            }
        });
        this.twilsock.on('registered', id => {
            if (context && id === context.id && twilsock.state === 'connected') {
                this.emit('transportReady', true);
            }
        });
    }
    setNotificationId(...args) { }
    updateToken(token) {
        // no need to do anything here, twilsock backend handles it on it's own
        // so just ignoring here
    }
    async updateContextRequest(messageTypes) {
        let context = {
            product_id: this.context.productId,
            notification_protocol_version: 4,
            endpoint_platform: this.context.platform,
            message_types: messageTypes
        };
        this.emit('transportReady', false);
        await this.twilsock.setNotificationsContext(this.context.id, context);
    }
    async updateRegistration(registration, reasons) {
        if (!reasons.has('messageType')) {
            return;
        }
        await this.updateContextRequest(Array.from(registration.messageTypes));
        return registration;
    }
    removeRegistration() {
        return this.twilsock.removeNotificationsContext(this.context.id);
    }
}
exports.TwilsockConnector = TwilsockConnector;
