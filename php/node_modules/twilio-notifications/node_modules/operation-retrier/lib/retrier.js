"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const events_1 = require("events");
/**
 * Provides retrier service
 */
class Retrier extends events_1.EventEmitter {
    /**
     * Creates a new Retrier instance
     */
    constructor(options) {
        super();
        this.minDelay = options.min;
        this.maxDelay = options.max;
        this.initialDelay = options.initial || 0;
        this.maxAttemptsCount = options.maxAttemptsCount || 0;
        this.maxAttemptsTime = options.maxAttemptsTime || 0;
        this.randomness = options.randomness || 0;
        this.inProgress = false;
        this.attemptNum = 0;
        this.prevDelay = 0;
        this.currDelay = 0;
    }
    attempt() {
        clearTimeout(this.timeout);
        this.attemptNum++;
        this.timeout = null;
        this.emit('attempt', this);
    }
    nextDelay(delayOverride) {
        if (typeof delayOverride === 'number') {
            this.prevDelay = 0;
            this.currDelay = delayOverride;
            return delayOverride;
        }
        if (this.attemptNum == 0) {
            return this.initialDelay;
        }
        if (this.attemptNum == 1) {
            this.currDelay = this.minDelay;
            return this.currDelay;
        }
        this.prevDelay = this.currDelay;
        let delay = this.currDelay + this.prevDelay;
        if (this.maxDelay && delay > this.maxDelay) {
            this.currDelay = this.maxDelay;
            delay = this.maxDelay;
        }
        this.currDelay = delay;
        return delay;
    }
    randomize(delay) {
        let area = delay * this.randomness;
        let corr = Math.round(Math.random() * area * 2 - area);
        return Math.max(0, delay + corr);
    }
    scheduleAttempt(delayOverride) {
        if (this.maxAttemptsCount && this.attemptNum >= this.maxAttemptsCount) {
            this.cleanup();
            this.emit('failed', new Error('Maximum attempt count limit reached'));
            this.reject(new Error('Maximum attempt count reached'));
            return;
        }
        let delay = this.nextDelay(delayOverride);
        delay = this.randomize(delay);
        if (this.maxAttemptsTime && (this.startTimestamp + this.maxAttemptsTime < Date.now() + delay)) {
            this.cleanup();
            this.emit('failed', new Error('Maximum attempt time limit reached'));
            this.reject(new Error('Maximum attempt time limit reached'));
            return;
        }
        this.timeout = setTimeout(() => this.attempt(), delay);
    }
    cleanup() {
        clearTimeout(this.timeout);
        this.timeout = null;
        this.inProgress = false;
        this.attemptNum = 0;
        this.prevDelay = 0;
        this.currDelay = 0;
    }
    start() {
        if (this.inProgress) {
            throw new Error('Retrier is already in progress');
        }
        this.inProgress = true;
        return new Promise((resolve, reject) => {
            this.resolve = resolve;
            this.reject = reject;
            this.startTimestamp = Date.now();
            this.scheduleAttempt(this.initialDelay);
        });
    }
    cancel() {
        if (this.timeout) {
            clearTimeout(this.timeout);
            this.timeout = null;
            this.inProgress = false;
            this.emit('cancelled');
            this.reject(new Error('Cancelled'));
        }
    }
    succeeded(arg) {
        this.emit('succeeded', arg);
        this.resolve(arg);
    }
    failed(err, nextAttemptDelayOverride) {
        if (this.timeout) {
            throw new Error('Retrier attempt is already in progress');
        }
        this.scheduleAttempt(nextAttemptDelayOverride);
    }
    run(handler) {
        this.on('attempt', () => {
            handler().then(v => this.succeeded(v)).catch(e => this.failed(e));
        });
        return this.start();
    }
}
exports.Retrier = Retrier;
exports.default = Retrier;
//# sourceMappingURL=retrier.js.map