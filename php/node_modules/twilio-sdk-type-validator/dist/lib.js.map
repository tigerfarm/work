{"version":3,"file":"lib.js","sources":["../src/rules/custom.ts","../src/rules/type.ts","../src/rules/literal.ts","../src/rules/non-empty-string.ts","../src/rules/non-negative-integer.ts","../src/rules/pure-object.ts","../src/type-validator.ts","../src/rules/object-schema.ts","../src/rules/array.ts"],"sourcesContent":["import { RuleDefinition, RuleFunction } from \"../type-validator\";\n\nexport const custom = (...checks: RuleFunction[]): RuleDefinition => ({\n  checks,\n});\n","import { RuleDefinition, TypeRule } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const type = (...checks: TypeRule[]): RuleDefinition =>\n  custom((value: unknown) => {\n    let isValid = false;\n    const expectedTypes: string[] = [];\n\n    for (const type of checks) {\n      if (typeof type === \"string\") {\n        isValid = isValid || typeof value === type;\n        expectedTypes.push(`of type ${type}`);\n\n        continue;\n      }\n\n      isValid = isValid || value instanceof type;\n      expectedTypes.push(`an instance of ${type.name}`);\n    }\n\n    return [isValid, expectedTypes];\n  });\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const literal = (...checks: unknown[]): RuleDefinition =>\n  custom((value: unknown) => {\n    let isValid = false;\n    const expectedTypes = [];\n\n    for (const type of checks) {\n      isValid = isValid || value === type;\n      expectedTypes.push(typeof type === \"string\" ? `\"${type}\"` : `${type}`);\n    }\n\n    return [isValid, expectedTypes];\n  });\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const nonEmptyString: RuleDefinition = custom((value) => [\n  typeof value === \"string\" && value.length > 0,\n  \"a non-empty string\",\n]);\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const nonNegativeInteger: RuleDefinition = custom((value) => [\n  typeof value === \"number\" && Number.isInteger(value) && value >= 0,\n  \"a non-negative integer\",\n]);\n","import { RuleDefinition } from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const pureObject: RuleDefinition = custom((value) => [\n  typeof value === \"object\" && value !== null && !Array.isArray(value),\n  \"a pure object (non-null and non-array)\",\n]);\n","import { type } from \"./rules/type\";\n\nexport type TypeRule =\n  | \"undefined\"\n  | \"object\"\n  | \"boolean\"\n  | \"number\"\n  | \"bigint\"\n  | \"string\"\n  | \"symbol\"\n  | \"function\"\n  | { new (...args: unknown[]): unknown };\n\nexport type RuleFunction = (\n  value: unknown\n) => [boolean, (string | string[])?, string?];\n\nexport type RuleDefinition = {\n  checks: RuleFunction[];\n};\n\nexport type RuleArgument =\n  | TypeRule\n  | RuleDefinition\n  | (TypeRule | RuleDefinition)[];\n\ntype Decorator = (\n  target: unknown,\n  propertyKey: string,\n  descriptor: PropertyDescriptor\n) => void;\n\nexport const runtimeTypeValidation = (\n  rules: RuleDefinition[][],\n  values: unknown[]\n): void => {\n  if (values.length > rules.length) {\n    throw new Error(\n      `Expected at most ${rules.length} argument(s), but got ${values.length}`\n    );\n  }\n\n  while (values.length < rules.length) {\n    values.push(undefined);\n  }\n\n  for (const [index, value] of values.entries()) {\n    const [isValid, received, expected, delimeter] = validateValue(\n      rules[index],\n      value\n    );\n\n    if (isValid) {\n      continue;\n    }\n\n    const argumentIndex = index + 1;\n\n    throw new Error(\n      `Argument ${argumentIndex} is expected to be ${expected}${delimeter} but got ${received}`\n    );\n  }\n};\n\nexport const stringifyReceivedType = (value: unknown): string => {\n  let receivedType;\n  const types = [\"undefined\", \"boolean\", \"number\", \"bigint\", \"string\"];\n\n  if (types.includes(typeof value)) {\n    receivedType = typeof value === \"string\" ? `\"${value}\"` : `${value}`;\n  }\n\n  if (typeof value === \"object\" && value?.constructor?.name !== \"Object\") {\n    receivedType =\n      value === null ? \"null\" : `instance of ${value?.constructor?.name}`;\n  }\n\n  if (!receivedType) {\n    receivedType = typeof value;\n  }\n\n  return receivedType;\n};\n\n/* eslint-disable @typescript-eslint/no-explicit-any */\nexport const validateConstructorTypes = (\n  ...args: RuleArgument[]\n): (<T extends new (...args: any[]) => any>(ctor: T) => T) => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return <T extends { new (...args: any[]): any }>(ctor: T): T => {\n    return class extends ctor {\n      constructor(...args: any[]) {\n        runtimeTypeValidation(finalRuleSet, args);\n        super(...args);\n      }\n    };\n  };\n};\n/* eslint-enable @typescript-eslint/no-explicit-any */\n\nexport const validateTypes = (...args: RuleArgument[]): Decorator => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return (\n    target: unknown,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\n        \"The validateTypes decorator can only be applied to methods\"\n      );\n    }\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: unknown[]) {\n      runtimeTypeValidation(finalRuleSet, args);\n      return originalMethod.apply(this, args);\n    };\n  };\n};\n\nexport const validateTypesAsync = (...args: RuleArgument[]): Decorator => {\n  const finalRuleSet = convertRuleArguments(args);\n\n  return (\n    target: unknown,\n    propertyKey: string,\n    descriptor: PropertyDescriptor\n  ) => {\n    if (typeof descriptor.value !== \"function\") {\n      throw new Error(\n        \"The validateTypesAsync decorator can only be applied to methods\"\n      );\n    }\n\n    const originalMethod = descriptor.value;\n\n    descriptor.value = function (...args: unknown[]) {\n      try {\n        runtimeTypeValidation(finalRuleSet, args);\n      } catch (e) {\n        return Promise.reject<Error>(e);\n      }\n\n      return originalMethod.apply(this, args);\n    };\n  };\n};\n\nexport const convertRuleArguments = (\n  args: RuleArgument[]\n): RuleDefinition[][] => {\n  const finalRuleDefinitionSet: RuleDefinition[][] = [];\n\n  for (const arg of args) {\n    finalRuleDefinitionSet.push(convertRuleArgument(arg));\n  }\n\n  return finalRuleDefinitionSet;\n};\n\nexport const convertRuleArgument = (arg: RuleArgument): RuleDefinition[] => {\n  const finalArgumentRuleDefinitions: RuleDefinition[] = [];\n  const declaredRules = Array.isArray(arg) ? arg : [arg];\n\n  for (const rule of declaredRules) {\n    if (typeof rule === \"string\" || typeof rule === \"function\") {\n      finalArgumentRuleDefinitions.push(type(rule));\n      continue;\n    }\n\n    finalArgumentRuleDefinitions.push(rule);\n  }\n\n  return finalArgumentRuleDefinitions;\n};\n\nexport const validateValue = (\n  ruleDefinitions: RuleDefinition[],\n  value: unknown\n): [true] | [false, string, string, string] => {\n  let expectedTypes: string[] = [];\n  let customReceivedType: string | undefined;\n  let isValid = false;\n\n  for (const definition of ruleDefinitions) {\n    for (const check of definition.checks) {\n      const [checkPassed, typeDescription, receivedType] = check(value);\n      isValid = isValid || checkPassed;\n\n      if (!customReceivedType && receivedType) {\n        customReceivedType = receivedType;\n      }\n\n      if (typeDescription) {\n        expectedTypes =\n          typeof typeDescription === \"string\"\n            ? [...expectedTypes, typeDescription]\n            : [...expectedTypes, ...typeDescription];\n      }\n    }\n  }\n\n  if (isValid) {\n    return [true];\n  }\n\n  const receivedType = customReceivedType || stringifyReceivedType(value);\n  const lastIndex = expectedTypes.length - 1;\n  const expectedTypesString =\n    lastIndex > 0\n      ? `${expectedTypes.slice(0, lastIndex).join(\", \")} or ${\n          expectedTypes[lastIndex]\n        }`\n      : expectedTypes.join(\", \");\n\n  return [false, receivedType, expectedTypesString, lastIndex > 1 ? \";\" : \",\"];\n};\n","import {\n  convertRuleArgument,\n  RuleArgument,\n  RuleDefinition,\n  validateValue,\n} from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const objectSchema = (\n  name: string,\n  schema: Record<string, RuleArgument>\n): RuleDefinition =>\n  custom((object) => {\n    if (\n      typeof object !== \"object\" ||\n      object === null ||\n      Array.isArray(object)\n    ) {\n      return [false, `valid ${name} (should be a pure object)`];\n    }\n\n    for (const [key, rules] of Object.entries(schema)) {\n      const [isValid, received, expected] = validateValue(\n        convertRuleArgument(rules),\n        (object as Record<string, unknown>)[key]\n      );\n\n      if (!isValid) {\n        return [\n          false,\n          `valid ${name} (key \"${key}\" should be ${expected})`,\n          `malformed ${name} (key \"${key}\" is ${received})`,\n        ];\n      }\n    }\n\n    return [true];\n  });\n","import {\n  convertRuleArgument,\n  RuleArgument,\n  RuleDefinition,\n  validateValue,\n} from \"../type-validator\";\nimport { custom } from \"./custom\";\n\nexport const array = (name: string, rules: RuleArgument): RuleDefinition =>\n  custom((value) => {\n    if (!Array.isArray(value)) {\n      return [false, `an array of ${name}`];\n    }\n\n    for (const [key, valueOfKey] of value.entries()) {\n      const [isValid, received, expected] = validateValue(\n        convertRuleArgument(rules),\n        valueOfKey\n      );\n\n      if (!isValid) {\n        return [\n          false,\n          `a valid array of ${name} (index ${key} should be ${expected})`,\n          `malformed array of ${name} (index ${key} is ${received})`,\n        ];\n      }\n    }\n\n    return [true];\n  });\n"],"names":["_typeof"],"mappings":"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"}