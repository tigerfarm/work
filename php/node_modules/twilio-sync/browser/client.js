"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var events_1 = require("events");
var twilsock_1 = require("twilsock");
var twilio_notifications_1 = require("twilio-notifications");
var uri_1 = require("./utils/uri");
var syncerror_1 = require("./utils/syncerror");
var sanitize_1 = require("./utils/sanitize");
var logger_1 = require("./utils/logger");
var configuration_1 = require("./configuration");
var subscriptions_1 = require("./subscriptions");
var router_1 = require("./router");
var network_1 = require("./services/network");
var syncdocument_1 = require("./syncdocument");
var synclist_1 = require("./synclist");
var syncmap_1 = require("./syncmap");
var clientInfo_1 = require("./clientInfo");
var entitiesCache_1 = require("./entitiesCache");
var storage_1 = require("./services/storage");
var syncstream_1 = require("./streams/syncstream");
var livequery_1 = require("./livequery");
var livequery_2 = require("./livequery");
var SYNC_PRODUCT_ID = 'data_sync';
var SDK_VERSION = require('../package.json').version;
function decompose(arg) {
    if (!arg) {
        return { mode: 'create_new' };
    } else if (typeof arg === 'string') {
        return { id: arg, mode: 'open_or_create' };
    } else {
        sanitize_1.validateOptionalTtl(arg.ttl);
        sanitize_1.validateId(arg.id);
        if (arg.mode) {
            sanitize_1.validateMode(arg.mode);
        }
        var mode = arg.mode || (arg.id ? 'open_or_create' : 'create_new');
        return (0, _assign2.default)((0, _assign2.default)({}, arg), { mode: mode });
    }
}
/**
 * @class Client
 * @classdesc
 * Client for the Twilio Sync service.
 * @constructor
 * @param {String} token - Twilio access token.
 * @param {Client#ClientOptions} [options] - Options to customize the Client.
 * @example
 * // Using NPM
 * var SyncClient = require('twilio-sync');
 * var syncClient = new SyncClient(token, { logLevel: 'debug' });
 *
 * // Using CDN
 * var SyncClient = new Twilio.Sync.Client(token, { logLevel: 'debug' });
 *
 * @property {Client#ConnectionState} connectionState - Contains current service connection state.
 * Valid options are ['connecting', 'connected', 'disconnecting', 'disconnected', 'denied', 'error'].
 */

var Client = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(Client, _events_1$EventEmitte);

    function Client(fpaToken) {
        var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
        (0, _classCallCheck3.default)(this, Client);

        var _this = (0, _possibleConstructorReturn3.default)(this, (Client.__proto__ || (0, _getPrototypeOf2.default)(Client)).call(this));

        if (!fpaToken) {
            throw new Error('Sync library needs a valid Twilio token to be passed');
        }
        if (options.hasOwnProperty('logLevel')) {
            logger_1.default.setLevel(options.logLevel);
        } else {
            logger_1.default.setLevel('silent');
        }
        var productId = options.productId = options.productId || SYNC_PRODUCT_ID;
        // Filling ClientMetadata
        options.clientMetadata = options.clientMetadata || {};
        if (!options.clientMetadata.hasOwnProperty('type')) {
            options.clientMetadata.type = 'sync';
        }
        if (!options.clientMetadata.hasOwnProperty('sdk')) {
            options.clientMetadata.sdk = 'JS';
            options.clientMetadata.sdkv = SDK_VERSION;
        }
        var twilsock = options.twilsockClient = options.twilsockClient || new twilsock_1.Twilsock(fpaToken, productId, options);
        twilsock.on('tokenAboutToExpire', function (ttl) {
            return _this.emit('tokenAboutToExpire', ttl);
        });
        twilsock.on('tokenExpired', function () {
            return _this.emit('tokenExpired');
        });
        twilsock.on('connectionError', function (err) {
            return _this.emit('connectionError', err);
        });
        var notifications = options.notificationsClient = options.notificationsClient || new twilio_notifications_1.Notifications(fpaToken, options);
        var config = new configuration_1.Configuration(options);
        var network = new network_1.NetworkService(new clientInfo_1.ClientInfo(SDK_VERSION), config, twilsock);
        var storage = new storage_1.SessionStorage(config);
        _this.localStorageId = null;
        twilsock.connect();
        _this.services = {
            config: config,
            twilsock: twilsock,
            notifications: notifications,
            network: network,
            storage: storage,
            router: null,
            subscriptions: null
        };
        var subscriptions = new subscriptions_1.Subscriptions(_this.services);
        var router = new router_1.Router({ config: config, subscriptions: subscriptions, notifications: notifications });
        _this.services.router = router;
        _this.services.subscriptions = subscriptions;
        _this.entities = new entitiesCache_1.EntitiesCache();
        notifications.on('connectionStateChanged', function () {
            _this.emit('connectionStateChanged', _this.services.notifications.connectionState);
        });
        return _this;
    }
    /**
     * Current version of Sync client.
     * @name Client#version
     * @type String
     * @readonly
     */


    (0, _createClass3.default)(Client, [{
        key: "ensureReady",

        /**
         * Returns promise which resolves when library is correctly initialized
         * Or throws if initialization is impossible
         * @private
         */
        value: function () {
            var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee() {
                var storageSettings;
                return _regenerator2.default.wrap(function _callee$(_context) {
                    while (1) {
                        switch (_context.prev = _context.next) {
                            case 0:
                                if (this.services.config.sessionStorageEnabled) {
                                    _context.next = 2;
                                    break;
                                }

                                return _context.abrupt("return");

                            case 2:
                                _context.prev = 2;
                                _context.next = 5;
                                return this.services.twilsock.storageId();

                            case 5:
                                storageSettings = _context.sent;

                                this.services.storage.updateStorageId(storageSettings.id);
                                _context.next = 12;
                                break;

                            case 9:
                                _context.prev = 9;
                                _context.t0 = _context["catch"](2);

                                logger_1.default.warn('Failed to initialize storage', _context.t0);

                            case 12:
                            case "end":
                                return _context.stop();
                        }
                    }
                }, _callee, this, [[2, 9]]);
            }));

            function ensureReady() {
                return _ref.apply(this, arguments);
            }

            return ensureReady;
        }()
    }, {
        key: "storeRootInSessionCache",
        value: function storeRootInSessionCache(type, id, value) {
            // can't store without id
            if (!this.services.config.sessionStorageEnabled || !id) {
                return;
            }
            var valueToStore = sanitize_1.deepClone(value);
            if (type === synclist_1.SyncList.type || type === syncmap_1.SyncMap.type) {
                valueToStore['last_event_id'] = null;
                delete valueToStore['items'];
            }
            this.services.storage.store(type, id, valueToStore);
        }
    }, {
        key: "readRootFromSessionCache",
        value: function readRootFromSessionCache(type, id) {
            if (!this.services.config.sessionStorageEnabled || !id) {
                return null;
            }
            return this.services.storage.read(type, id);
        }
    }, {
        key: "_get",
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(baseUri, id) {
                var optimistic = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : false;
                var uri, response;
                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                if (id) {
                                    _context2.next = 2;
                                    break;
                                }

                                throw new syncerror_1.SyncError("Cannot get entity without id", 404);

                            case 2:
                                uri = new uri_1.UriBuilder(baseUri).pathSegment(id).queryParam('Include', optimistic ? 'items' : undefined).build();
                                _context2.next = 5;
                                return this.services.network.get(uri);

                            case 5:
                                response = _context2.sent;
                                return _context2.abrupt("return", response.body);

                            case 7:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function _get(_x3, _x4) {
                return _ref2.apply(this, arguments);
            }

            return _get;
        }()
    }, {
        key: "_createDocument",
        value: function _createDocument(id, data, ttl) {
            var requestBody = {
                unique_name: id,
                data: data || {}
            };
            if (ttl !== undefined) {
                requestBody.ttl = ttl;
            }
            return this.services.network.post(this.services.config.documentsUri, requestBody).then(function (response) {
                response.body.data = requestBody.data;
                return response.body;
            });
        }
    }, {
        key: "_getDocument",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3(id) {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                return _context3.abrupt("return", this.readRootFromSessionCache(syncdocument_1.SyncDocument.type, id) || this._get(this.services.config.documentsUri, id));

                            case 1:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function _getDocument(_x5) {
                return _ref3.apply(this, arguments);
            }

            return _getDocument;
        }()
    }, {
        key: "_createList",
        value: function _createList(id, purpose, context, ttl) {
            var requestBody = {
                unique_name: id,
                purpose: purpose,
                context: context
            };
            if (ttl !== undefined) {
                requestBody.ttl = ttl;
            }
            return this.services.network.post(this.services.config.listsUri, requestBody).then(function (response) {
                return response.body;
            });
        }
    }, {
        key: "_getList",
        value: function () {
            var _ref4 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee4(id) {
                return _regenerator2.default.wrap(function _callee4$(_context4) {
                    while (1) {
                        switch (_context4.prev = _context4.next) {
                            case 0:
                                return _context4.abrupt("return", this.readRootFromSessionCache(synclist_1.SyncList.type, id) || this._get(this.services.config.listsUri, id));

                            case 1:
                            case "end":
                                return _context4.stop();
                        }
                    }
                }, _callee4, this);
            }));

            function _getList(_x6) {
                return _ref4.apply(this, arguments);
            }

            return _getList;
        }()
    }, {
        key: "_createMap",
        value: function _createMap(id, ttl) {
            var requestBody = {
                unique_name: id
            };
            if (ttl !== undefined) {
                requestBody.ttl = ttl;
            }
            return this.services.network.post(this.services.config.mapsUri, requestBody).then(function (response) {
                return response.body;
            });
        }
    }, {
        key: "_getMap",
        value: function () {
            var _ref5 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee5(id) {
                var optimistic = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : false;
                return _regenerator2.default.wrap(function _callee5$(_context5) {
                    while (1) {
                        switch (_context5.prev = _context5.next) {
                            case 0:
                                return _context5.abrupt("return", this.readRootFromSessionCache(syncmap_1.SyncMap.type, id) || this._get(this.services.config.mapsUri, id, optimistic));

                            case 1:
                            case "end":
                                return _context5.stop();
                        }
                    }
                }, _callee5, this);
            }));

            function _getMap(_x8) {
                return _ref5.apply(this, arguments);
            }

            return _getMap;
        }()
    }, {
        key: "_getStream",
        value: function () {
            var _ref6 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee6(id) {
                return _regenerator2.default.wrap(function _callee6$(_context6) {
                    while (1) {
                        switch (_context6.prev = _context6.next) {
                            case 0:
                                return _context6.abrupt("return", this.readRootFromSessionCache(syncstream_1.SyncStream.type, id) || this._get(this.services.config.streamsUri, id, false));

                            case 1:
                            case "end":
                                return _context6.stop();
                        }
                    }
                }, _callee6, this);
            }));

            function _getStream(_x9) {
                return _ref6.apply(this, arguments);
            }

            return _getStream;
        }()
    }, {
        key: "_createStream",
        value: function () {
            var _ref7 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee7(id, ttl) {
                var requestBody, response;
                return _regenerator2.default.wrap(function _callee7$(_context7) {
                    while (1) {
                        switch (_context7.prev = _context7.next) {
                            case 0:
                                requestBody = {
                                    unique_name: id
                                };

                                if (ttl !== undefined) {
                                    requestBody.ttl = ttl;
                                }
                                _context7.next = 4;
                                return this.services.network.post(this.services.config.streamsUri, requestBody);

                            case 4:
                                response = _context7.sent;
                                return _context7.abrupt("return", response.body);

                            case 6:
                            case "end":
                                return _context7.stop();
                        }
                    }
                }, _callee7, this);
            }));

            function _createStream(_x10, _x11) {
                return _ref7.apply(this, arguments);
            }

            return _createStream;
        }()
    }, {
        key: "_getLiveQuery",
        value: function _getLiveQuery(sid) {
            return this.readRootFromSessionCache(livequery_1.LiveQuery.type, sid);
        }
    }, {
        key: "getCached",
        value: function getCached(id, type) {
            if (id) {
                return this.entities.get(id, type) || null;
            }
            return null;
        }
    }, {
        key: "removeFromCacheAndSession",
        value: function removeFromCacheAndSession(type, sid, uniqueName) {
            this.entities.remove(sid);
            if (this.services.config.sessionStorageEnabled) {
                this.services.storage.remove(type, sid, uniqueName);
            }
        }
        /**
         * Read or create a Sync Document.
         * @param {String | Client#OpenOptions} [arg] One of:
         * <li>Unique name or SID identifying a Sync Document - opens a Document with the given identifier or creates one if it does not exist.</li>
         * <li>none - creates a new Document with a randomly assigned SID and no unique name.</li>
         * <li>{@link Client#OpenOptions} object for more granular control.</li>
         * @return {Promise<Document>} a promise which resolves after the Document is successfully read (or created).
         * This promise may reject if the Document could not be created or if this endpoint lacks the necessary permissions to access it.
         * @public
         * @example
         * syncClient.document('MyDocument')
         *   .then(function(document) {
         *     console.log('Successfully opened a Document. SID: ' + document.sid);
         *     document.on('updated', function(event) {
         *       console.log('Received updated event: ', event);
         *     });
         *   })
         *   .catch(function(error) {
         *     console.log('Unexpected error', error);
         *   });
         */

    }, {
        key: "document",
        value: function () {
            var _ref8 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee8(arg) {
                var _this2 = this;

                var opts, docDescriptor, docFromInMemoryCache, syncDocumentImpl;
                return _regenerator2.default.wrap(function _callee8$(_context8) {
                    while (1) {
                        switch (_context8.prev = _context8.next) {
                            case 0:
                                _context8.next = 2;
                                return this.ensureReady();

                            case 2:
                                opts = decompose(arg);
                                docDescriptor = void 0;

                                if (!(opts.mode === 'create_new')) {
                                    _context8.next = 10;
                                    break;
                                }

                                _context8.next = 7;
                                return this._createDocument(opts.id, opts.data, opts.ttl);

                            case 7:
                                docDescriptor = _context8.sent;
                                _context8.next = 40;
                                break;

                            case 10:
                                docFromInMemoryCache = this.getCached(opts.id, syncdocument_1.SyncDocument.type);

                                if (!docFromInMemoryCache) {
                                    _context8.next = 15;
                                    break;
                                }

                                return _context8.abrupt("return", new syncdocument_1.SyncDocument(docFromInMemoryCache));

                            case 15:
                                _context8.prev = 15;
                                _context8.next = 18;
                                return this._getDocument(opts.id);

                            case 18:
                                docDescriptor = _context8.sent;
                                _context8.next = 40;
                                break;

                            case 21:
                                _context8.prev = 21;
                                _context8.t0 = _context8["catch"](15);

                                if (!(_context8.t0.status !== 404 || opts.mode === 'open_existing')) {
                                    _context8.next = 27;
                                    break;
                                }

                                throw _context8.t0;

                            case 27:
                                _context8.prev = 27;
                                _context8.next = 30;
                                return this._createDocument(opts.id, opts.data, opts.ttl);

                            case 30:
                                docDescriptor = _context8.sent;
                                _context8.next = 40;
                                break;

                            case 33:
                                _context8.prev = 33;
                                _context8.t1 = _context8["catch"](27);

                                if (!(_context8.t1.status === 409)) {
                                    _context8.next = 39;
                                    break;
                                }

                                return _context8.abrupt("return", this.document(arg));

                            case 39:
                                throw _context8.t1;

                            case 40:
                                this.storeRootInSessionCache(syncdocument_1.SyncDocument.type, opts.id, docDescriptor);
                                syncDocumentImpl = new syncdocument_1.SyncDocumentImpl(this.services, docDescriptor, function (type, sid, uniqueName) {
                                    return _this2.removeFromCacheAndSession(type, sid, uniqueName);
                                });

                                syncDocumentImpl = this.entities.store(syncDocumentImpl);
                                return _context8.abrupt("return", new syncdocument_1.SyncDocument(syncDocumentImpl));

                            case 44:
                            case "end":
                                return _context8.stop();
                        }
                    }
                }, _callee8, this, [[15, 21], [27, 33]]);
            }));

            function document(_x12) {
                return _ref8.apply(this, arguments);
            }

            return document;
        }()
        /**
         * Read or create a Sync Map.
         * @param {String | Client#OpenOptions} [arg] One of:
         * <li>Unique name or SID identifying a Sync Map - opens a Map with the given identifier or creates one if it does not exist.</li>
         * <li>none - creates a new Map with a randomly assigned SID and no unique name.</li>
         * <li>{@link Client#OpenOptions} object for more granular control.</li>
         * @return {Promise<Map>} a promise which resolves after the Map is successfully read (or created).
         * This promise may reject if the Map could not be created or if this endpoint lacks the necessary permissions to access it.
         * @public
         * @example
         * syncClient.map('MyMap')
         *   .then(function(map) {
         *     console.log('Successfully opened a Map. SID: ' + map.sid);
         *     map.on('itemUpdated', function(event) {
         *       console.log('Received itemUpdated event: ', event);
         *     });
         *   })
         *   .catch(function(error) {
         *     console.log('Unexpected error', error);
         *   });
         */

    }, {
        key: "map",
        value: function () {
            var _ref9 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee9(arg) {
                var _this3 = this;

                var opts, mapDescriptor, mapFromInMemoryCache, syncMapImpl;
                return _regenerator2.default.wrap(function _callee9$(_context9) {
                    while (1) {
                        switch (_context9.prev = _context9.next) {
                            case 0:
                                _context9.next = 2;
                                return this.ensureReady();

                            case 2:
                                opts = decompose(arg);
                                mapDescriptor = void 0;

                                if (!(opts.mode === 'create_new')) {
                                    _context9.next = 10;
                                    break;
                                }

                                _context9.next = 7;
                                return this._createMap(opts.id, opts.ttl);

                            case 7:
                                mapDescriptor = _context9.sent;
                                _context9.next = 40;
                                break;

                            case 10:
                                mapFromInMemoryCache = this.getCached(opts.id, syncmap_1.SyncMap.type);

                                if (!mapFromInMemoryCache) {
                                    _context9.next = 15;
                                    break;
                                }

                                return _context9.abrupt("return", new syncmap_1.SyncMap(mapFromInMemoryCache));

                            case 15:
                                _context9.prev = 15;
                                _context9.next = 18;
                                return this._getMap(opts.id, opts.includeItems);

                            case 18:
                                mapDescriptor = _context9.sent;
                                _context9.next = 40;
                                break;

                            case 21:
                                _context9.prev = 21;
                                _context9.t0 = _context9["catch"](15);

                                if (!(_context9.t0.status !== 404 || opts.mode === 'open_existing')) {
                                    _context9.next = 27;
                                    break;
                                }

                                throw _context9.t0;

                            case 27:
                                _context9.prev = 27;
                                _context9.next = 30;
                                return this._createMap(opts.id, opts.ttl);

                            case 30:
                                mapDescriptor = _context9.sent;
                                _context9.next = 40;
                                break;

                            case 33:
                                _context9.prev = 33;
                                _context9.t1 = _context9["catch"](27);

                                if (!(_context9.t1.status === 409)) {
                                    _context9.next = 39;
                                    break;
                                }

                                return _context9.abrupt("return", this.map(arg));

                            case 39:
                                throw _context9.t1;

                            case 40:
                                this.storeRootInSessionCache(syncmap_1.SyncMap.type, opts.id, mapDescriptor);
                                syncMapImpl = new syncmap_1.SyncMapImpl(this.services, mapDescriptor, function (type, sid, uniqueName) {
                                    return _this3.removeFromCacheAndSession(type, sid, uniqueName);
                                });

                                syncMapImpl = this.entities.store(syncMapImpl);
                                return _context9.abrupt("return", new syncmap_1.SyncMap(syncMapImpl));

                            case 44:
                            case "end":
                                return _context9.stop();
                        }
                    }
                }, _callee9, this, [[15, 21], [27, 33]]);
            }));

            function map(_x13) {
                return _ref9.apply(this, arguments);
            }

            return map;
        }()
        /**
         * Read or create a Sync List.
         * @param {String | Client#OpenOptions} [arg] One of:
         * <li>Unique name or SID identifying a Sync List - opens a List with the given identifier or creates one if it does not exist.</li>
         * <li>none - creates a new List with a randomly assigned SID and no unique name.</li>
         * <li>{@link Client#OpenOptions} object for more granular control.</li>
         * @return {Promise<List>} a promise which resolves after the List is successfully read (or created).
         * This promise may reject if the List could not be created or if this endpoint lacks the necessary permissions to access it.
         * @public
         * @example
         * syncClient.list('MyList')
         *   .then(function(list) {
         *     console.log('Successfully opened a List. SID: ' + list.sid);
         *     list.on('itemAdded', function(event) {
         *       console.log('Received itemAdded event: ', event);
         *     });
         *   })
         *   .catch(function(error) {
         *     console.log('Unexpected error', error);
         *   });
         */

    }, {
        key: "list",
        value: function () {
            var _ref10 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee10(arg) {
                var _this4 = this;

                var opts, listDescriptor, listFromInMemoryCache, syncListImpl;
                return _regenerator2.default.wrap(function _callee10$(_context10) {
                    while (1) {
                        switch (_context10.prev = _context10.next) {
                            case 0:
                                _context10.next = 2;
                                return this.ensureReady();

                            case 2:
                                opts = decompose(arg);
                                listDescriptor = void 0;

                                if (!(opts.mode === 'create_new')) {
                                    _context10.next = 10;
                                    break;
                                }

                                _context10.next = 7;
                                return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);

                            case 7:
                                listDescriptor = _context10.sent;
                                _context10.next = 40;
                                break;

                            case 10:
                                listFromInMemoryCache = this.getCached(opts.id, synclist_1.SyncList.type);

                                if (!listFromInMemoryCache) {
                                    _context10.next = 15;
                                    break;
                                }

                                return _context10.abrupt("return", new synclist_1.SyncList(listFromInMemoryCache));

                            case 15:
                                _context10.prev = 15;
                                _context10.next = 18;
                                return this._getList(opts.id);

                            case 18:
                                listDescriptor = _context10.sent;
                                _context10.next = 40;
                                break;

                            case 21:
                                _context10.prev = 21;
                                _context10.t0 = _context10["catch"](15);

                                if (!(_context10.t0.status !== 404 || opts.mode === 'open_existing')) {
                                    _context10.next = 27;
                                    break;
                                }

                                throw _context10.t0;

                            case 27:
                                _context10.prev = 27;
                                _context10.next = 30;
                                return this._createList(opts.id, opts.purpose, opts.context, opts.ttl);

                            case 30:
                                listDescriptor = _context10.sent;
                                _context10.next = 40;
                                break;

                            case 33:
                                _context10.prev = 33;
                                _context10.t1 = _context10["catch"](27);

                                if (!(_context10.t1.status === 409)) {
                                    _context10.next = 39;
                                    break;
                                }

                                return _context10.abrupt("return", this.list(arg));

                            case 39:
                                throw _context10.t1;

                            case 40:
                                this.storeRootInSessionCache(synclist_1.SyncList.type, opts.id, listDescriptor);
                                syncListImpl = new synclist_1.SyncListImpl(this.services, listDescriptor, function (type, sid, uniqueName) {
                                    return _this4.removeFromCacheAndSession(type, sid, uniqueName);
                                });

                                syncListImpl = this.entities.store(syncListImpl);
                                return _context10.abrupt("return", new synclist_1.SyncList(syncListImpl));

                            case 44:
                            case "end":
                                return _context10.stop();
                        }
                    }
                }, _callee10, this, [[15, 21], [27, 33]]);
            }));

            function list(_x14) {
                return _ref10.apply(this, arguments);
            }

            return list;
        }()
        /**
         * Read or create a Sync Message Stream.
         * @param {String | Client#OpenOptions} [arg] One of:
         * <li>Unique name or SID identifying a Stream - opens a Stream with the given identifier or creates one if it does not exist.</li>
         * <li>none - creates a new Stream with a randomly assigned SID and no unique name.</li>
         * <li>{@link Client#OpenOptions} object for more granular control.</li>
         * @return {Promise<Stream>} a promise which resolves after the Stream is successfully read (or created).
         * The flow of messages will begin imminently (but not necessarily immediately) upon resolution.
         * This promise may reject if the Stream could not be created or if this endpoint lacks the necessary permissions to access it.
         * @public
         * @example
         * syncClient.stream('MyStream')
         *   .then(function(stream) {
         *     console.log('Successfully opened a Message Stream. SID: ' + stream.sid);
         *     stream.on('messagePublished', function(event) {
         *       console.log('Received messagePublished event: ', event);
         *     });
         *   })
         *   .catch(function(error) {
         *     console.log('Unexpected error', error);
         *   });
         */

    }, {
        key: "stream",
        value: function () {
            var _ref11 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee11(arg) {
                var _this5 = this;

                var opts, streamDescriptor, streamFromInMemoryCache, streamRemovalHandler, syncStreamImpl;
                return _regenerator2.default.wrap(function _callee11$(_context11) {
                    while (1) {
                        switch (_context11.prev = _context11.next) {
                            case 0:
                                _context11.next = 2;
                                return this.ensureReady();

                            case 2:
                                opts = decompose(arg);
                                streamDescriptor = void 0;

                                if (!(opts.mode === 'create_new')) {
                                    _context11.next = 10;
                                    break;
                                }

                                _context11.next = 7;
                                return this._createStream(opts.id, opts.ttl);

                            case 7:
                                streamDescriptor = _context11.sent;
                                _context11.next = 40;
                                break;

                            case 10:
                                streamFromInMemoryCache = this.getCached(opts.id, syncstream_1.SyncStream.type);

                                if (!streamFromInMemoryCache) {
                                    _context11.next = 15;
                                    break;
                                }

                                return _context11.abrupt("return", new syncstream_1.SyncStream(streamFromInMemoryCache));

                            case 15:
                                _context11.prev = 15;
                                _context11.next = 18;
                                return this._getStream(opts.id);

                            case 18:
                                streamDescriptor = _context11.sent;
                                _context11.next = 40;
                                break;

                            case 21:
                                _context11.prev = 21;
                                _context11.t0 = _context11["catch"](15);

                                if (!(_context11.t0.status !== 404 || opts.mode === 'open_existing')) {
                                    _context11.next = 27;
                                    break;
                                }

                                throw _context11.t0;

                            case 27:
                                _context11.prev = 27;
                                _context11.next = 30;
                                return this._createStream(opts.id, opts.ttl);

                            case 30:
                                streamDescriptor = _context11.sent;
                                _context11.next = 40;
                                break;

                            case 33:
                                _context11.prev = 33;
                                _context11.t1 = _context11["catch"](27);

                                if (!(_context11.t1.status === 409)) {
                                    _context11.next = 39;
                                    break;
                                }

                                return _context11.abrupt("return", this.stream(arg));

                            case 39:
                                throw _context11.t1;

                            case 40:
                                this.storeRootInSessionCache(syncstream_1.SyncStream.type, opts.id, streamDescriptor);

                                streamRemovalHandler = function streamRemovalHandler(type, sid, uniqueName) {
                                    return _this5.removeFromCacheAndSession(type, sid, uniqueName);
                                };

                                syncStreamImpl = new syncstream_1.SyncStreamImpl(this.services, streamDescriptor, streamRemovalHandler);

                                syncStreamImpl = this.entities.store(syncStreamImpl);
                                return _context11.abrupt("return", new syncstream_1.SyncStream(syncStreamImpl));

                            case 45:
                            case "end":
                                return _context11.stop();
                        }
                    }
                }, _callee11, this, [[15, 21], [27, 33]]);
            }));

            function stream(_x15) {
                return _ref11.apply(this, arguments);
            }

            return stream;
        }()
        /**
         * Gracefully shuts the Sync client down.
         */

    }, {
        key: "shutdown",
        value: function () {
            var _ref12 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee12() {
                return _regenerator2.default.wrap(function _callee12$(_context12) {
                    while (1) {
                        switch (_context12.prev = _context12.next) {
                            case 0:
                                _context12.next = 2;
                                return this.services.subscriptions.shutdown();

                            case 2:
                                _context12.next = 4;
                                return this.services.twilsock.disconnect();

                            case 4:
                            case "end":
                                return _context12.stop();
                        }
                    }
                }, _callee12, this);
            }));

            function shutdown() {
                return _ref12.apply(this, arguments);
            }

            return shutdown;
        }()
        /**
         * Set new authentication token.
         * @param {String} token New token to set.
         * @return {Promise<void>}
         * @public
         */

    }, {
        key: "updateToken",
        value: function () {
            var _ref13 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee13(token) {
                return _regenerator2.default.wrap(function _callee13$(_context13) {
                    while (1) {
                        switch (_context13.prev = _context13.next) {
                            case 0:
                                if (token) {
                                    _context13.next = 2;
                                    break;
                                }

                                return _context13.abrupt("return", _promise2.default.reject(new Error('A valid Twilio token should be provided')));

                            case 2:
                                return _context13.abrupt("return", this.services.twilsock.updateToken(token).catch(function (error) {
                                    var _a;
                                    var status = (_a = error === null || error === void 0 ? void 0 : error.reply) === null || _a === void 0 ? void 0 : _a.status;
                                    if ((status === null || status === void 0 ? void 0 : status.code) === 401 && (status === null || status === void 0 ? void 0 : status.status) === 'UNAUTHORIZED') {
                                        throw new syncerror_1.SyncError('Updated token was rejected by server', 400, 51130);
                                    }
                                    throw error;
                                }));

                            case 3:
                            case "end":
                                return _context13.stop();
                        }
                    }
                }, _callee13, this);
            }));

            function updateToken(_x16) {
                return _ref13.apply(this, arguments);
            }

            return updateToken;
        }()
        /**
         * For Flex customers only. Establishes a long-running query against Flex data wherein the returned
         * result set is updated whenever new (or updated) records match the given expression. Updated results
         * are presented row-by-row according to the lifetime of the returned LiveQuery object.
         *
         * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.
         * @param queryExpression {String} A query expression to be executed against the given data index.
         * Please review <a href="https://www.twilio.com/docs/sync/live-query" target="_blank">Live Query Language</a>
         * page for Sync Client limits and full list of operators currently supported in query expressions.
         *
         * @return {Promise<LiveQuery>} a promise that resolves when the query has been successfully executed.
         * @public
         * @example
         * syncClient.liveQuery('tr-worker', 'data.attributes.worker_name == "Bob"')
         *     .then(function(args) {
         *        console.log('Subscribed to live data updates for worker Bob');
         *        let items = args.getItems();
         *        Object.entries(items).forEach(([key, value]) => {
         *          console.log('Search result item key: ' + key);
         *          console.log('Search result item value: ' + value);
         *        });
         *     })
         *     .catch(function(err) {
         *        console.log('Error when subscribing to live updates for worker Bob', err);
         *     });
         */

    }, {
        key: "liveQuery",
        value: function () {
            var _ref14 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee14(indexName, queryExpression) {
                var _this6 = this;

                var queryUri, response, liveQueryImpl, descriptor, liveQueryRemovalHandler;
                return _regenerator2.default.wrap(function _callee14$(_context14) {
                    while (1) {
                        switch (_context14.prev = _context14.next) {
                            case 0:
                                _context14.next = 2;
                                return this.ensureReady();

                            case 2:
                                if (!(!indexName || typeof indexName !== 'string')) {
                                    _context14.next = 4;
                                    break;
                                }

                                throw new Error('Index name must contain a non-empty string value');

                            case 4:
                                queryUri = new uri_1.UriBuilder(this.services.config.insightsUri).pathSegment(indexName).pathSegment('Items').build();
                                // send query to CDS to get server-generated sid and item list

                                _context14.next = 7;
                                return livequery_2.queryItems({
                                    network: this.services.network,
                                    uri: queryUri,
                                    queryString: queryExpression,
                                    type: livequery_1.LiveQuery.type
                                });

                            case 7:
                                response = _context14.sent;
                                liveQueryImpl = this.getCached(response.query_id, livequery_1.LiveQuery.type);

                                if (!liveQueryImpl) {
                                    descriptor = this._getLiveQuery(response.query_id);

                                    if (!descriptor) {
                                        descriptor = {
                                            indexName: indexName,
                                            queryExpression: queryExpression,
                                            sid: response.query_id,
                                            queryUri: queryUri,
                                            last_event_id: response.last_event_id
                                        };
                                    }

                                    liveQueryRemovalHandler = function liveQueryRemovalHandler(type, sid, uniqueName) {
                                        return _this6.removeFromCacheAndSession(type, sid, uniqueName);
                                    };

                                    liveQueryImpl = new livequery_1.LiveQueryImpl(descriptor, this.services, liveQueryRemovalHandler, response.items);
                                }
                                this.storeRootInSessionCache(livequery_1.LiveQuery.type, response.query_id, liveQueryImpl.liveQueryDescriptor);
                                liveQueryImpl = this.entities.store(liveQueryImpl);
                                return _context14.abrupt("return", new livequery_1.LiveQuery(liveQueryImpl));

                            case 13:
                            case "end":
                                return _context14.stop();
                        }
                    }
                }, _callee14, this);
            }));

            function liveQuery(_x17, _x18) {
                return _ref14.apply(this, arguments);
            }

            return liveQuery;
        }()
        /**
         * For Flex customers only. Creates a query object that can be used to issue one-time queries repeatedly
         * against the target index.
         *
         * @param indexName {String} Must specify one of the Flex data classes for which Live Queries are available.
         * @return {Promise<InstantQuery>} a promise which resolves after the InstantQuery is successfully created.
         * @public
         * @example
         * syncClient.instantQuery('tr-worker')
         *    .then(function(q) {
         *        q.on('searchResult', function(items) {
         *          Object.entries(items).forEach(([key, value]) => {
         *             console.log('Search result item key: ' + key);
         *             console.log('Search result item value: ' + value);
         *          });
         *       });
         *    });
         */

    }, {
        key: "instantQuery",
        value: function () {
            var _ref15 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee15(indexName) {
                var _this7 = this;

                var liveQueryCreator, search;
                return _regenerator2.default.wrap(function _callee15$(_context15) {
                    while (1) {
                        switch (_context15.prev = _context15.next) {
                            case 0:
                                _context15.next = 2;
                                return this.ensureReady();

                            case 2:
                                liveQueryCreator = function liveQueryCreator(indexName, queryExpression) {
                                    return _this7.liveQuery(indexName, queryExpression);
                                };

                                search = new livequery_1.InstantQuery({
                                    indexName: indexName,
                                    network: this.services.network,
                                    insightsUri: this.services.config.insightsUri,
                                    liveQueryCreator: liveQueryCreator
                                });
                                return _context15.abrupt("return", search);

                            case 5:
                            case "end":
                                return _context15.stop();
                        }
                    }
                }, _callee15, this);
            }));

            function instantQuery(_x19) {
                return _ref15.apply(this, arguments);
            }

            return instantQuery;
        }()
    }, {
        key: "connectionState",
        get: function get() {
            return this.services.notifications.connectionState;
        }
    }], [{
        key: "version",
        get: function get() {
            return SDK_VERSION;
        }
    }]);
    return Client;
}(events_1.EventEmitter);

exports.Client = Client;
exports.SyncClient = Client;
exports.default = Client;
/**
 * Indicates current state of connection between the client and Sync service.
 * <p>Possible values are as follows:
 * <li>'connecting' - client is offline and connection attempt is in process.
 * <li>'connected' - client is online and ready.
 * <li>'disconnecting' - client is going offline as disconnection is in process.
 * <li>'disconnected' - client is offline and no connection attempt is in process.
 * <li>'denied' - client connection is denied because of invalid JWT access token. User must refresh token in order to proceed.
 * <li>'error' - client connection is in a permanent erroneous state. Client re-initialization is required.
 * @typedef {('connecting'|'connected'|'disconnecting'|'disconnected'|'denied'|'error')} Client#ConnectionState
 */
/**
 * These options can be passed to Client constructor.
 * @typedef {Object} Client#ClientOptions
 * @property {String} [logLevel='error'] - The level of logging to enable. Valid options
 *   (from strictest to broadest): ['silent', 'error', 'warn', 'info', 'debug', 'trace'].
 */
/**
 * Fired when connection state has been changed.
 * @param {Client#ConnectionState} connectionState Contains current service connection state.
 * @event Client#connectionStateChanged
 * @example
 * syncClient.on('connectionStateChanged', function(newState) {
 *   console.log('Received new connection state: ' + newState);
 * });
 */
/**
 * Fired when connection is interrupted by unexpected reason
 * @property {Object} error - connection error details
 * @property {Boolean} error.terminal - twilsock will stop connection attempts
 * @property {String} error.message - root cause
 * @property {Number} [error.httpStatusCode] - http status code if available
 * @property {Number} [error.errorCode] - Twilio public error code if available
 * @event Client#connectionError
 * @example
 * syncClient.on('connectionError', function(connectionError) {
 *   console.log('Connection was interrupted: ' + connectionError.message +
 *     ' (isTerminal: ' + connectionError.terminal')');
 * });
 */
/**
 * Options for opening a Sync Object.
 * @typedef {Object} Client#OpenOptions
 * @property {String} [id] Sync object SID or unique name.
 * @property {'open_or_create' | 'open_existing' | 'create_new'} [mode='open_or_create'] - The mode for opening the Sync object:
 * <li>'open_or_create' - reads a Sync object or creates one if it does not exist.
 * <li>'open_existing' - reads an existing Sync object. The promise is rejected if the object does not exist.
 * <li>'create_new' - creates a new Sync object. If the <i>id</i> property is specified, it will be used as the unique name.
 * @property {Number} [ttl] - The time-to-live of the Sync object in seconds. This is applied only if the object is created.
 * @property {Object} [data={ }] - The initial data for the Sync Document (only applicable to Documents).
 * @example <caption>The following example is applicable to all Sync objects
 * (i.e., <code>syncClient.document(), syncClient.list(), syncClient.map(), syncClient.stream()</code>)</caption>
 * // Attempts to open an existing Document with unique name 'MyDocument'
 * // If no such Document exists, the promise is rejected
 * syncClient.document({
 *     id: 'MyDocument',
 *     mode: 'open_existing'
 *   })
 *   .then(...)
 *   .catch(...);
 *
 * // Attempts to create a new Document with unique name 'MyDocument', TTL of 24 hours and initial data { name: 'John Smith' }
 * // If such a Document already exists, the promise is rejected
 * syncClient.document({
 *     id: 'MyDocument',
 *     mode: 'create_new',
 *     ttl: 86400
 *     data: { name: 'John Smith' } // the `data` property is only applicable for Documents
 *   })
 *   .then(...)
 *   .catch(...);
 */
/**
 * Fired when the access token is about to expire and needs to be updated.
 * The trigger takes place three minutes before the JWT access token expiry.
 * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or
 * <code>tokenExpired</code> events occur; handling just one of them is sufficient.
 * @event Client#tokenAboutToExpire
 * @type {void}
 * @example <caption>The following example illustrates access token refresh</caption>
 * syncClient.on('tokenAboutToExpire', function() {
 *   // Obtain a JWT access token: https://www.twilio.com/docs/sync/identity-and-access-tokens
 *   var token = '<your-access-token-here>';
 *   syncClient.updateToken(token);
 * });
 */
/**
 * Fired when the access token is expired.
 * In case the token is not refreshed, all subsequent Sync operations will fail and the client will disconnect.
 * For long living applications, you should refresh the token when either <code>tokenAboutToExpire</code> or
 * <code>tokenExpired</code> events occur; handling just one of them is sufficient.
 * @event Client#tokenExpired
 * @type {void}
 */