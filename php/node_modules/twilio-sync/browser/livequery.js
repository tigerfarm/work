"use strict";

var _promise = require("babel-runtime/core-js/promise");

var _promise2 = _interopRequireDefault(_promise);

var _assign = require("babel-runtime/core-js/object/assign");

var _assign2 = _interopRequireDefault(_assign);

var _get2 = require("babel-runtime/helpers/get");

var _get3 = _interopRequireDefault(_get2);

var _regenerator = require("babel-runtime/regenerator");

var _regenerator2 = _interopRequireDefault(_regenerator);

var _asyncToGenerator2 = require("babel-runtime/helpers/asyncToGenerator");

var _asyncToGenerator3 = _interopRequireDefault(_asyncToGenerator2);

var _getPrototypeOf = require("babel-runtime/core-js/object/get-prototype-of");

var _getPrototypeOf2 = _interopRequireDefault(_getPrototypeOf);

var _createClass2 = require("babel-runtime/helpers/createClass");

var _createClass3 = _interopRequireDefault(_createClass2);

var _possibleConstructorReturn2 = require("babel-runtime/helpers/possibleConstructorReturn");

var _possibleConstructorReturn3 = _interopRequireDefault(_possibleConstructorReturn2);

var _inherits2 = require("babel-runtime/helpers/inherits");

var _inherits3 = _interopRequireDefault(_inherits2);

var _classCallCheck2 = require("babel-runtime/helpers/classCallCheck");

var _classCallCheck3 = _interopRequireDefault(_classCallCheck2);

var queryItems = function () {
    var _ref = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee(params) {
        var network, queryString, uri, type, liveQueryRequestBody, response;
        return _regenerator2.default.wrap(function _callee$(_context) {
            while (1) {
                switch (_context.prev = _context.next) {
                    case 0:
                        network = params.network, queryString = params.queryString, uri = params.uri, type = params.type;

                        if (!(queryString == null)) {
                            _context.next = 3;
                            break;
                        }

                        throw new syncerror_1.SyncError("Invalid query", 400, 54507);

                    case 3:
                        liveQueryRequestBody = {
                            query_string: queryString // raw query string (like `key == "value" AND key2 != "value2"`)
                        };

                        if (type === LiveQuery.type) {
                            liveQueryRequestBody.type = type;
                        }
                        _context.next = 7;
                        return network.post(uri, liveQueryRequestBody, undefined, true);

                    case 7:
                        response = _context.sent;
                        return _context.abrupt("return", response.body);

                    case 9:
                    case "end":
                        return _context.stop();
                }
            }
        }, _callee, this);
    }));

    return function queryItems(_x) {
        return _ref.apply(this, arguments);
    };
}();

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

Object.defineProperty(exports, "__esModule", { value: true });
var uri_1 = require("./utils/uri");
var syncerror_1 = require("./utils/syncerror");
var logger_1 = require("./utils/logger");
var events_1 = require("events");
var entity_1 = require("./entity");
var closeable_1 = require("./closeable");
var cache_1 = require("./cache");

var InsightsItem = function InsightsItem() {
    (0, _classCallCheck3.default)(this, InsightsItem);
};

exports.InsightsItem = InsightsItem;

var LiveQueryImpl = function (_entity_1$SyncEntity) {
    (0, _inherits3.default)(LiveQueryImpl, _entity_1$SyncEntity);

    function LiveQueryImpl(descriptor, services, removalHandler, items) {
        (0, _classCallCheck3.default)(this, LiveQueryImpl);

        var _this = (0, _possibleConstructorReturn3.default)(this, (LiveQueryImpl.__proto__ || (0, _getPrototypeOf2.default)(LiveQueryImpl)).call(this, services, removalHandler));

        _this.descriptor = descriptor;
        _this.cache = new cache_1.Cache();
        if (items) {
            items.forEach(function (item) {
                _this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);
            });
        }
        return _this;
    }
    // public


    (0, _createClass3.default)(LiveQueryImpl, [{
        key: "onRemoved",

        // dummy stub from iface
        value: function onRemoved() {}
    }, {
        key: "getItems",
        value: function getItems() {
            var dataByKey = {};
            this.cache.forEach(function (key, item) {
                dataByKey[key] = item.value;
            });
            return dataByKey;
        }
        /**
         * @private
         */

    }, {
        key: "_update",
        value: function _update(message, isStrictlyOrdered) {
            switch (message.type) {
                case 'live_query_item_updated':
                    this.handleItemMutated(message.item_key, message.item_data, message.item_revision);
                    break;
                case 'live_query_item_removed':
                    this.handleItemRemoved(message.item_key, message.item_revision);
                    break;
                case 'live_query_updated':
                    this.handleBatchUpdate(message.items);
                    break;
            }
            if (isStrictlyOrdered) {
                this._advanceLastEventId(message.last_event_id);
            }
        }
    }, {
        key: "handleItemMutated",
        value: function handleItemMutated(key, value, revision) {
            if (this.shouldIgnoreEvent(key, revision)) {
                logger_1.default.trace("Item " + key + " update skipped, revision: " + revision);
            } else {
                var newItem = { key: key, value: value };
                this.cache.store(key, newItem, revision);
                this.broadcastEventToListeners('itemUpdated', newItem);
            }
        }
    }, {
        key: "handleItemRemoved",
        value: function handleItemRemoved(key, revision) {
            var force = revision === null;
            if (this.shouldIgnoreEvent(key, revision)) {
                logger_1.default.trace("Item " + key + " delete skipped, revision: " + revision);
            } else {
                this.cache.delete(key, revision, force);
                this.broadcastEventToListeners('itemRemoved', { key: key });
            }
        }
    }, {
        key: "handleBatchUpdate",
        value: function handleBatchUpdate(items) {
            var _this2 = this;

            // preprocess item set for easy key-based access (it's a one-time constant time operation)
            var newItems = {};
            if (items != null) {
                items.forEach(function (item) {
                    newItems[item.key] = {
                        data: item.data,
                        revision: item.revision
                    };
                });
            }
            // go through existing items and generate update/remove events for them
            this.cache.forEach(function (key, item) {
                var newItem = newItems[key];
                if (newItem != null) {
                    _this2.handleItemMutated(key, newItem.data, newItem.revision);
                } else {
                    _this2.handleItemRemoved(key, null); // force deletion w/o revision
                }
                // once item is handled, remove it from incoming array
                delete newItems[key];
            });
            // once we handled all the known items, handle remaining pack
            for (var key in newItems) {
                this.handleItemMutated(key, newItems[key].data, newItems[key].revision);
            }
        }
    }, {
        key: "shouldIgnoreEvent",
        value: function shouldIgnoreEvent(key, eventId) {
            return key != null && eventId != null && this.cache.isKnown(key, eventId);
        }
        /**
         * @private
         */

    }, {
        key: "_advanceLastEventId",
        value: function _advanceLastEventId(eventId, revision) {
            // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only
            if (this.lastEventId < eventId) {
                this.descriptor.last_event_id = eventId;
            }
        }
    }, {
        key: "sid",
        get: function get() {
            return this.descriptor.sid;
        }
        // private extension of SyncEntity

    }, {
        key: "uniqueName",
        get: function get() {
            return null;
        }
    }, {
        key: "type",
        get: function get() {
            return LiveQueryImpl.type;
        }
    }, {
        key: "lastEventId",
        get: function get() {
            return this.descriptor.last_event_id;
        }
    }, {
        key: "indexName",
        get: function get() {
            return this.descriptor.indexName;
        }
    }, {
        key: "queryString",
        get: function get() {
            return this.descriptor.queryExpression;
        }
        // custom private props

    }, {
        key: "queryUri",
        get: function get() {
            return this.descriptor.queryUri;
        }
    }, {
        key: "liveQueryDescriptor",
        get: function get() {
            return this.descriptor;
        }
    }], [{
        key: "type",
        get: function get() {
            return 'live_query';
        }
    }]);
    return LiveQueryImpl;
}(entity_1.SyncEntity);

exports.LiveQueryImpl = LiveQueryImpl;

exports.queryItems = queryItems;
/**
 * @class
 * @alias LiveQuery
 * @classdesc Represents a long-running query against Flex data wherein the returned result set
 *     subsequently receives pushed updates whenever new (or updated) records would match the
 *     given expression. Updated results are presented row-by-row until this query is explicitly
 *     closed.
 *
 *     Use the {@link Client#liveQuery} method to create a live query.
 *
 * @property {String} sid The immutable identifier of this query object, assigned by the system.
 *
 * @fires LiveQuery#itemUpdated
 * @fires LiveQuery#itemRemoved
 */

var LiveQuery = function (_closeable_1$Closeabl) {
    (0, _inherits3.default)(LiveQuery, _closeable_1$Closeabl);

    /**
     * @private
     */
    function LiveQuery(liveQueryImpl) {
        (0, _classCallCheck3.default)(this, LiveQuery);

        var _this3 = (0, _possibleConstructorReturn3.default)(this, (LiveQuery.__proto__ || (0, _getPrototypeOf2.default)(LiveQuery)).call(this));

        _this3.liveQueryImpl = liveQueryImpl;
        _this3.liveQueryImpl.attach(_this3);
        return _this3;
    }
    // private props


    (0, _createClass3.default)(LiveQuery, [{
        key: "close",

        /**
         * Closes this query instance and unsubscribes from further service events.
         * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
         * @public
         */
        value: function close() {
            (0, _get3.default)(LiveQuery.prototype.__proto__ || (0, _getPrototypeOf2.default)(LiveQuery.prototype), "close", this).call(this);
            this.liveQueryImpl.detach(this.listenerUuid);
        }
        /**
         * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.
         * @public
         */

    }, {
        key: "getItems",
        value: function getItems() {
            this.ensureNotClosed();
            return this.liveQueryImpl.getItems();
        }
    }, {
        key: "type",
        get: function get() {
            return LiveQueryImpl.type;
        }
    }, {
        key: "lastEventId",
        get: function get() {
            return this.liveQueryImpl.lastEventId;
        }
        // public

    }, {
        key: "sid",
        get: function get() {
            return this.liveQueryImpl.sid;
        }
    }], [{
        key: "type",
        get: function get() {
            return LiveQueryImpl.type;
        }
    }]);
    return LiveQuery;
}(closeable_1.Closeable);

exports.LiveQuery = LiveQuery;
/**
 * @class
 * @alias InstantQuery
 * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a
 * LiveQuery, this result set does not subscribe to any updates and therefore receives no events
 * beyond the initial result set.
 *
 * Use the {@link Client#instantQuery} method to create an Instant Query.
 *
 * @fires InstantQuery#searchResult
 */

var InstantQuery = function (_events_1$EventEmitte) {
    (0, _inherits3.default)(InstantQuery, _events_1$EventEmitte);

    /**
     * @private
     */
    function InstantQuery(params) {
        (0, _classCallCheck3.default)(this, InstantQuery);

        var _this4 = (0, _possibleConstructorReturn3.default)(this, (InstantQuery.__proto__ || (0, _getPrototypeOf2.default)(InstantQuery)).call(this));

        _this4.queryExpression = null;
        _this4.items = {};
        (0, _assign2.default)(_this4, params);
        _this4.updateIndexName(params.indexName);
        return _this4;
    }
    // private props


    (0, _createClass3.default)(InstantQuery, [{
        key: "search",

        /**
         * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}
         * event.
         * @param {String} queryExpression A query expression to be executed against the given data index. For more information
         * on the syntax read {@link Client#liveQuery}.
         * @returns {Promise<void>} A promise that resolves when query result has been received.
         * @public
         */
        value: function () {
            var _ref2 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee2(queryExpression) {
                var _this5 = this;

                return _regenerator2.default.wrap(function _callee2$(_context2) {
                    while (1) {
                        switch (_context2.prev = _context2.next) {
                            case 0:
                                this.items = {};
                                return _context2.abrupt("return", queryItems({
                                    network: this.network,
                                    uri: this.queryUri,
                                    queryString: queryExpression
                                }).then(function (response) {
                                    _this5.queryExpression = queryExpression;
                                    if (response.items) {
                                        response.items.forEach(function (item) {
                                            _this5.items[item.key] = item.data;
                                        });
                                    }
                                    _this5.emit('searchResult', _this5.getItems());
                                }).catch(function (err) {
                                    logger_1.default.error("Error '" + err.message + "' while executing query '" + queryExpression + "'");
                                    _this5.queryExpression = null;
                                    throw err;
                                }));

                            case 2:
                            case "end":
                                return _context2.stop();
                        }
                    }
                }, _callee2, this);
            }));

            function search(_x2) {
                return _ref2.apply(this, arguments);
            }

            return search;
        }()
        /**
         * Instantiates a LiveQuery object based on the last known query expression that was passed to the
         * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,
         * while current object can be still used to execute repetitive searches.
         * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.
         * @public
         */

    }, {
        key: "subscribe",
        value: function () {
            var _ref3 = (0, _asyncToGenerator3.default)( /*#__PURE__*/_regenerator2.default.mark(function _callee3() {
                return _regenerator2.default.wrap(function _callee3$(_context3) {
                    while (1) {
                        switch (_context3.prev = _context3.next) {
                            case 0:
                                if (!(this.queryExpression == null)) {
                                    _context3.next = 2;
                                    break;
                                }

                                return _context3.abrupt("return", _promise2.default.reject(new syncerror_1.SyncError("Invalid query", 400, 54507)));

                            case 2:
                                return _context3.abrupt("return", this.liveQueryCreator(this.indexName, this.queryExpression));

                            case 3:
                            case "end":
                                return _context3.stop();
                        }
                    }
                }, _callee3, this);
            }));

            function subscribe() {
                return _ref3.apply(this, arguments);
            }

            return subscribe;
        }()
        /**
         * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.
         * @public
         */

    }, {
        key: "getItems",
        value: function getItems() {
            return this.items;
        }
        /**
         * Set new index name
         * @param {String} indexName New index name to set
         * @returns void
         * @public
         */

    }, {
        key: "updateIndexName",
        value: function updateIndexName(indexName) {
            if (!indexName || typeof indexName !== 'string') {
                throw new Error('Index name must contain a non-empty string value');
            }
            this.indexName = indexName;
            this.queryUri = this.generateQueryUri(this.indexName);
        }
    }, {
        key: "generateQueryUri",
        value: function generateQueryUri(indexName) {
            return new uri_1.UriBuilder(this.insightsUri).pathSegment(indexName).pathSegment('Items').build();
        }
    }, {
        key: "type",
        get: function get() {
            return InstantQuery.type;
        }
    }], [{
        key: "type",
        get: function get() {
            return 'instant_query';
        }
    }]);
    return InstantQuery;
}(events_1.EventEmitter);

exports.InstantQuery = InstantQuery;
exports.default = LiveQuery;
/**
 * @class InsightsItem
 * @classdesc An individual result from a LiveQuery or InstantQuery result set.
 * @property {String} key The identifier that maps to this item within the search result.
 * @property {Object} value The contents of the item.
 */
/**
 * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a
 * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of
 * {@link InsightsItem}-s.
 * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot
 */
/**
 * Fired when an item has been added or updated.
 * @event LiveQuery#itemUpdated
 * @param {InsightsItem} item Updated item.
 * @example
 * liveQuery.on('itemUpdated', function(item) {
 *   console.log('Item ' + item.key + ' was updated');
 *   console.log('Item value: ', item.value);
 * });
 */
/**
 * Fired when an existing item has been removed.
 * @event LiveQuery#itemRemoved
 * @param {Object} args Arguments provided with the event.
 * @param {String} args.key The key of the removed item.
 * @example
 * liveQuery.on('itemRemoved', function(args) {
 *   console.log('Item ' + args.key + ' was removed');
 * });
 */
/**
 * Fired when a search result is ready.
 * @event InstantQuery#searchResult
 * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.
 * @example
 * instantQuery.on('searchResult', function(items) {
 *    Object.entries(items).forEach(([key, value]) => {
 *      console.log('Search result item key: ' + key);
 *      console.log('Search result item value: ' + value);
 *    });
 * });
 */