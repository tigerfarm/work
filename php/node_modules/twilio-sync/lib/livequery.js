"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const uri_1 = require("./utils/uri");
const syncerror_1 = require("./utils/syncerror");
const logger_1 = require("./utils/logger");
const events_1 = require("events");
const entity_1 = require("./entity");
const closeable_1 = require("./closeable");
const cache_1 = require("./cache");
class InsightsItem {
}
exports.InsightsItem = InsightsItem;
class LiveQueryImpl extends entity_1.SyncEntity {
    constructor(descriptor, services, removalHandler, items) {
        super(services, removalHandler);
        this.descriptor = descriptor;
        this.cache = new cache_1.Cache();
        if (items) {
            items.forEach(item => {
                this.cache.store(item.key, { key: item.key, value: item.data }, item.revision);
            });
        }
    }
    // public
    get sid() {
        return this.descriptor.sid;
    }
    // private extension of SyncEntity
    get uniqueName() {
        return null;
    }
    get type() {
        return LiveQueryImpl.type;
    }
    static get type() {
        return 'live_query';
    }
    get lastEventId() {
        return this.descriptor.last_event_id;
    }
    get indexName() {
        return this.descriptor.indexName;
    }
    get queryString() {
        return this.descriptor.queryExpression;
    }
    // custom private props
    get queryUri() {
        return this.descriptor.queryUri;
    }
    get liveQueryDescriptor() {
        return this.descriptor;
    }
    // dummy stub from iface
    onRemoved() {
    }
    getItems() {
        const dataByKey = {};
        this.cache.forEach((key, item) => {
            dataByKey[key] = item.value;
        });
        return dataByKey;
    }
    /**
     * @private
     */
    _update(message, isStrictlyOrdered) {
        switch (message.type) {
            case 'live_query_item_updated':
                this.handleItemMutated(message.item_key, message.item_data, message.item_revision);
                break;
            case 'live_query_item_removed':
                this.handleItemRemoved(message.item_key, message.item_revision);
                break;
            case 'live_query_updated':
                this.handleBatchUpdate(message.items);
                break;
        }
        if (isStrictlyOrdered) {
            this._advanceLastEventId(message.last_event_id);
        }
    }
    handleItemMutated(key, value, revision) {
        if (this.shouldIgnoreEvent(key, revision)) {
            logger_1.default.trace(`Item ${key} update skipped, revision: ${revision}`);
        }
        else {
            const newItem = { key, value };
            this.cache.store(key, newItem, revision);
            this.broadcastEventToListeners('itemUpdated', newItem);
        }
    }
    handleItemRemoved(key, revision) {
        const force = (revision === null);
        if (this.shouldIgnoreEvent(key, revision)) {
            logger_1.default.trace(`Item ${key} delete skipped, revision: ${revision}`);
        }
        else {
            this.cache.delete(key, revision, force);
            this.broadcastEventToListeners('itemRemoved', { key });
        }
    }
    handleBatchUpdate(items) {
        // preprocess item set for easy key-based access (it's a one-time constant time operation)
        let newItems = {};
        if (items != null) {
            items.forEach(item => {
                newItems[item.key] = {
                    data: item.data,
                    revision: item.revision
                };
            });
        }
        // go through existing items and generate update/remove events for them
        this.cache.forEach((key, item) => {
            const newItem = newItems[key];
            if (newItem != null) {
                this.handleItemMutated(key, newItem.data, newItem.revision);
            }
            else {
                this.handleItemRemoved(key, null); // force deletion w/o revision
            }
            // once item is handled, remove it from incoming array
            delete newItems[key];
        });
        // once we handled all the known items, handle remaining pack
        for (let key in newItems) {
            this.handleItemMutated(key, newItems[key].data, newItems[key].revision);
        }
    }
    shouldIgnoreEvent(key, eventId) {
        return key != null && eventId != null && this.cache.isKnown(key, eventId);
    }
    /**
     * @private
     */
    _advanceLastEventId(eventId, revision) {
        // LiveQuery is not revisioned in any way, so simply ignore second param and act upon lastEventId only
        if (this.lastEventId < eventId) {
            this.descriptor.last_event_id = eventId;
        }
    }
}
exports.LiveQueryImpl = LiveQueryImpl;
async function queryItems(params) {
    let { network, queryString, uri, type } = params;
    if (queryString == null) { // should not be null or undefined
        throw new syncerror_1.SyncError(`Invalid query`, 400, 54507);
    }
    const liveQueryRequestBody = {
        query_string: queryString // raw query string (like `key == "value" AND key2 != "value2"`)
    };
    if (type === LiveQuery.type) {
        liveQueryRequestBody.type = type;
    }
    let response = await network.post(uri, liveQueryRequestBody, undefined, true);
    return response.body;
}
exports.queryItems = queryItems;
/**
 * @class
 * @alias LiveQuery
 * @classdesc Represents a long-running query against Flex data wherein the returned result set
 *     subsequently receives pushed updates whenever new (or updated) records would match the
 *     given expression. Updated results are presented row-by-row until this query is explicitly
 *     closed.
 *
 *     Use the {@link Client#liveQuery} method to create a live query.
 *
 * @property {String} sid The immutable identifier of this query object, assigned by the system.
 *
 * @fires LiveQuery#itemUpdated
 * @fires LiveQuery#itemRemoved
 */
class LiveQuery extends closeable_1.Closeable {
    /**
     * @private
     */
    constructor(liveQueryImpl) {
        super();
        this.liveQueryImpl = liveQueryImpl;
        this.liveQueryImpl.attach(this);
    }
    // private props
    static get type() {
        return LiveQueryImpl.type;
    }
    get type() {
        return LiveQueryImpl.type;
    }
    get lastEventId() {
        return this.liveQueryImpl.lastEventId;
    }
    // public
    get sid() {
        return this.liveQueryImpl.sid;
    }
    /**
     * Closes this query instance and unsubscribes from further service events.
     * This will eventually stop the physical inflow of updates over the network, when all other instances of this query are closed as well.
     * @public
     */
    close() {
        super.close();
        this.liveQueryImpl.detach(this.listenerUuid);
    }
    /**
     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching the current query expression.
     * @public
     */
    getItems() {
        this.ensureNotClosed();
        return this.liveQueryImpl.getItems();
    }
}
exports.LiveQuery = LiveQuery;
/**
 * @class
 * @alias InstantQuery
 * @classdesc Allows repetitive quick searches against a specific Flex data. Unlike a
 * LiveQuery, this result set does not subscribe to any updates and therefore receives no events
 * beyond the initial result set.
 *
 * Use the {@link Client#instantQuery} method to create an Instant Query.
 *
 * @fires InstantQuery#searchResult
 */
class InstantQuery extends events_1.EventEmitter {
    /**
     * @private
     */
    constructor(params) {
        super();
        this.queryExpression = null;
        this.items = {};
        Object.assign(this, params);
        this.updateIndexName(params.indexName);
    }
    // private props
    static get type() {
        return 'instant_query';
    }
    get type() {
        return InstantQuery.type;
    }
    /**
     * Spawns a new search request. The result will be provided asynchronously via the {@link InstantQuery#event:searchResult}
     * event.
     * @param {String} queryExpression A query expression to be executed against the given data index. For more information
     * on the syntax read {@link Client#liveQuery}.
     * @returns {Promise<void>} A promise that resolves when query result has been received.
     * @public
     */
    async search(queryExpression) {
        this.items = {};
        return queryItems({
            network: this.network,
            uri: this.queryUri,
            queryString: queryExpression
        })
            .then(response => {
            this.queryExpression = queryExpression;
            if (response.items) {
                response.items.forEach((item) => {
                    this.items[item.key] = item.data;
                });
            }
            this.emit('searchResult', this.getItems());
        })
            .catch(err => {
            logger_1.default.error(`Error '${err.message}' while executing query '${queryExpression}'`);
            this.queryExpression = null;
            throw err;
        });
    }
    /**
     * Instantiates a LiveQuery object based on the last known query expression that was passed to the
     * {@link InstantQuery#search} method. This LiveQuery will start receiving updates with new results,
     * while current object can be still used to execute repetitive searches.
     * @returns {Promise<LiveQuery>} A promise which resolves when the LiveQuery object is ready.
     * @public
     */
    async subscribe() {
        if (this.queryExpression == null) { // should not be null or undefined
            return Promise.reject(new syncerror_1.SyncError(`Invalid query`, 400, 54507));
        }
        return this.liveQueryCreator(this.indexName, this.queryExpression);
    }
    /**
     * @returns {LiveQuery#ItemsSnapshot} A snapshot of items matching current query expression.
     * @public
     */
    getItems() {
        return this.items;
    }
    /**
     * Set new index name
     * @param {String} indexName New index name to set
     * @returns void
     * @public
     */
    updateIndexName(indexName) {
        if (!indexName || typeof indexName !== 'string') {
            throw new Error('Index name must contain a non-empty string value');
        }
        this.indexName = indexName;
        this.queryUri = this.generateQueryUri(this.indexName);
    }
    generateQueryUri(indexName) {
        return new uri_1.UriBuilder(this.insightsUri)
            .pathSegment(indexName)
            .pathSegment('Items')
            .build();
    }
}
exports.InstantQuery = InstantQuery;
exports.default = LiveQuery;
/**
 * @class InsightsItem
 * @classdesc An individual result from a LiveQuery or InstantQuery result set.
 * @property {String} key The identifier that maps to this item within the search result.
 * @property {Object} value The contents of the item.
 */
/**
 * A result set, i.e. a collection of items that matched a LiveQuery or InstantQuery expression. Each result is a
 * key-value pair, where each key identifies its object uniquely. These results are equivalent to a set of
 * {@link InsightsItem}-s.
 * @typedef {Object.<string, Object>} LiveQuery#ItemsSnapshot
 */
/**
 * Fired when an item has been added or updated.
 * @event LiveQuery#itemUpdated
 * @param {InsightsItem} item Updated item.
 * @example
 * liveQuery.on('itemUpdated', function(item) {
 *   console.log('Item ' + item.key + ' was updated');
 *   console.log('Item value: ', item.value);
 * });
 */
/**
 * Fired when an existing item has been removed.
 * @event LiveQuery#itemRemoved
 * @param {Object} args Arguments provided with the event.
 * @param {String} args.key The key of the removed item.
 * @example
 * liveQuery.on('itemRemoved', function(args) {
 *   console.log('Item ' + args.key + ' was removed');
 * });
 */
/**
 * Fired when a search result is ready.
 * @event InstantQuery#searchResult
 * @param {LiveQuery#ItemsSnapshot} items A snapshot of items matching current query expression.
 * @example
 * instantQuery.on('searchResult', function(items) {
 *    Object.entries(items).forEach(([key, value]) => {
 *      console.log('Search result item key: ' + key);
 *      console.log('Search result item value: ' + value);
 *    });
 * });
 */
