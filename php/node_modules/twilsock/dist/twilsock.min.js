/* twilsock.js 0.6.2
The following license applies to all parts of this software except as
documented below.

    Copyright (c) 2016, Twilio, inc.
    All rights reserved.

    Redistribution and use in source and binary forms, with or without
    modification, are permitted provided that the following conditions are
    met:

      1. Redistributions of source code must retain the above copyright
         notice, this list of conditions and the following disclaimer.

      2. Redistributions in binary form must reproduce the above copyright
         notice, this list of conditions and the following disclaimer in
         the documentation and/or other materials provided with the
         distribution.

      3. Neither the name of Twilio nor the names of its contributors may
         be used to endorse or promote products derived from this software
         without specific prior written permission.

    THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS
    "AS IS" AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT
    LIMITED TO, THE IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR
    A PARTICULAR PURPOSE ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT
    HOLDER OR CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL,
    SPECIAL, EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT
    LIMITED TO, PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE,
    DATA, OR PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY
    THEORY OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
    (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
    OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.

This software includes javascript-state-machine under the following license.

    Copyright (c) 2012, 2013, 2014, 2015, Jake Gordon and contributors

    Permission is hereby granted, free of charge, to any person obtaining a copy
    of this software and associated documentation files (the "Software"), to deal
    in the Software without restriction, including without limitation the rights
    to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the Software is
    furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in all
    copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
    OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE

This software includes loglevel under the following license.

    Copyright (c) 2013 Tim Perry

    Permission is hereby granted, free of charge, to any person
    obtaining a copy of this software and associated documentation
    files (the "Software"), to deal in the Software without
    restriction, including without limitation the rights to use,
    copy, modify, merge, publish, distribute, sublicense, and/or sell
    copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following
    conditions:

    The above copyright notice and this permission notice shall be
    included in all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
    EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES
    OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
    NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT
    HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY,
    WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR
    OTHER DEALINGS IN THE SOFTWARE.

*/
!function(e){if("object"==typeof exports&&"undefined"!=typeof module)module.exports=e();else if("function"==typeof define&&define.amd)define([],e);else{var t;((t="undefined"!=typeof window?window:"undefined"!=typeof global?global:"undefined"!=typeof self?self:this).Twilio||(t.Twilio={})).Twilsock=e()}}(function(){return function(){return function e(t,n,i){function r(o,a){if(!n[o]){if(!t[o]){var c="function"==typeof require&&require;if(!a&&c)return c(o,!0);if(s)return s(o,!0);var l=new Error("Cannot find module '"+o+"'");throw l.code="MODULE_NOT_FOUND",l}var u=n[o]={exports:{}};t[o][0].call(u.exports,function(e){return r(t[o][1][e]||e)},u,u.exports,e,t,n,i)}return n[o].exports}for(var s="function"==typeof require&&require,o=0;o<i.length;o++)r(i[o]);return r}}()({1:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("events"),r=e("operation-retrier");n.BackoffRetrier=
/**
 * Retrier with backoff override capability
*/
class extends i.EventEmitter{constructor(e){super(),this.options=e?Object.assign({},e):{}}get inProgress(){return!!this.retrier}
/**
     * Should be called once per attempt series to start retrier.
    */start(){if(this.inProgress)throw new Error("Already waiting for next attempt, call finishAttempt(success : boolean) to finish it");this.createRetrier()}
/**
     * Should be called to stop retrier entirely.
    */stop(){this.cleanRetrier(),this.newBackoff=null,this.usedBackoff=null}
/**
     * Modifies backoff for next attempt.
     * Expected behavior:
     * - If there was no backoff passed previously reschedulling next attempt to given backoff
     * - If previous backoff was longer then ignoring this one.
     * - If previous backoff was shorter then reschedulling with this one.
     * With or without backoff retrier will keep growing normally.
     * @param delay delay of next attempts in ms.
     */modifyBackoff(e){this.newBackoff=e}
/**
     * Mark last emmited attempt as failed, initiating either next of fail if limits were hit.
    */attemptFailed(){if(!this.inProgress)throw new Error("No attempt is in progress");this.newBackoff&&(!this.usedBackoff||this.usedBackoff<this.newBackoff)?this.createRetrier():this.retrier.failed(new Error)}cancel(){this.retrier&&this.retrier.cancel()}cleanRetrier(){this.retrier&&(this.retrier.removeAllListeners(),this.retrier.cancel(),this.retrier=null)}getRetryPolicy(){const e=Object.assign({},this.options);return this.newBackoff&&(e.min=this.newBackoff,e.max=this.options.max&&this.options.max>this.newBackoff?this.options.max:this.newBackoff),
// As we're always skipping first attempt we should add one extra if limit is present
e.maxAttemptsCount=this.options.maxAttemptsCount?this.options.maxAttemptsCount+1:void 0,e}createRetrier(){this.cleanRetrier();const e=this.getRetryPolicy();this.retrier=new r.Retrier(e),this.retrier.once("attempt",()=>{this.retrier.on("attempt",()=>this.emit("attempt")),this.retrier.failed(new Error("Skipping first attempt"))}),this.retrier.on("failed",e=>this.emit("failed",e)),this.usedBackoff=this.newBackoff,this.newBackoff=null,this.retrier.start().catch(e=>{})}}},{events:31,"operation-retrier":35}],2:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("events"),r=e("./logger"),s=e("./configuration"),o=e("./twilsock"),a=e("./packetinterface"),c=e("./websocketchannel"),l=e("./services/registrations"),u=e("./services/upstream"),d=e("./deferred"),h=e("./error/twilsockerror"),f=e("./offlinestorage"),p=e("./tokenStorage"),m=e("./services/telemetrytracker");class g{}n.TelemetryEvents=g,g.TWILSOCK_CONNECT="twilsock.sdk.connect",// establish WebSocket connection (with WebSocket handshake finished)
g.TWILSOCK_INIT="twilsock.sdk.init";// send "init" message and receive reply
/**
 * @alias Twilsock
 * @classdesc Client library for the Twilsock service
 * It allows to recevie service-generated updates as well as bi-directional transport
 * @fires Twilsock#message
 * @fires Twilsock#connected
 * @fires Twilsock#disconnected
 * @fires Twilsock#tokenAboutToExpire
 * @fires Twilsock#stateChanged
 * @fires Twilsock#connectionError
 */
class y extends i.EventEmitter{
/**
     * @param {string} token Twilio access token
     * @param {string} productId Product identifier. Should be the same as a grant name in token
     */
constructor(e,t,n={}){super(),this.offlineStorageDeferred=new d.Deferred,n.continuationToken=n.continuationToken?n.continuationToken:p.TokenStorage.getStoredToken(t);let i=this.config=new s.Configuration(e,t,n);r.log.setLevel(i.logLevel);let f=new c.WebSocketChannel(i.url),y=n.transport?n.transport:new a.PacketInterface(f,i);this.channel=n.channel?n.channel:new o.TwilsockImpl(f,y,i),this.registrations=n.registrations?n.registrations:new l.Registrations(y),this.upstream=new u.Upstream(y,this.channel,i),
// Send telemetry only when connected and initialised
this.telemetryTracker=new m.TelemetryTracker(i,y),this.channel.on("initialized",()=>this.telemetryTracker.canSendTelemetry=!0),f.on("disconnected",()=>this.telemetryTracker.canSendTelemetry=!1),this.registrations.on("registered",e=>this.emit("registered",e)),this.channel.on("message",(e,t)=>setTimeout(()=>this.emit("message",e,t),0)),this.channel.on("stateChanged",e=>setTimeout(()=>this.emit("stateChanged",e),0)),this.channel.on("connectionError",e=>setTimeout(()=>this.emit("connectionError",e),0)),this.channel.on("tokenAboutToExpire",()=>setTimeout(()=>this.emit("tokenAboutToExpire"),0)),this.channel.on("tokenExpired",()=>setTimeout(()=>this.emit("tokenExpired"),0)),this.channel.on("connected",()=>this.registrations.updateRegistrations()),this.channel.on("connected",()=>this.upstream.sendPendingMessages()),this.channel.on("connected",()=>setTimeout(()=>this.emit("connected"),0)),
// Twilsock telemetry events
this.channel.on("beforeConnect",()=>this.telemetryTracker.addPartialEvent(new m.TelemetryEventDescription("Establish WebSocket connection","",new Date),g.TWILSOCK_CONNECT,m.TelemetryPoint.Start)),this.channel.on("connected",()=>this.telemetryTracker.addPartialEvent(new m.TelemetryEventDescription("Establish WebSocket connection","",new Date,new Date),g.TWILSOCK_CONNECT,m.TelemetryPoint.End)),this.channel.on("beforeSendInit",()=>this.telemetryTracker.addPartialEvent(new m.TelemetryEventDescription("Send Twilsock init","",new Date),g.TWILSOCK_INIT,m.TelemetryPoint.Start)),this.channel.on("initialized",()=>this.telemetryTracker.addPartialEvent(new m.TelemetryEventDescription("Send Twilsock init","Succeeded",new Date,new Date),g.TWILSOCK_INIT,m.TelemetryPoint.End)),this.channel.on("sendInitFailed",()=>this.telemetryTracker.addPartialEvent(new m.TelemetryEventDescription("Send Twilsock init","Failed",new Date,new Date),g.TWILSOCK_INIT,m.TelemetryPoint.End)),this.channel.on("initialized",e=>{this.handleStorageId(t,e),p.TokenStorage.storeToken(e.continuationToken,t),setTimeout(()=>this.emit("initialized",e),0)}),this.channel.on("disconnected",()=>setTimeout(()=>this.emit("disconnected"),0)),this.channel.on("disconnected",()=>this.upstream.rejectPendingMessages()),this.channel.on("disconnected",()=>this.offlineStorageDeferred.fail(new h.TwilsockError("Client disconnected"))),this.offlineStorageDeferred.promise.catch(()=>{})}emit(e,...t){return r.log.debug(`Emitting ${e.toString()}(${t.map(e=>JSON.stringify(e)).join(", ")})`),super.emit(e,...t)}handleStorageId(e,t){if(t.offlineStorage)if(t.offlineStorage.hasOwnProperty(e))try{this.offlineStorageDeferred.set(f.OfflineProductStorage.create(t.offlineStorage[e])),r.log.debug(`Offline storage for '${e}' product: ${JSON.stringify(t.offlineStorage[e])}.`)}catch(n){this.offlineStorageDeferred.fail(new h.TwilsockError(`Failed to parse offline storage for ${e} ${JSON.stringify(t.offlineStorage[e])}. ${n}.`))}else this.offlineStorageDeferred.fail(new h.TwilsockError(`No offline storage id for '${e}' product: ${JSON.stringify(t.offlineStorage)}`));else this.offlineStorageDeferred.fail(new h.TwilsockError("No offline storage id"))}
/**
     * Get offline storage ID
     * @returns {Promise}
     */storageId(){return this.offlineStorageDeferred.promise}
/**
     * Indicates if twilsock is connected now
     * @returns {Boolean}
     */get isConnected(){return this.channel.isConnected}
/**
     * Current state
     * @returns {String}
     */get state(){return this.channel.state}
/**
     * Update token
     * @param {String} token
     * @returns {Promise}
     */async updateToken(e){if(r.log.trace(`updating token '${e}'`),this.config.token!==e)return this.config.updateToken(e),this.channel.updateToken(e)}
/**
     * Updates notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @param context value of notification context
     * @private
     */setNotificationsContext(e,t){this.registrations.setNotificationsContext(e,t)}
/**
     * Remove notification context.
     * This method shouldn't be used anyone except twilio notifications library
     * @param contextId id of notification context
     * @private
     */removeNotificationsContext(e){this.registrations.removeNotificationsContext(e)}
/**
     * Connect to the server
     * @fires Twilsock#connected
     * @public
     * @returns {void}
     */connect(){return this.channel.connect()}
/**
     * Disconnect from the server
     * @fires Twilsock#disconnected
     * @public
     * @returns {Promise}
     */disconnect(){return this.telemetryTracker.sendTelemetry(m.EventSendingLimitation.AnyEventsIncludingUnfinished),this.channel.disconnect()}
/**
     * Get HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */get(e,t,n){// send collected telemetry (if any) before upstream message shipment
return this.telemetryTracker.sendTelemetry(m.EventSendingLimitation.AnyEvents),this.upstream.send("GET",e,t,void 0,n)}
/**
     * Post HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */post(e,t,n,i){// send collected telemetry (if any) before upstream message shipment
return this.telemetryTracker.sendTelemetry(m.EventSendingLimitation.AnyEvents),this.upstream.send("POST",e,t,n,i)}
/**
     * Put HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {body} body Body to send
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */put(e,t,n,i){// send collected telemetry (if any) before upstream message shipment
return this.telemetryTracker.sendTelemetry(m.EventSendingLimitation.AnyEvents),this.upstream.send("PUT",e,t,n,i)}
/**
     * Delete HTTP request to upstream service
     * @param {string} url Upstream service url
     * @param {headers} headers Set of custom headers
     * @param {string} [grant] The product grant
     * @returns {Promise}
     */delete(e,t,n){// send collected telemetry (if any) before upstream message shipment
return this.telemetryTracker.sendTelemetry(m.EventSendingLimitation.AnyEvents),this.upstream.send("DELETE",e,t,void 0,n)}
/**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @returns {void}
     */addTelemetryEvent(e){this.telemetryTracker.addTelemetryEvent(e),this.telemetryTracker.sendTelemetryIfMinimalPortionCollected()}
/**
     * Submits internal telemetry event. Not to be used for any customer and/or sensitive data.
     * @param {TelemetryEventDescription} event Event details.
     * @param {string} eventKey Unique event key.
     * @param {TelemetryPoint} point Is this partial event for start or end of measurement.
     * @returns {void}
     */addPartialTelemetryEvent(e,t,n){this.telemetryTracker.addPartialEvent(e,t,n),n===m.TelemetryPoint.End&&
// this telemetry event is complete, so minimal portion could become ready to send
this.telemetryTracker.sendTelemetryIfMinimalPortionCollected()}}n.TwilsockClient=y,n.Twilsock=y},{"./configuration":3,"./deferred":4,"./error/twilsockerror":6,"./logger":10,"./offlinestorage":12,"./packetinterface":13,"./services/registrations":24,"./services/telemetrytracker":25,"./services/upstream":26,"./tokenStorage":27,"./twilsock":28,"./websocketchannel":29,events:31}],3:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});let i="0.6.2";
/**
 * Settings container for the Twilsock client library
 */n.Configuration=class{
/**
     * @param {String} token - authentication token
     * @param {Object} options - options to override defaults
     */
constructor(e,t,n={}){this.confirmedCapabilities=new Set,this.activeGrant=t,this._token=e;const r=`wss://tsock.${n.region||"us1"}.twilio.com/v3/wsconnect`;let s=n.twilsock||n.Twilsock||{};this.url=s.uri||r,this._continuationToken=n.continuationToken?n.continuationToken:null,this.logLevel=n.logLevel?n.logLevel:"error",this.retryPolicy=n.retryPolicy?n.retryPolicy:{min:1e3,max:12e4,randomness:.2},this.clientMetadata=n.clientMetadata?n.clientMetadata:{},this.clientMetadata.ver=i,this.initRegistrations=n.initRegistrations?n.initRegistrations:null,this.tweaks=n.tweaks?n.tweaks:null}get token(){return this._token}get continuationToken(){return this._continuationToken}updateToken(e){this._token=e}updateContinuationToken(e){this._continuationToken=e}}},{}],4:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.Deferred=class{constructor(){this._promise=new Promise((e,t)=>{this._resolve=e,this._reject=t})}get promise(){return this._promise}update(e){this._resolve(e)}set(e){this.current=e,this._resolve(e)}fail(e){this._reject(e)}}},{}],5:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./twilsockerror");n.TransportUnavailableError=class extends i.TwilsockError{constructor(e){super(e)}}},{"./twilsockerror":6}],6:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});n.TwilsockError=class extends Error{constructor(e){super(e)}}},{}],7:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./twilsockerror");n.TwilsockReplyError=class extends i.TwilsockError{constructor(e,t){super(e),this.reply=t}}},{"./twilsockerror":6}],8:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./twilsockerror");n.TwilsockUpstreamError=class extends i.TwilsockError{constructor(e,t,n){super(t),this.status=e,this.description=t,this.body=n}}},{"./twilsockerror":6}],9:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./client");n.TwilsockClient=i.TwilsockClient,n.Twilsock=i.TwilsockClient;const r=e("./error/twilsockerror");n.TwilsockError=r.TwilsockError;const s=e("./error/transportunavailableerror");n.TransportUnavailableError=s.TransportUnavailableError},{"./client":2,"./error/transportunavailableerror":5,"./error/twilsockerror":6}],10:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("loglevel").getLogger("twilsock");// twilsock is used by Flex SDK. Please DO NOT change
function r(e,t){return[`${(new Date).toISOString()} Twilsock ${e}:`].concat(Array.from(t))}class s{constructor(e){this.prefix="",this.prefix=null!=e&&e.length>0?" "+e+":":""}setLevel(e){i.setLevel(e)}static setLevel(e){i.setLevel(e)}trace(...e){i.debug.apply(null,r("T",e))}debug(...e){i.debug.apply(null,r("D",e))}info(...e){i.info.apply(null,r("I",e))}warn(...e){i.warn.apply(null,r("W",e))}error(...e){i.error.apply(null,r("E",e))}static trace(...e){i.trace.apply(null,r("T",e))}static debug(...e){i.debug.apply(null,r("D",e))}static info(...e){i.info.apply(null,r("I",e))}static warn(...e){i.warn.apply(null,r("W",e))}static error(...e){i.error.apply(null,r("E",e))}}n.Logger=s;let o=new s("");n.log=o},{loglevel:33}],11:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("platform");n.Metadata=class{static getMetadata(e){"undefined"!=typeof navigator&&i.parse(navigator.userAgent);let t=e&&e.clientMetadata?e.clientMetadata:{};const n={env:i.name,envv:i.version,os:i.os.family,osv:i.os.version,osa:i.os.architecture,sdk:"js-default"};let r={};return["ver","env","envv","os","osv","osa","type","sdk","sdkv","dev","devv","devt","app","appv"].filter(e=>e in t||e in n).forEach(e=>r[e]=e in t?t[e]:n[e]),r}}},{platform:37}],12:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./error/twilsockerror");class r{constructor(e){this.id=e}static create(e){if(e instanceof Object&&"storage_id"in e)return new r(e.storage_id);throw new i.TwilsockError('Field "storage_id" is missing')}}n.OfflineProductStorage=r},{"./error/twilsockerror":6}],13:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./logger"),r=e("uuid"),s=e("./error/twilsockerror"),o=e("./error/twilsockreplyerror"),a=e("./parser"),c=e("./protocol/messages"),l=e("./metadata"),u=3e4;n.PacketResponse=class{};n.PacketInterface=class{constructor(e,t){this.config=t,this.activeRequests=new Map,this.channel=e,this.channel.on("reply",e=>this.processReply(e)),this.channel.on("disconnected",()=>{this.activeRequests.forEach(e=>{clearTimeout(e.timeout),e.reject(new s.TwilsockError("disconnected"))}),this.activeRequests.clear()})}get isConnected(){return this.channel.isConnected}processReply(e){const t=this.activeRequests.get(e.id);var n;
/**
 * Makes sure that body is properly stringified
 */t&&(clearTimeout(t.timeout),this.activeRequests.delete(e.id),(n=e.status.code)>=200&&n<300?t.resolve(e):(t.reject(new o.TwilsockReplyError("Transport failure: "+e.status.status,e)),i.log.trace("message rejected")))}storeRequest(e,t,n){let r={resolve:t,reject:n,timeout:setTimeout(()=>{i.log.trace("request",e,"is timed out"),n(new s.TwilsockError("Twilsock: request timeout: "+e))},u)};this.activeRequests.set(e,r)}shutdown(){this.activeRequests.forEach(e=>{clearTimeout(e.timeout),e.reject(new s.TwilsockError("Twilsock: request cancelled by user"))}),this.activeRequests.clear()}async sendInit(){i.log.trace("sendInit");let e=l.Metadata.getMetadata(this.config),t=new c.Init(this.config.token,this.config.continuationToken,e,this.config.initRegistrations,this.config.tweaks),n=await this.sendWithReply(t);return new c.InitReply(n.id,n.header.continuation_token,n.header.continuation_token_status,n.header.offline_storage,n.header.init_registrations,n.header.debug_info,new Set(n.header.capabilities))}sendClose(){let e=new c.Close;
//@todo send telemetry AnyEventsIncludingUnfinished
this.send(e)}sendWithReply(e,t){return new Promise((n,i)=>{let r=this.send(e,t);this.storeRequest(r,n,i)})}send(e,t){e.id=e.id||`TM${r.v4()}`;let n=a.Parser.createPacket(e,function(e){switch(typeof e){case"undefined":return"";case"object":return JSON.stringify(e);default:return e}}(t));try{return this.channel.send(n),e.id}catch(t){throw i.log.debug("failed to send ",e,t),i.log.trace(t.stack),t}}}},{"./error/twilsockerror":6,"./error/twilsockreplyerror":7,"./logger":10,"./metadata":11,"./parser":14,"./protocol/messages":17,uuid:38}],14:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./logger");function r(e){return encodeURIComponent(e).replace(/%([0-9A-F]{2})/g,(e,t)=>String.fromCharCode("0x"+t)).length}function s(e){let t=Array.prototype.map.call(e,e=>String.fromCharCode(e)).join("").replace(/(.)/g,(e,t)=>{let n=t.charCodeAt(0).toString(16).toUpperCase();return n.length<2&&(n="0"+n),"%"+n});return decodeURIComponent(t)}function o(e){return JSON.parse(s(e))}n.Parser=class{constructor(){}static parse(e){const t=new Uint8Array(e),n=function(e){let t="",n=0;for(;n<e.length;++n){const i=String.fromCharCode(e[n]);if(t+=i,"\r"===i){n+=2;break}}const i=t.split(" ");return{size:n,protocol:i[0],version:i[1],headerSize:Number(i[2])}}(t);if("TWILSOCK"!==n.protocol||"V3.0"!==n.version)
//throw new Error('Unsupported protocol');
//this.fsm.unsupportedProtocol();
return void i.log.error(`unsupported protocol: ${n.protocol} ver ${n.version}`);let r=null;try{r=o(t.subarray(n.size,n.size+n.headerSize))}catch(t){
//throw new Error('Failed to parse message');
//this.fsm.protocolError();
return void i.log.error("failed to parse message header",t,e)}i.log.debug("message received: ",r.method),i.log.trace("message received: ",r);let a=null;if(r.payload_size>0){const c=2+n.size+n.headerSize,l=r.payload_size;if(r.hasOwnProperty("payload_type")&&0!==r.payload_type.indexOf("application/json"))0===r.payload_type.indexOf("text/plain")&&(a=s(t.subarray(c,c+l)));else try{a=o(t.subarray(c,c+l))}catch(t){
//this.fsm.protocolError();
return void i.log.error("failed to parse message body",t,e)}}return{method:r.method,header:r,payload:a}}static createPacket(e,t=""){e.payload_size=r(t);// eslint-disable-line camelcase
let n=JSON.stringify(e)+"\r\n",s="TWILSOCK V3.0 "+(r(n)-2)+"\r\n";return i.log.debug("send request:",s+n+t),function(e){let t=encodeURIComponent(e).replace(/%([0-9A-F]{2})/g,(e,t)=>String.fromCharCode("0x"+t)),n=new Uint8Array(t.length);return Array.prototype.forEach.call(t,(e,t)=>{n[t]=e.charCodeAt(0)}),n}(s+n+t).buffer}}},{"./logger":10}],15:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("uuid");n.AbstractMessage=class{constructor(e){this.id=e||`TM${i.v4()}`}}},{uuid:38}],16:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.Close=class extends i.AbstractMessage{constructor(){super(),this.method="close"}}},{"./abstractmessage":15}],17:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./init");n.Init=i.Init;const r=e("./initReply");n.InitReply=r.InitReply;const s=e("./update");n.Update=s.Update;const o=e("./message");n.Message=o.Message;const a=e("./reply");n.Reply=a.Reply;const c=e("./close");n.Close=c.Close;const l=e("./telemetry");n.Telemetry=l.Telemetry},{"./close":16,"./init":18,"./initReply":19,"./message":20,"./reply":21,"./telemetry":22,"./update":23}],18:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.Init=class extends i.AbstractMessage{constructor(e,t,n,i=null,r=null){super(),this.method="init",this.token=e,this.continuation_token=t,this.metadata=n,this.registrations=i,this.tweaks=r,this.capabilities=["client_update","offline_storage","telemetry.v1"]}}},{"./abstractmessage":15}],19:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.ContinuationTokenStatus=class{};n.InitReply=class extends i.AbstractMessage{constructor(e,t,n,i,r,s,o){super(e),this.continuationToken=t,this.continuationTokenStatus=n,this.offlineStorage=i,this.initRegistrations=r,this.debugInfo=s,this.confirmedCapabilities=o}}},{"./abstractmessage":15}],20:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.Message=class extends i.AbstractMessage{constructor(e,t,n){super(),this.method="message",this.active_grant=e,this.payload_type=t,this.http_request=n}}},{"./abstractmessage":15}],21:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.Reply=class extends i.AbstractMessage{constructor(e){super(e),this.method="reply",this.payload_type="application/json",this.status={code:200,status:"OK"}}}},{"./abstractmessage":15}],22:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.TelemetryEvent=class{constructor(e,// relative to event send time
t,// relative to event send time
n,i,r,// optional, default will be random assigned by backend
s){this.start=e,this.end=t,this.title=n,this.details=i,this.id=r,this.type=s}};n.Telemetry=class extends i.AbstractMessage{constructor(e){super(),this.method="telemetry.v1",this.events=e}}},{"./abstractmessage":15}],23:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./abstractmessage");n.Update=class extends i.AbstractMessage{constructor(e){super(),this.method="update",this.token=e}}},{"./abstractmessage":15}],24:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("../logger"),r=e("events"),s=e("uuid"),o=e("../error/twilsockerror");n.Registrations=
/**
 * Registrations module handles all operations with registration contexts through twilsock
 * Main role: it automatically refreshes all registrations after reconnect.
 */
class extends r.EventEmitter{constructor(e){super(),this.transport=e,this.registrations=new Map,this.registrationsInProgress=new Map}async putNotificationContext(e,t){const n={method:"put_notification_ctx",notification_ctx_id:e};await this.transport.sendWithReply(n,t)}async deleteNotificationContext(e){let t={method:"delete_notification_ctx",notification_ctx_id:e};await this.transport.sendWithReply(t)}async updateRegistration(e,t){i.log.debug("update registration for context",e);let n=this.registrationsInProgress.get(e);n||(n=new Set,this.registrationsInProgress.set(e,n));const r=s.v4();n.add(r);try{await this.putNotificationContext(e,t),i.log.debug("registration attempt succeeded for context",t),n.delete(r),0===n.size&&(this.registrationsInProgress.delete(e),this.emit("registered",e))}catch(s){i.log.warn("registration attempt failed for context",t),i.log.debug(s),n.delete(r),0===n.size&&(this.registrationsInProgress.delete(e),this.emit("registrationFailed",e,s))}}updateRegistrations(){i.log.trace(`refreshing ${this.registrations.size} registrations`),this.registrations.forEach((e,t)=>{this.updateRegistration(t,e)})}setNotificationsContext(e,t){if(!e||!t)throw new o.TwilsockError("Invalid arguments provided");this.registrations.set(e,t),this.transport.isConnected&&this.updateRegistration(e,t)}async removeNotificationsContext(e){this.registrations.has(e)&&(await this.deleteNotificationContext(e),this.transport.isConnected&&this.registrations.delete(e))}}},{"../error/twilsockerror":6,"../logger":10,events:31,uuid:38}],25:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("../protocol/messages/telemetry"),r=e("../logger");class s{constructor(e,t,n,i,r,s){this.title=e,this.details=t,this.start=n,this.type=r,this.id=s,this.end=i}
// Prepare telemetry event right before sending it.
// Convert times to relative.
toTelemetryEvent(){
// Fix dates
const e=new Date;let t=this.start,n=this.end?this.end:e;if(n<t){let e=n;n=t,t=e}
// Converting dates to relative offset from current moment in ms
const r=t.getTime()-e.getTime(),s=n.getTime()-e.getTime();return new i.TelemetryEvent(r,s,this.title,this.details,this.id,this.type)}}var o,a;n.TelemetryEventDescription=s,function(e){e[e.Start=0]="Start",e[e.End=1]="End"}(o||(o={})),n.TelemetryPoint=o,function(e){e[e.MinEventsPortion=0]="MinEventsPortion",e[e.AnyEvents=1]="AnyEvents",e[e.AnyEventsIncludingUnfinished=2]="AnyEventsIncludingUnfinished"}(a||(a={})),n.EventSendingLimitation=a;n.TelemetryTracker=class{constructor(e,t){
// accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)
this.minEventsPortionToSend=50,
// max events batch size to be sent in a single Telemetry message
this.maxEventsPortionToSend=100,this.pendingEvents=new Map,// started events: have TelemetryEvent::startTime only
this.readyEvents=[],// events ready to send
this.hasInitializationFinished=!1,this._canSendTelemetry=!1,this.config=e,this.packetInterface=t}
// Keeping this private prevents the type declaration from being generated properly.
// Ideally, this should be private.
get isTelemetryEnabled(){return this.config.confirmedCapabilities.has("telemetry.v1")}get canSendTelemetry(){return this._canSendTelemetry&&this.isTelemetryEnabled}set canSendTelemetry(e){r.log.debug(`TelemetryTracker.canSendTelemetry: ${e} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`),
// We want to keep telemetry events added in advance but
// we need to purge events from previous connection when being disconnected
this._canSendTelemetry&&!e&&(this.pendingEvents.clear(),this.readyEvents=[]),this._canSendTelemetry=e,e&&this.sendTelemetry(a.AnyEvents),e&&!this.hasInitializationFinished&&(this.hasInitializationFinished=!0)}
// Add complete event
addTelemetryEvent(e){
// Allow adding events before initialization.
!this.canSendTelemetry&&this.hasInitializationFinished||this.readyEvents.push(e)}
// Add incomplete event (with either starting or ending time point)
addPartialEvent(e,t,n){r.log.debug(`Adding ${n===o.Start?"starting":"ending"} timepoint for '${t}' event`);let i=this.pendingEvents.has(t);if(n===o.Start)i&&r.log.debug(`Overwriting starting point for '${t}' event`),this.pendingEvents.set(t,e);else{if(!i)return void r.log.info(`Could not find started event for '${t}' event`);this.addTelemetryEvent(this.merge(this.pendingEvents.get(t),e)),this.pendingEvents.delete(t)}}getTelemetryToSend(e){return this.canSendTelemetry&&0!=this.readyEvents.length?e==a.MinEventsPortion&&this.readyEvents.length<this.minEventsPortionToSend?[]:this.getTelemetryPortion(e==a.AnyEventsIncludingUnfinished):[]}getTelemetryPortion(e){const t=Math.min(this.readyEvents.length,this.maxEventsPortionToSend);let n=this.readyEvents.splice(0,t);return e&&n.length<this.maxEventsPortionToSend&&this.pendingEvents.forEach((e,t)=>{if(n.length>=this.maxEventsPortionToSend)return;// @fixme does not end the loop early
let i=this.pendingEvents.get(t);this.pendingEvents.delete(t),n.push(new s(`[UNFINISHED] ${i.title}`,// add prefix title to mark unfinished events for CleanSock
i.details,i.start,null,// Not ended, on sending will be replaced with now
i.type,i.id))}),n}
// Merging 2 partial events:
//   use start.startTime & end.endTime.
// For other fields,
//   if there are values in end, use them,
//   else use values from start.
merge(e,t){return new s(t.title?t.title:e.title,t.details?t.details:e.details,e.start,t.end,t.type?t.type:e.type,t.id?t.id:e.id)}sendTelemetryIfMinimalPortionCollected(){this.sendTelemetry(a.MinEventsPortion)}
// NB: getTelemetryToSend will return non-empty array only if we have already received initReply
// and telemetry.v1 capability is enabled there.
sendTelemetry(e){const t=this.getTelemetryToSend(e);if(0!==t.length)try{this.packetInterface.send(new i.Telemetry(t.map(e=>e.toTelemetryEvent())))}catch(e){r.log.debug(`Error while sending ${t.length} telemetry events due to ${e}; they will be resubmitted`),this.readyEvents=this.readyEvents.concat(t)}}}},{"../logger":10,"../protocol/messages/telemetry":22}],26:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("../logger"),r=e("../error/twilsockerror"),s=e("../error/twilsockupstreamerror"),o=e("../protocol/messages"),a=e("../error/transportunavailableerror"),c=2e4;function l(e,t){const n=function(e){const t=e.match(/^(https?\:)\/\/(([^:\/?#]*)(?:\:([0-9]+))?)(\/[^?#]*)(\?[^#]*|)(#.*|)$/);if(t){let e={protocol:t[1],host:t[2],hostname:t[3],port:t[4],pathname:t[5],search:t[6],hash:t[7],params:null};if(e.search.length>0){let t=e.search.substring(1);e.params=t.split("&").map(e=>e.split("=")).reduce((e,t)=>(e.hasOwnProperty(t[0])?Array.isArray(e[t[0]])?e[t[0]].push(t[1]):e[t[0]]=[e[t[0]],t[1]]:e[t[0]]=t[1],e),{})}return e}throw new r.TwilsockError("Incorrect URI: "+e)}(t);let i={method:e,host:n.host,path:n.pathname};return n.params&&(i.params=n.params),i}n.Upstream=class{constructor(e,t,n){this.config=n,this.transport=e,this.pendingMessages=[],this.twilsock=t}saveMessage(e){return new Promise((t,n)=>{let s={message:e,resolve:t,reject:n,alreadyRejected:!1,timeout:setTimeout(()=>{i.log.debug("request is timed out"),n(new r.TwilsockError(`request '${e.to.method}' to '${e.to.host}' timed out`)),s.alreadyRejected=!0},c)};this.pendingMessages.push(s)})}sendPendingMessages(){for(;this.pendingMessages.length;){let e=this.pendingMessages[0];
// Do not send message if we've rejected its promise already
if(!e.alreadyRejected)try{let t=e.message;this.actualSend(t).then(t=>e.resolve(t)).catch(t=>e.reject(t)),clearTimeout(e.timeout)}catch(e){i.log.debug("Failed to send pending message",e);break}this.pendingMessages.splice(0,1)}}rejectPendingMessages(){this.pendingMessages.forEach(e=>{e.reject(new a.TransportUnavailableError("Unable to connect: "+this.twilsock.getTerminationReason)),clearTimeout(e.timeout)}),this.pendingMessages.splice(0,this.pendingMessages.length)}async actualSend(e){let t=e.to,n=e.headers,i=e.body,r=e.grant?e.grant:this.config.activeGrant,a={host:t.host,path:t.path,method:t.method,params:t.params,headers:n},c=new o.Message(r,n["Content-Type"]||"application/json",a),l=await this.transport.sendWithReply(c,i);if((d=l)&&d.header&&d.header.http_status&&!((u=l.header.http_status.code)>=200&&u<300))throw new s.TwilsockUpstreamError(l.header.http_status.code,l.header.http_status.status,l.body);var u,d;return{status:l.header.http_status,headers:l.header.http_headers,body:l.body}}
/**
     * Send an upstream message
     * @param {string} method The upstream method
     * @param {string} url URL to send the message to
     * @param {object} [headers] The message headers
     * @param {any} [body] The message body
     * @param {string} [grant] The product grant
     * @returns {Promise<Result>} Result from remote side
     */send(e,t,n={},i,r){if(this.twilsock.isTerminalState)return Promise.reject(new a.TransportUnavailableError("Unable to connect: "+this.twilsock.getTerminationReason));let s=function(e,t,n,i,r){return{to:l(e,t),headers:n,body:i,grant:r}}(e,t,n,i,r);return this.twilsock.isConnected?this.actualSend(s):this.saveMessage(s)}}},{"../error/transportunavailableerror":5,"../error/twilsockerror":6,"../error/twilsockupstreamerror":8,"../logger":10,"../protocol/messages":17}],27:[function(e,t,n){(function(e){"use strict";Object.defineProperty(n,"__esModule",{value:!0});class t{static get sessionStorage(){try{return e.sessionStorage}catch(e){return null}}static get window(){try{return e.window}catch(e){return null}}static storeToken(e,n){t.canStore&&t.sessionStorage.setItem(t.getKeyName(n),e)}static getStoredToken(e){return t.canStore?t.sessionStorage.getItem(t.getKeyName(e)):null}static initialize(){if(t.canStore){
// Duplicated tab, cleaning up all stored keys
t.sessionStorage.getItem(t.initializedFlag)&&this.clear(),t.sessionStorage.setItem(t.initializedFlag,"true"),
// When leaving page or refreshing
t.window.addEventListener("unload",()=>{t.sessionStorage.removeItem(t.initializedFlag)})}}static clear(){if(t.canStore){let e=[];for(let n=0;n<t.sessionStorage.length;n++){const i=t.sessionStorage.key(n);
// We manually removed startsWith here due to some problems with babel polyfill setup.
// Restore it when we figure out what's wrong.
//if (key.startsWith(TokenStorage.tokenStoragePrefix)) {
0===i.indexOf(t.tokenStoragePrefix)&&e.push(i)}e.forEach(e=>t.sessionStorage.removeItem(e)),t.sessionStorage.removeItem(t.initializedFlag)}}static getKeyName(e){return`${t.tokenStoragePrefix}${e}`}static get canStore(){return t.sessionStorage&&t.window}}n.TokenStorage=t,t.initializedFlag="twilio_twilsock_token_storage",t.tokenStoragePrefix="twilio_continuation_token_",t.initialize()}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],28:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("events"),r=e("javascript-state-machine"),s=e("./logger"),o=e("./protocol/messages"),a=e("./parser"),c=e("./error/twilsockreplyerror"),l=e("./backoffretrier"),u=3e3;n.Response=class{};
/**
 * Twilsock channel level protocol implementation
 */
class d extends i.EventEmitter{constructor(e,t,n){super(),this.terminalStates=["disconnected","rejected"],this.lastEmittedState=void 0,this.tokenExpiredSasCode=20104,this.terminationReason="Connection is not initialized",this.websocket=e,this.websocket.on("connected",()=>this.fsm.socketConnected()),this.websocket.on("disconnected",e=>this.fsm.socketClosed()),this.websocket.on("message",e=>this.onIncomingMessage(e)),this.websocket.on("socketError",e=>this.emit("connectionError",{terminal:!1,message:`Socket error: ${e.message}`,httpStatusCode:null,errorCode:null})),this.transport=t,this.config=n,this.retrier=new l.BackoffRetrier(n.retryPolicy),this.retrier.on("attempt",()=>this.retry()),this.retrier.on("failed",e=>{s.log.warn(`Retrying failed: ${e.message}`),this.disconnect()}),"undefined"!=typeof window&&void 0!==window.addEventListener&&(window.addEventListener("online",()=>{s.log.debug("Browser reported connectivity state: online"),this.resetBackoff(),this.fsm.systemOnline()}),window.addEventListener("offline",()=>{s.log.debug("Browser reported connectivity state: offline"),this.websocket.close(),this.fsm.socketClosed()})),this.fsm=new r({init:"disconnected",transitions:[{name:"userConnect",from:["disconnected","rejected"],to:"connecting"},{name:"userConnect",from:["connecting","connected"]},{name:"userDisconnect",from:["connecting","initialising","connected","updating","retrying","rejected","waitSocketClosed","waitOffloadSocketClosed"],to:"disconnecting"},{name:"userRetry",from:["retrying"],to:"connecting"},{name:"socketConnected",from:["connecting"],to:"initialising"},{name:"socketClosed",from:["connecting","initialising","connected","updating","error","waitOffloadSocketClosed"],to:"retrying"},{name:"socketClosed",from:["disconnecting"],to:"disconnected"},{name:"socketClosed",from:["waitSocketClosed"],to:"disconnected"},{name:"socketClosed",from:["rejected"],to:"rejected"},{name:"initSuccess",from:["initialising"],to:"connected"},{name:"initError",from:["initialising"],to:"error"},{name:"tokenRejected",from:["initialising","updating"],to:"rejected"},{name:"protocolError",from:["initialising","connected","updating"],to:"error"},{name:"receiveClose",from:["initialising","connected","updating"],to:"waitSocketClosed"},{name:"receiveOffload",from:["initialising","connected","updating"],to:"waitOffloadSocketClosed"},{name:"unsupportedProtocol",from:["initialising","connected","updating"],to:"unsupported"},{name:"receiveFatalClose",from:["initialising","connected","updating"],to:"unsupported"},{name:"userUpdateToken",from:["disconnected","rejected","connecting","retrying"],to:"connecting"},{name:"userUpdateToken",from:["connected"],to:"updating"},{name:"updateSuccess",from:["updating"],to:"connected"},{name:"updateError",from:["updating"],to:"error"},{name:"userSend",from:["connected"],to:"connected"},{name:"systemOnline",from:["retrying"],to:"connecting"}],methods:{onConnecting:()=>{this.setupSocket(),this.emit("connecting")},onEnterInitialising:()=>{this.sendInit()},onLeaveInitialising:()=>{this.cancelInit()},onEnterUpdating:()=>{this.sendUpdate()},onLeaveUpdating:()=>{this.cancelUpdate()},onEnterRetrying:()=>{this.initRetry(),this.emit("connecting")},onEnterConnected:()=>{this.resetBackoff(),this.onConnected()},onUserUpdateToken:()=>{this.resetBackoff()},onTokenRejected:()=>{this.resetBackoff(),this.closeSocket(!0),this.finalizeSocket()},onUserDisconnect:()=>{this.closeSocket(!0)},onEnterDisconnecting:()=>{this.startDisconnectTimer()},onLeaveDisconnecting:()=>{this.cancelDisconnectTimer()},onEnterWaitSocketClosed:()=>{this.startDisconnectTimer()},onLeaveWaitSocketClosed:()=>{this.cancelDisconnectTimer()},onEnterWaitOffloadSocketClosed:()=>{this.startDisconnectTimer()},onLeaveWaitOffloadSocketClosed:()=>{this.cancelDisconnectTimer()},onDisconnected:()=>{this.resetBackoff(),this.finalizeSocket()},onReceiveClose:(e,t)=>{this.onCloseReceived(t)},onReceiveOffload:(e,t)=>{s.log.debug("onreceiveoffload: ",t),this.modifyBackoff(t.body),this.onCloseReceived(t.status)},onUnsupported:()=>{this.closeSocket(!0),this.finalizeSocket()},onError:(e,t)=>{this.closeSocket(t),this.finalizeSocket()},onEnterState:e=>{"none"!==e.from&&this.changeState(e)},onInvalidTransition:(e,t,n)=>{s.log.warn("FSM: unexpected transition",t,n)}}})}changeState(e){s.log.debug(`FSM: ${e.transition}: ${e.from} --\x3e ${e.to}`),this.lastEmittedState!==this.state&&(this.lastEmittedState=this.state,this.emit("stateChanged",this.state))}resetBackoff(){s.log.trace("resetBackoff"),this.retrier.stop()}modifyBackoff(e){s.log.trace("modifyBackoff",e);let t=e?e.backoff_policy:null;t&&"number"==typeof t.reconnect_min_ms&&this.retrier.modifyBackoff(t.reconnect_min_ms)}startDisconnectTimer(){s.log.trace("startDisconnectTimer"),this.disconnectingTimer&&(clearTimeout(this.disconnectingTimer),this.disconnectingTimer=null),this.disconnectingTimer=setTimeout(()=>{s.log.debug("disconnecting is timed out"),this.closeSocket(!0)},u)}cancelDisconnectTimer(){s.log.trace("cancelDisconnectTimer"),this.disconnectingTimer&&(clearTimeout(this.disconnectingTimer),this.disconnectingTimer=null)}get isConnected(){return"connected"===this.state&&this.websocket.isConnected}get state(){switch(this.fsm.state){case"connecting":case"initialising":case"retrying":case"error":return"connecting";case"updating":case"connected":return"connected";case"rejected":return"rejected";case"disconnecting":case"waitSocketClosed":case"waitOffloadSocketClosed":return"disconnecting";case"disconnected":default:return"disconnected"}}initRetry(){s.log.debug("initRetry"),this.retrier.inProgress?this.retrier.attemptFailed():this.retrier.start()}retry(){"connecting"!=this.fsm.state?(s.log.trace("retry"),this.websocket.close(),this.fsm.userRetry()):s.log.trace("can\t retry as already connecting")}onConnected(){this.emit("connected")}finalizeSocket(){s.log.trace("finalizeSocket"),this.websocket.close(),this.emit("disconnected"),this.disconnectedPromiseResolve&&(this.disconnectedPromiseResolve(),this.disconnectedPromiseResolve=null)}setupSocket(){s.log.trace("setupSocket:",this.config.token),this.emit("beforeConnect"),// This is used by client to record startup telemetry event
this.websocket.connect()}onIncomingMessage(e){let{method:t,header:n,payload:i}=a.Parser.parse(e);if("reply"!==t&&this.confirmReceiving(n),"notification"===t)this.emit("message",n.message_type,i);else if("reply"===n.method)this.transport.processReply({id:n.id,status:n.status,header:n,body:i});else if("client_update"===n.method)"token_about_to_expire"===n.client_update_type&&this.emit("tokenAboutToExpire");else if("close"===n.method)if(308===n.status.code)s.log.debug("Connection has been offloaded"),this.fsm.receiveOffload({status:n.status.status,body:i});else if(406===n.status.code){
// Not acceptable message
const e=`Server closed connection because can't parse protocol: ${JSON.stringify(n.status)}`;this.emitReplyConnectionError(e,n,!0),s.log.error(e),this.fsm.receiveFatalClose()}else 417===n.status.code?(
// Protocol error
s.log.error(`Server closed connection because can't parse client reply: ${JSON.stringify(n.status)}`),this.fsm.receiveFatalClose(n.status.status)):410===n.status.code?(
// Expired token
s.log.warn(`Server closed connection: ${JSON.stringify(n.status)}`),this.fsm.receiveClose(n.status.status),this.emit("tokenExpired")):401===n.status.code?(
// Authentication fail
s.log.error(`Server closed connection: ${JSON.stringify(n.status)}`),this.fsm.receiveClose(n.status.status)):(s.log.warn("unexpected message: ",n.status),
// Try to reconnect
this.fsm.receiveOffload({status:n.status.status,body:null}))}async sendInit(){s.log.trace("sendInit");try{this.emit("beforeSendInit");// This is used by client to record startup telemetry event
let e=await this.transport.sendInit();this.config.updateContinuationToken(e.continuationToken),this.config.confirmedCapabilities=e.confirmedCapabilities,this.fsm.initSuccess(e),this.emit("initialized",e),this.emit("tokenUpdated")}catch(e){if(e instanceof c.TwilsockReplyError){let t=!1;s.log.warn(`Init rejected by server: ${JSON.stringify(e.reply.status)}`),this.emit("sendInitFailed"),// This is used by client to record startup telemetry event
// @todo emit telemetry from inside "if" below for more granularity...
401===e.reply.status.code||403===e.reply.status.code?(t=!0,this.fsm.tokenRejected(e.reply.status),e.reply.status.errorCode===this.tokenExpiredSasCode&&this.emit("tokenExpired")):429===e.reply.status.code?(this.modifyBackoff(e.reply.body),this.fsm.initError(!0)):500===e.reply.status.code?this.fsm.initError(!1):this.fsm.initError(!0),this.emitReplyConnectionError(e.message,e.reply,t)}else this.terminationReason=e.message,this.emit("connectionError",{terminal:!0,message:`Unknown error during connection initialisation: ${e.message}\n${JSON.stringify(e,null,2)}`,httpStatusCode:null,errorCode:null}),this.fsm.initError(!0);this.emit("tokenUpdated",e)}}async sendUpdate(){s.log.trace("sendUpdate");let e=new o.Update(this.config.token);try{let t=await this.transport.sendWithReply(e);this.fsm.updateSuccess(t.body),this.emit("tokenUpdated")}catch(e){if(e instanceof c.TwilsockReplyError){let t=!1;s.log.warn(`Token update rejected by server: ${JSON.stringify(e.reply.status)}`),401===e.reply.status.code||403===e.reply.status.code?(t=!0,this.fsm.tokenRejected(e.reply.status),e.reply.status.errorCode===this.tokenExpiredSasCode&&this.emit("tokenExpired")):429===e.reply.status.code?(this.modifyBackoff(e.reply.body),this.fsm.updateError(e.reply.status)):this.fsm.updateError(e.reply.status),this.emitReplyConnectionError(e.message,e.reply,t)}else this.emit("error",!1,e.message,null,null),this.fsm.updateError(e);this.emit("tokenUpdated",e)}}emitReplyConnectionError(e,t,n){const i=t.status&&t.status.description?t.status.description:e,r=t.status.code,s=t.status&&t.status.errorCode?t.status.errorCode:null;n&&(this.terminationReason=i),this.emit("connectionError",{terminal:n,message:`Connection error: ${i}`,httpStatusCode:r,errorCode:s})}cancelInit(){s.log.trace("cancelInit");
// TODO: implement
}cancelUpdate(){s.log.trace("cancelUpdate");
// TODO: implement
}
/**
     * Should be called for each message to confirm it received
     */confirmReceiving(e){s.log.trace("confirmReceiving");try{
//@todo send telemetry events AnyEvents
this.transport.send(new o.Reply(e.id))}catch(e){s.log.debug("failed to confirm packet receiving",e)}}
/**
     * Shutdown connection
     */closeSocket(e){s.log.trace(`closeSocket (graceful: ${e})`),e&&this.transport.isConnected&&this.transport.sendClose(),this.websocket.close(),setTimeout(()=>this.fsm.socketClosed(),0)}
/**
     * Initiate the twilsock connection
     * If already connected, it does nothing
     */connect(){s.log.trace("connect"),this.fsm.userConnect()}
/**
     * Close twilsock connection
     * If already disconnected, it does nothing
     */disconnect(){return s.log.trace("disconnect"),this.fsm.is("disconnected")?Promise.resolve():new Promise(e=>{this.disconnectedPromiseResolve=e,this.fsm.userDisconnect()})}
/**
     * Update fpa token for twilsock connection
     */updateToken(e){return s.log.trace("updateToken:",e),new Promise((e,t)=>{this.once("tokenUpdated",n=>{n?t(n):e()}),this.fsm.userUpdateToken()})}get isTerminalState(){return-1!==this.terminalStates.indexOf(this.fsm.state)}get getTerminationReason(){return this.terminationReason}onCloseReceived(e){this.websocket.close()}}n.TwilsockChannel=d,n.TwilsockImpl=d},{"./backoffretrier":1,"./error/twilsockreplyerror":7,"./logger":10,"./parser":14,"./protocol/messages":17,events:31,"javascript-state-machine":32}],29:[function(e,t,n){(function(t){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("events"),r=e("./logger");n.WebSocketChannel=class extends i.EventEmitter{constructor(n){super(),this.url=n,this.WebSocket=t.WebSocket||t.MozWebSocket||e("ws")}get isConnected(){return this.socket&&1===this.socket.readyState}connect(){let e;r.log.trace("connecting to socket");try{e=new this.WebSocket(this.url)}catch(e){return r.log.debug(`Socket error: ${this.url}`),void this.emit("socketError",e)}e.binaryType="arraybuffer",e.onopen=(()=>{r.log.debug(`socket opened ${this.url}`),this.emit("connected")}),e.onclose=(e=>{r.log.debug("socket closed",e),this.emit("disconnected",e)}),e.onerror=(e=>{r.log.debug("Socket error:",e),this.emit("socketError",e)}),e.onmessage=(e=>{this.emit("message",e.data)}),this.socket=e}send(e){this.socket.send(e)}close(){if(r.log.trace("closing socket"),this.socket){this.socket.onopen=null,this.socket.onclose=null,this.socket.onerror=null,this.socket.onmessage=null;try{this.socket.close()}finally{}}}}}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{"./logger":10,events:31,ws:30}],30:[function(e,t,n){},{}],31:[function(e,t,n){
// Copyright Joyent, Inc. and other Node contributors.
//
// Permission is hereby granted, free of charge, to any person obtaining a
// copy of this software and associated documentation files (the
// "Software"), to deal in the Software without restriction, including
// without limitation the rights to use, copy, modify, merge, publish,
// distribute, sublicense, and/or sell copies of the Software, and to permit
// persons to whom the Software is furnished to do so, subject to the
// following conditions:
//
// The above copyright notice and this permission notice shall be included
// in all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS
// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN
// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,
// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR
// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE
// USE OR OTHER DEALINGS IN THE SOFTWARE.
var i=Object.create||function(e){var t=function(){};return t.prototype=e,new t},r=Object.keys||function(e){var t=[];for(var n in e)Object.prototype.hasOwnProperty.call(e,n)&&t.push(n);return n},s=Function.prototype.bind||function(e){var t=this;return function(){return t.apply(e,arguments)}};function o(){this._events&&Object.prototype.hasOwnProperty.call(this,"_events")||(this._events=i(null),this._eventsCount=0),this._maxListeners=this._maxListeners||void 0}t.exports=o,
// Backwards-compat with node 0.10.x
o.EventEmitter=o,o.prototype._events=void 0,o.prototype._maxListeners=void 0;
// By default EventEmitters will print a warning if more than 10 listeners are
// added to it. This is a useful default which helps finding memory leaks.
var a,c=10;try{var l={};Object.defineProperty&&Object.defineProperty(l,"x",{value:0}),a=0===l.x}catch(e){a=!1}function u(e){return void 0===e._maxListeners?o.defaultMaxListeners:e._maxListeners}function d(e,t,n,r){var s,o,a;if("function"!=typeof n)throw new TypeError('"listener" argument must be a function');if((o=e._events)?(
// To avoid recursion in the case that type === "newListener"! Before
// adding it to the listeners, first emit "newListener".
o.newListener&&(e.emit("newListener",t,n.listener?n.listener:n),
// Re-assign `events` because a newListener handler could have caused the
// this._events to be assigned to a new object
o=e._events),a=o[t]):(o=e._events=i(null),e._eventsCount=0),a){
// Check for listener leak
if("function"==typeof a?
// Adding the second element, need to change to array.
a=o[t]=r?[n,a]:[a,n]:
// If we've already got an array, just append.
r?a.unshift(n):a.push(n),!a.warned&&(s=u(e))&&s>0&&a.length>s){a.warned=!0;var c=new Error("Possible EventEmitter memory leak detected. "+a.length+' "'+String(t)+'" listeners added. Use emitter.setMaxListeners() to increase limit.');c.name="MaxListenersExceededWarning",c.emitter=e,c.type=t,c.count=a.length,"object"==typeof console&&console.warn&&console.warn("%s: %s",c.name,c.message)}}else
// Optimize the case of one listener. Don't need the extra array object.
a=o[t]=n,++e._eventsCount;return e}function h(){if(!this.fired)switch(this.target.removeListener(this.type,this.wrapFn),this.fired=!0,arguments.length){case 0:return this.listener.call(this.target);case 1:return this.listener.call(this.target,arguments[0]);case 2:return this.listener.call(this.target,arguments[0],arguments[1]);case 3:return this.listener.call(this.target,arguments[0],arguments[1],arguments[2]);default:for(var e=new Array(arguments.length),t=0;t<e.length;++t)e[t]=arguments[t];this.listener.apply(this.target,e)}}function f(e,t,n){var i={fired:!1,wrapFn:void 0,target:e,type:t,listener:n},r=s.call(h,i);return r.listener=n,i.wrapFn=r,r}function p(e,t,n){var i=e._events;if(!i)return[];var r=i[t];return r?"function"==typeof r?n?[r.listener||r]:[r]:n?function(e){for(var t=new Array(e.length),n=0;n<t.length;++n)t[n]=e[n].listener||e[n];return t}(r):g(r,r.length):[]}function m(e){var t=this._events;if(t){var n=t[e];if("function"==typeof n)return 1;if(n)return n.length}return 0}function g(e,t){for(var n=new Array(t),i=0;i<t;++i)n[i]=e[i];return n}a?Object.defineProperty(o,"defaultMaxListeners",{enumerable:!0,get:function(){return c},set:function(e){
// check whether the input is a positive number (whose value is zero or
// greater and not a NaN).
if("number"!=typeof e||e<0||e!=e)throw new TypeError('"defaultMaxListeners" must be a positive number');c=e}}):o.defaultMaxListeners=c,
// Obviously not all Emitters should be limited to 10. This function allows
// that to be increased. Set to zero for unlimited.
o.prototype.setMaxListeners=function(e){if("number"!=typeof e||e<0||isNaN(e))throw new TypeError('"n" argument must be a positive number');return this._maxListeners=e,this},o.prototype.getMaxListeners=function(){return u(this)},o.prototype.emit=function(e){var t,n,i,r,s,o,a="error"===e;if(o=this._events)a=a&&null==o.error;else if(!a)return!1;
// If there is no 'error' event listener then throw.
if(a){if(arguments.length>1&&(t=arguments[1]),t instanceof Error)throw t;// Unhandled 'error' event
// At least give some kind of context to the user
var c=new Error('Unhandled "error" event. ('+t+")");throw c.context=t,c}if(!(n=o[e]))return!1;var l="function"==typeof n;switch(i=arguments.length){
// fast cases
case 1:!
// These standalone emit* functions are used to optimize calling of event
// handlers for fast cases because emit() itself often has a variable number of
// arguments and can be deoptimized because of that. These functions always have
// the same number of arguments and thus do not get deoptimized, so the code
// inside them can execute faster.
function(e,t,n){if(t)e.call(n);else for(var i=e.length,r=g(e,i),s=0;s<i;++s)r[s].call(n)}(n,l,this);break;case 2:!function(e,t,n,i){if(t)e.call(n,i);else for(var r=e.length,s=g(e,r),o=0;o<r;++o)s[o].call(n,i)}(n,l,this,arguments[1]);break;case 3:!function(e,t,n,i,r){if(t)e.call(n,i,r);else for(var s=e.length,o=g(e,s),a=0;a<s;++a)o[a].call(n,i,r)}(n,l,this,arguments[1],arguments[2]);break;case 4:!function(e,t,n,i,r,s){if(t)e.call(n,i,r,s);else for(var o=e.length,a=g(e,o),c=0;c<o;++c)a[c].call(n,i,r,s)}(n,l,this,arguments[1],arguments[2],arguments[3]);break;
// slower
default:for(r=new Array(i-1),s=1;s<i;s++)r[s-1]=arguments[s];!function(e,t,n,i){if(t)e.apply(n,i);else for(var r=e.length,s=g(e,r),o=0;o<r;++o)s[o].apply(n,i)}(n,l,this,r)}return!0},o.prototype.addListener=function(e,t){return d(this,e,t,!1)},o.prototype.on=o.prototype.addListener,o.prototype.prependListener=function(e,t){return d(this,e,t,!0)},o.prototype.once=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.on(e,f(this,e,t)),this},o.prototype.prependOnceListener=function(e,t){if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');return this.prependListener(e,f(this,e,t)),this},
// Emits a 'removeListener' event if and only if the listener was removed.
o.prototype.removeListener=function(e,t){var n,r,s,o,a;if("function"!=typeof t)throw new TypeError('"listener" argument must be a function');if(!(r=this._events))return this;if(!(n=r[e]))return this;if(n===t||n.listener===t)0==--this._eventsCount?this._events=i(null):(delete r[e],r.removeListener&&this.emit("removeListener",e,n.listener||t));else if("function"!=typeof n){for(s=-1,o=n.length-1;o>=0;o--)if(n[o]===t||n[o].listener===t){a=n[o].listener,s=o;break}if(s<0)return this;0===s?n.shift():
// About 1.5x faster than the two-arg version of Array#splice().
function(e,t){for(var n=t,i=n+1,r=e.length;i<r;n+=1,i+=1)e[n]=e[i];e.pop()}(n,s),1===n.length&&(r[e]=n[0]),r.removeListener&&this.emit("removeListener",e,a||t)}return this},o.prototype.removeAllListeners=function(e){var t,n,s;if(!(n=this._events))return this;
// not listening for removeListener, no need to emit
if(!n.removeListener)return 0===arguments.length?(this._events=i(null),this._eventsCount=0):n[e]&&(0==--this._eventsCount?this._events=i(null):delete n[e]),this;
// emit removeListener for all listeners on all events
if(0===arguments.length){var o,a=r(n);for(s=0;s<a.length;++s)"removeListener"!==(o=a[s])&&this.removeAllListeners(o);return this.removeAllListeners("removeListener"),this._events=i(null),this._eventsCount=0,this}if("function"==typeof(t=n[e]))this.removeListener(e,t);else if(t)
// LIFO order
for(s=t.length-1;s>=0;s--)this.removeListener(e,t[s]);return this},o.prototype.listeners=function(e){return p(this,e,!0)},o.prototype.rawListeners=function(e){return p(this,e,!1)},o.listenerCount=function(e,t){return"function"==typeof e.listenerCount?e.listenerCount(t):m.call(e,t)},o.prototype.listenerCount=m,o.prototype.eventNames=function(){return this._eventsCount>0?Reflect.ownKeys(this._events):[]}},{}],32:[function(e,t,n){var i,r;i=this,r=function(){/******/
return function(e){// webpackBootstrap
/******/ // The module cache
/******/var t={};
/******/
/******/ // The require function
/******/function n(i){
/******/
/******/ // Check if module is in cache
/******/if(t[i])
/******/return t[i].exports;
/******/
/******/ // Create a new module (and put it into the cache)
/******/var r=t[i]={
/******/i:i,
/******/l:!1,
/******/exports:{}
/******/};
/******/
/******/ // Execute the module function
/******/
/******/
/******/ // Return the exports of the module
/******/return e[i].call(r.exports,r,r.exports,n),
/******/
/******/ // Flag the module as loaded
/******/r.l=!0,r.exports;
/******/}
/******/
/******/
/******/ // expose the modules object (__webpack_modules__)
/******/
/******/
/******/ // Load entry module and return exports
/******/return n.m=e,
/******/
/******/ // expose the module cache
/******/n.c=t,
/******/
/******/ // identity function for calling harmony imports with the correct context
/******/n.i=function(e){return e},
/******/
/******/ // define getter function for harmony exports
/******/n.d=function(e,t,i){
/******/n.o(e,t)||
/******/Object.defineProperty(e,t,{
/******/configurable:!1,
/******/enumerable:!0,
/******/get:i
/******/})
/******/},
/******/
/******/ // getDefaultExport function for compatibility with non-harmony modules
/******/n.n=function(e){
/******/var t=e&&e.__esModule?
/******/function(){return e.default}:
/******/function(){return e};
/******/
/******/return n.d(t,"a",t),t;
/******/},
/******/
/******/ // Object.prototype.hasOwnProperty.call
/******/n.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},
/******/
/******/ // __webpack_public_path__
/******/n.p="",n(n.s=5);
/******/}
/************************************************************************/
/******/([
/* 0 */
/***/function(e,t,n){"use strict";e.exports=function(e,t){var n,i,r;for(n=1;n<arguments.length;n++)for(r in i=arguments[n])i.hasOwnProperty(r)&&(e[r]=i[r]);return e}
/***/},
/* 1 */
/***/function(e,t,n){"use strict";
//-------------------------------------------------------------------------------------------------
var i=n(0);
//-------------------------------------------------------------------------------------------------
e.exports={build:function(e,t){var n,r,s,o=t.plugins;for(n=0,r=o.length;n<r;n++)(s=o[n]).methods&&i(e,s.methods),s.properties&&Object.defineProperties(e,s.properties)},hook:function(e,t,n){var i,r,s,o,a=e.config.plugins,c=[e.context];for(n&&(c=c.concat(n)),i=0,r=a.length;i<r;i++)o=a[i],(s=a[i][t])&&s.apply(o,c)}};
//-------------------------------------------------------------------------------------------------
/***/},
/* 2 */
/***/function(e,t,n){"use strict";
//-------------------------------------------------------------------------------------------------
function i(e){if(0===e.length)return e;var t,n,i=e.split(/[_-]/);
// single word with first character already lowercase, return untouched
if(1===i.length&&i[0][0].toLowerCase()===i[0][0])return e;for(n=i[0].toLowerCase(),t=1;t<i.length;t++)n=n+i[t].charAt(0).toUpperCase()+i[t].substring(1).toLowerCase();return n}
//-------------------------------------------------------------------------------------------------
i.prepended=function(e,t){return e+(t=i(t))[0].toUpperCase()+t.substring(1)}
//-------------------------------------------------------------------------------------------------
,e.exports=i},
/* 3 */
/***/function(e,t,n){"use strict";
//-------------------------------------------------------------------------------------------------
var i=n(0),r=n(2);
//-------------------------------------------------------------------------------------------------
function s(e,t){e=e||{},this.options=e,// preserving original options can be useful (e.g visualize plugin)
this.defaults=t.defaults,this.states=[],this.transitions=[],this.map={},this.lifecycle=this.configureLifecycle(),this.init=this.configureInitTransition(e.init),this.data=this.configureData(e.data),this.methods=this.configureMethods(e.methods),this.map[this.defaults.wildcard]={},this.configureTransitions(e.transitions||[]),this.plugins=this.configurePlugins(e.plugins,t.plugin)}
//-------------------------------------------------------------------------------------------------
i(s.prototype,{addState:function(e){this.map[e]||(this.states.push(e),this.addStateLifecycleNames(e),this.map[e]={})},addStateLifecycleNames:function(e){this.lifecycle.onEnter[e]=r.prepended("onEnter",e),this.lifecycle.onLeave[e]=r.prepended("onLeave",e),this.lifecycle.on[e]=r.prepended("on",e)},addTransition:function(e){this.transitions.indexOf(e)<0&&(this.transitions.push(e),this.addTransitionLifecycleNames(e))},addTransitionLifecycleNames:function(e){this.lifecycle.onBefore[e]=r.prepended("onBefore",e),this.lifecycle.onAfter[e]=r.prepended("onAfter",e),this.lifecycle.on[e]=r.prepended("on",e)},mapTransition:function(e){var t=e.name,n=e.from,i=e.to;return this.addState(n),"function"!=typeof i&&this.addState(i),this.addTransition(t),this.map[n][t]=e,e},configureLifecycle:function(){return{onBefore:{transition:"onBeforeTransition"},onAfter:{transition:"onAfterTransition"},onEnter:{state:"onEnterState"},onLeave:{state:"onLeaveState"},on:{transition:"onTransition"}}},configureInitTransition:function(e){return"string"==typeof e?this.mapTransition(i({},this.defaults.init,{to:e,active:!0})):"object"==typeof e?this.mapTransition(i({},this.defaults.init,e,{active:!0})):(this.addState(this.defaults.init.from),this.defaults.init)},configureData:function(e){return"function"==typeof e?e:"object"==typeof e?function(){return e}:function(){return{}}},configureMethods:function(e){return e||{}},configurePlugins:function(e,t){var n,i,r;for(n=0,i=(e=e||[]).length;n<i;n++)"function"==typeof(r=e[n])&&(e[n]=r=r()),r.configure&&r.configure(this);return e},configureTransitions:function(e){var t,n,i,r,s,o=this.defaults.wildcard;for(n=0;n<e.length;n++)for(i=e[n],r=Array.isArray(i.from)?i.from:[i.from||o],s=i.to||o,t=0;t<r.length;t++)this.mapTransition({name:i.name,from:r[t],to:s})},transitionFor:function(e,t){var n=this.defaults.wildcard;return this.map[e][t]||this.map[n][t]},transitionsFor:function(e){var t=this.defaults.wildcard;return Object.keys(this.map[e]).concat(Object.keys(this.map[t]))},allStates:function(){return this.states},allTransitions:function(){return this.transitions}}),
//-------------------------------------------------------------------------------------------------
e.exports=s},
/* 4 */
/***/function(e,t,n){var i=n(0),r=n(6),s=n(1),o=[null,[]];
//-------------------------------------------------------------------------------------------------
function a(e,t){this.context=e,this.config=t,this.state=t.init.from,this.observers=[e]}
//-------------------------------------------------------------------------------------------------
i(a.prototype,{init:function(e){if(i(this.context,this.config.data.apply(this.context,e)),s.hook(this,"init"),this.config.init.active)return this.fire(this.config.init.name,[])},is:function(e){return Array.isArray(e)?e.indexOf(this.state)>=0:this.state===e},isPending:function(){return this.pending},can:function(e){return!this.isPending()&&!!this.seek(e)},cannot:function(e){return!this.can(e)},allStates:function(){return this.config.allStates()},allTransitions:function(){return this.config.allTransitions()},transitions:function(){return this.config.transitionsFor(this.state)},seek:function(e,t){var n=this.config.defaults.wildcard,i=this.config.transitionFor(this.state,e),r=i&&i.to;return"function"==typeof r?r.apply(this.context,t):r===n?this.state:r},fire:function(e,t){return this.transit(e,this.state,this.seek(e,t),t)},transit:function(e,t,n,i){var r=this.config.lifecycle,s=this.config.options.observeUnchangedState||t!==n;return n?this.isPending()?this.context.onPendingTransition(e,t,n):(this.config.addState(n),// might need to add this state if it's unknown (e.g. conditional transition or goto)
this.beginTransit(),i.unshift({// this context will be passed to each lifecycle event observer
transition:e,from:t,to:n,fsm:this.context}),this.observeEvents([this.observersForEvent(r.onBefore.transition),this.observersForEvent(r.onBefore[e]),s?this.observersForEvent(r.onLeave.state):o,s?this.observersForEvent(r.onLeave[t]):o,this.observersForEvent(r.on.transition),s?["doTransit",[this]]:o,s?this.observersForEvent(r.onEnter.state):o,s?this.observersForEvent(r.onEnter[n]):o,s?this.observersForEvent(r.on[n]):o,this.observersForEvent(r.onAfter.transition),this.observersForEvent(r.onAfter[e]),this.observersForEvent(r.on[e])],i)):this.context.onInvalidTransition(e,t,n)},beginTransit:function(){this.pending=!0},endTransit:function(e){return this.pending=!1,e},failTransit:function(e){throw this.pending=!1,e},doTransit:function(e){this.state=e.to},observe:function(e){if(2===e.length){var t={};t[e[0]]=e[1],this.observers.push(t)}else this.observers.push(e[0])},observersForEvent:function(e){for(// TODO: this could be cached
var t,n=0,i=this.observers.length,r=[];n<i;n++)(t=this.observers[n])[e]&&r.push(t);return[e,r,!0]},observeEvents:function(e,t,n,i){if(0===e.length)return this.endTransit(void 0===i||i);var r=e[0][0],o=e[0][1],a=e[0][2];if(t[0].event=r,r&&a&&r!==n&&s.hook(this,"lifecycle",t),0===o.length)return e.shift(),this.observeEvents(e,t,r,i);var c=o.shift(),l=c[r].apply(c,t);return l&&"function"==typeof l.then?l.then(this.observeEvents.bind(this,e,t,r)).catch(this.failTransit.bind(this)):!1===l?this.endTransit(!1):this.observeEvents(e,t,r,l)},onInvalidTransition:function(e,t,n){throw new r("transition is invalid in current state",e,t,n,this.state)},onPendingTransition:function(e,t,n){throw new r("transition is invalid while previous transition is still in progress",e,t,n,this.state)}}),
//-------------------------------------------------------------------------------------------------
e.exports=a},
/* 5 */
/***/function(e,t,n){"use strict";
//-----------------------------------------------------------------------------------------------
var i=n(0),r=n(2),s=n(1),o=n(3),a=n(4),c={is:function(e){return this._fsm.is(e)},can:function(e){return this._fsm.can(e)},cannot:function(e){return this._fsm.cannot(e)},observe:function(){return this._fsm.observe(arguments)},transitions:function(){return this._fsm.transitions()},allTransitions:function(){return this._fsm.allTransitions()},allStates:function(){return this._fsm.allStates()},onInvalidTransition:function(e,t,n){return this._fsm.onInvalidTransition(e,t,n)},onPendingTransition:function(e,t,n){return this._fsm.onPendingTransition(e,t,n)}},l={state:{configurable:!1,enumerable:!0,get:function(){return this._fsm.state},set:function(e){throw Error("use transitions to change state")}}};
//-----------------------------------------------------------------------------------------------
//-----------------------------------------------------------------------------------------------
function u(e){return d(this||{},e)}
//-------------------------------------------------------------------------------------------------
function d(e,t){return h(e,new o(t,u)),e._fsm(),e}function h(e,t){if("object"!=typeof e||Array.isArray(e))throw Error("StateMachine can only be applied to objects");s.build(e,t),Object.defineProperties(e,l),i(e,c),i(e,t.methods),t.allTransitions().forEach(function(t){e[r(t)]=function(){return this._fsm.fire(t,[].slice.call(arguments))}}),e._fsm=function(){this._fsm=new a(this,t),this._fsm.init(arguments)}}
//-----------------------------------------------------------------------------------------------
u.version="3.0.1",u.factory=function(){var e,t;"function"==typeof arguments[0]?(e=arguments[0],t=arguments[1]||{}):(e=function(){this._fsm.apply(this,arguments)},t=arguments[0]||{});var n=new o(t,u);// convenience access to shared config without needing an instance
return h(e.prototype,n),e.prototype._fsm.config=n,e},u.apply=d,u.defaults={wildcard:"*",init:{name:"init",from:"none"}},
//===============================================================================================
e.exports=u},
/* 6 */
/***/function(e,t,n){"use strict";e.exports=function(e,t,n,i,r){this.message=e,this.transition=t,this.from=n,this.to=i,this.current=r}
/***/}
/******/])},"object"==typeof n&&"object"==typeof t?t.exports=r():"object"==typeof n?n.StateMachine=r():i.StateMachine=r()},{}],33:[function(e,t,n){
/*
* loglevel - https://github.com/pimterry/loglevel
*
* Copyright (c) 2013 Tim Perry
* Licensed under the MIT license.
*/
!function(e,n){"use strict";"object"==typeof t&&t.exports?t.exports=n():e.log=n()}(this,function(){"use strict";
// Slightly dubious tricks to cut down minimized file size
var e=function(){},t="undefined",n=typeof window!==t&&typeof window.navigator!==t&&/Trident\/|MSIE /.test(window.navigator.userAgent),i=["trace","debug","info","warn","error"];
// Cross-browser bind equivalent that works at least back to IE6
function r(e,t){var n=e[t];if("function"==typeof n.bind)return n.bind(e);try{return Function.prototype.bind.call(n,e)}catch(t){
// Missing bind shim or IE8 + Modernizr, fallback to wrapping
return function(){return Function.prototype.apply.apply(n,[e,arguments])}}}
// Trace() doesn't print the message in IE, so for that case we need to wrap it
function s(){console.log&&(console.log.apply?console.log.apply(console,arguments):
// In old IE, native console methods themselves don't have apply().
Function.prototype.apply.apply(console.log,[console,arguments])),console.trace&&console.trace()}
// Build the best logging method possible for this env
// Wherever possible we want to bind, not wrap, to preserve stack traces
// These private functions always need `this` to be set properly
function o(t,n){
/*jshint validthis:true */
for(var r=0;r<i.length;r++){var s=i[r];this[s]=r<t?e:this.methodFactory(s,t,n)}
// Define log.log as an alias for log.debug
this.log=this.debug}
// In old IE versions, the console isn't present until you first open it.
// We build realMethod() replacements here that regenerate logging methods
// By default, we use closely bound real methods wherever possible, and
// otherwise we wait for a console to appear, and then try again.
function a(i,a,c){
/*jshint validthis:true */
return function(i){return"debug"===i&&(i="log"),typeof console!==t&&("trace"===i&&n?s:void 0!==console[i]?r(console,i):void 0!==console.log?r(console,"log"):e)}(i)||function(e,n,i){return function(){typeof console!==t&&(o.call(this,n,i),this[e].apply(this,arguments))}}.apply(this,arguments)}function c(e,n,r){var s,c=this,l="loglevel";function u(){var e;if(typeof window!==t){try{e=window.localStorage[l]}catch(e){}
// Fallback to cookies if local storage gives us nothing
if(typeof e===t)try{var n=window.document.cookie,i=n.indexOf(encodeURIComponent(l)+"=");-1!==i&&(e=/^([^;]+)/.exec(n.slice(i))[1])}catch(e){}
// If the stored level is not valid, treat it as if nothing was stored.
return void 0===c.levels[e]&&(e=void 0),e}}
/*
       *
       * Public logger API - see https://github.com/pimterry/loglevel for details
       *
       */e&&(l+=":"+e),c.name=e,c.levels={TRACE:0,DEBUG:1,INFO:2,WARN:3,ERROR:4,SILENT:5},c.methodFactory=r||a,c.getLevel=function(){return s},c.setLevel=function(n,r){if("string"==typeof n&&void 0!==c.levels[n.toUpperCase()]&&(n=c.levels[n.toUpperCase()]),!("number"==typeof n&&n>=0&&n<=c.levels.SILENT))throw"log.setLevel() called with invalid level: "+n;if(s=n,!1!==r&&// defaults to true
function(e){var n=(i[e]||"silent").toUpperCase();if(typeof window!==t){
// Use localStorage if available
try{return void(window.localStorage[l]=n)}catch(e){}
// Use session cookie as fallback
try{window.document.cookie=encodeURIComponent(l)+"="+n+";"}catch(e){}}}(n),o.call(c,n,e),typeof console===t&&n<c.levels.SILENT)return"No console available for logging"},c.setDefaultLevel=function(e){u()||c.setLevel(e,!1)},c.enableAll=function(e){c.setLevel(c.levels.TRACE,e)},c.disableAll=function(e){c.setLevel(c.levels.SILENT,e)};
// Initialize with the right level
var d=u();null==d&&(d=null==n?"WARN":n),c.setLevel(d,!1)}
/*
     *
     * Top-level API
     *
     */var l=new c,u={};l.getLogger=function(e){if("string"!=typeof e||""===e)throw new TypeError("You must supply a name when creating a logger.");var t=u[e];return t||(t=u[e]=new c(e,l.getLevel(),l.methodFactory)),t};
// Grab the current global log variable in case of overwrite
var d=typeof window!==t?window.log:void 0;return l.noConflict=function(){return typeof window!==t&&window.log===l&&(window.log=d),l},l.getLoggers=function(){return u},l})},{}],34:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("events");function r(e){return null!=e}class s extends i.EventEmitter{constructor(e){if(super(),r((e=e||{}).initialDelay)&&e.initialDelay<1)throw new Error("The initial timeout must be equal to or greater than 1.");if(r(e.maxDelay)&&e.maxDelay<=1)throw new Error("The maximal timeout must be greater than 1.");if(r(e.randomisationFactor)&&(e.randomisationFactor<0||e.randomisationFactor>1))throw new Error("The randomisation factor must be between 0 and 1.");if(r(e.factor)&&e.factor<=1)throw new Error("Exponential factor should be greater than 1.");if(this.initialDelay=e.initialDelay||100,this.maxDelay=e.maxDelay||1e4,this.maxDelay<=this.initialDelay)throw new Error("The maximal backoff delay must be greater than the initial backoff delay.");this.randomisationFactor=e.randomisationFactor||0,this.factor=e.factor||2,this.maxNumberOfRetry=-1,this.reset()}static exponential(e){return new s(e)}backoff(e){null==this.timeoutID&&(this.backoffNumber===this.maxNumberOfRetry?(this.emit("fail",e),this.reset()):(this.backoffDelay=this.next(),this.timeoutID=setTimeout(this.onBackoff.bind(this),this.backoffDelay),this.emit("backoff",this.backoffNumber,this.backoffDelay,e)))}reset(){this.backoffDelay=0,this.nextBackoffDelay=this.initialDelay,this.backoffNumber=0,clearTimeout(this.timeoutID),this.timeoutID=null}failAfter(e){if(e<=0)throw new Error(`Expected a maximum number of retry greater than 0 but got ${e}`);this.maxNumberOfRetry=e}next(){this.backoffDelay=Math.min(this.nextBackoffDelay,this.maxDelay),this.nextBackoffDelay=this.backoffDelay*this.factor;let e=1+Math.random()*this.randomisationFactor;return Math.min(this.maxDelay,Math.round(this.backoffDelay*e))}onBackoff(){this.timeoutID=null,this.emit("ready",this.backoffNumber,this.backoffDelay),this.backoffNumber++}}n.Backoff=s,n.default=s},{events:31}],35:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("./retrier");n.Retrier=i.Retrier;const r=e("./backoff");n.Backoff=r.Backoff,n.default=i.Retrier},{"./backoff":34,"./retrier":36}],36:[function(e,t,n){"use strict";Object.defineProperty(n,"__esModule",{value:!0});const i=e("events");
/**
 * Provides retrier service
 */class r extends i.EventEmitter{
/**
     * Creates a new Retrier instance
     */
constructor(e){super(),this.minDelay=e.min,this.maxDelay=e.max,this.initialDelay=e.initial||0,this.maxAttemptsCount=e.maxAttemptsCount||0,this.maxAttemptsTime=e.maxAttemptsTime||0,this.randomness=e.randomness||0,this.inProgress=!1,this.attemptNum=0,this.prevDelay=0,this.currDelay=0}attempt(){clearTimeout(this.timeout),this.attemptNum++,this.timeout=null,this.emit("attempt",this)}nextDelay(e){if("number"==typeof e)return this.prevDelay=0,this.currDelay=e,e;if(0==this.attemptNum)return this.initialDelay;if(1==this.attemptNum)return this.currDelay=this.minDelay,this.currDelay;this.prevDelay=this.currDelay;let t=this.currDelay+this.prevDelay;return this.maxDelay&&t>this.maxDelay&&(this.currDelay=this.maxDelay,t=this.maxDelay),this.currDelay=t,t}randomize(e){let t=e*this.randomness,n=Math.round(Math.random()*t*2-t);return Math.max(0,e+n)}scheduleAttempt(e){if(this.maxAttemptsCount&&this.attemptNum>=this.maxAttemptsCount)return this.cleanup(),this.emit("failed",new Error("Maximum attempt count limit reached")),void this.reject(new Error("Maximum attempt count reached"));let t=this.nextDelay(e);if(t=this.randomize(t),this.maxAttemptsTime&&this.startTimestamp+this.maxAttemptsTime<Date.now()+t)return this.cleanup(),this.emit("failed",new Error("Maximum attempt time limit reached")),void this.reject(new Error("Maximum attempt time limit reached"));this.timeout=setTimeout(()=>this.attempt(),t)}cleanup(){clearTimeout(this.timeout),this.timeout=null,this.inProgress=!1,this.attemptNum=0,this.prevDelay=0,this.currDelay=0}start(){if(this.inProgress)throw new Error("Retrier is already in progress");return this.inProgress=!0,new Promise((e,t)=>{this.resolve=e,this.reject=t,this.startTimestamp=Date.now(),this.scheduleAttempt(this.initialDelay)})}cancel(){this.timeout&&(clearTimeout(this.timeout),this.timeout=null,this.inProgress=!1,this.emit("cancelled"),this.reject(new Error("Cancelled")))}succeeded(e){this.emit("succeeded",e),this.resolve(e)}failed(e,t){if(this.timeout)throw new Error("Retrier attempt is already in progress");this.scheduleAttempt(t)}run(e){return this.on("attempt",()=>{e().then(e=>this.succeeded(e)).catch(e=>this.failed(e))}),this.start()}}n.Retrier=r,n.default=r},{events:31}],37:[function(e,t,n){(function(e){(function(){"use strict";
/** Used to determine if values are of the language type `Object`. */var i={function:!0,object:!0},r=i[typeof window]&&window||this,s=i[typeof n]&&n,o=i[typeof t]&&t&&!t.nodeType&&t,a=s&&o&&"object"==typeof e&&e;
/** Used as a reference to the global object. */!a||a.global!==a&&a.window!==a&&a.self!==a||(r=a)
/**
   * Used as the maximum length of an array-like object.
   * See the [ES6 spec](http://people.mozilla.org/~jorendorff/es6-draft.html#sec-tolength)
   * for more details.
   */;var c=Math.pow(2,53)-1,l=/\bOpera/,u=Object.prototype,d=u.hasOwnProperty,h=u.toString;
/** Regular expression to detect Opera. */
/*--------------------------------------------------------------------------*/
/**
   * Capitalizes a string value.
   *
   * @private
   * @param {string} string The string to capitalize.
   * @returns {string} The capitalized string.
   */
function f(e){return(e=String(e)).charAt(0).toUpperCase()+e.slice(1)}
/**
   * A utility function to clean up the OS name.
   *
   * @private
   * @param {string} os The OS name to clean up.
   * @param {string} [pattern] A `RegExp` pattern matching the OS name.
   * @param {string} [label] A label for the OS.
   */
/**
   * Trim and conditionally capitalize string values.
   *
   * @private
   * @param {string} string The string to format.
   * @returns {string} The formatted string.
   */
function p(e){return e=v(e),/^(?:webOS|i(?:OS|P))/.test(e)?e:f(e)}
/**
   * Iterates over an object's own properties, executing the `callback` for each.
   *
   * @private
   * @param {Object} object The object to iterate over.
   * @param {Function} callback The function executed per own property.
   */function m(e,t){for(var n in e)d.call(e,n)&&t(e[n],n,e)}
/**
   * Gets the internal `[[Class]]` of a value.
   *
   * @private
   * @param {*} value The value.
   * @returns {string} The `[[Class]]`.
   */function g(e){return null==e?f(e):h.call(e).slice(8,-1)}
/**
   * Host objects can return type values that are different from their actual
   * data type. The objects we are concerned with usually return non-primitive
   * types of "object", "function", or "unknown".
   *
   * @private
   * @param {*} object The owner of the property.
   * @param {string} property The property to check.
   * @returns {boolean} Returns `true` if the property value is a non-primitive, else `false`.
   */
/**
   * Prepares a string for use in a `RegExp` by making hyphens and spaces optional.
   *
   * @private
   * @param {string} string The string to qualify.
   * @returns {string} The qualified string.
   */
function y(e){return String(e).replace(/([ -])(?!$)/g,"$1?")}
/**
   * A bare-bones `Array#reduce` like utility function.
   *
   * @private
   * @param {Array} array The array to iterate over.
   * @param {Function} callback The function called per iteration.
   * @returns {*} The accumulated result.
   */function b(e,t){var n=null;
/**
   * An iteration utility for arrays and objects.
   *
   * @private
   * @param {Array|Object} object The object to iterate over.
   * @param {Function} callback The function called per iteration.
   */
return function(e,t){var n=-1,i=e?e.length:0;if("number"==typeof i&&i>-1&&i<=c)for(;++n<i;)t(e[n],n,e);else m(e,t)}(e,function(i,r){n=t(n,i,r,e)}),n}
/**
   * Removes leading and trailing whitespace from a string.
   *
   * @private
   * @param {string} string The string to trim.
   * @returns {string} The trimmed string.
   */function v(e){return String(e).replace(/^ +| +$/g,"")}
/*--------------------------------------------------------------------------*/
/**
   * Creates a new platform object.
   *
   * @memberOf platform
   * @param {Object|string} [ua=navigator.userAgent] The user agent string or
   *  context object.
   * @returns {Object} A platform object.
   */
/*--------------------------------------------------------------------------*/
// Export platform.
var w=function e(t){
/** The environment context object. */
var n=r,i=t&&"object"==typeof t&&"String"!=g(t);
/** Used to flag when a custom context is provided. */
// Juggle arguments.
i&&(n=t,t=null)
/** Browser navigator object. */;var s=n.navigator||{},o=s.userAgent||"";
/** Browser user agent string. */t||(t=o);
/** Used to flag when `thisBinding` is the [ModuleScope]. */
var a,c,u,d,f,w=i?!!s.likeChrome:/\bChrome\b/.test(t)&&!/internal|\n/i.test(h.toString()),k=i?"Object":"ScriptBridgingProxyObject",S=i?"Object":"Environment",T=i&&n.java?"JavaPackage":g(n.java),E=i?"Object":"RuntimeObject",x=/\bJava/.test(T)&&n.java,C=x&&g(n.environment)==S,_=x?"a":"\u03b1",O=x?"b":"\u03b2",P=n.document||{},M=n.operamini||n.opera,R=l.test(R=i&&M?M["[[Class]]"]:g(M))?R:M=null,I=t,j=[],A=null,D=t==o,L=D&&M&&"function"==typeof M.version&&M.version(),B=b([{label:"EdgeHTML",pattern:"Edge"},"Trident",{label:"WebKit",pattern:"AppleWebKit"},"iCab","Presto","NetFront","Tasman","KHTML","Gecko"],function(e,n){return e||RegExp("\\b"+(n.pattern||y(n))+"\\b","i").exec(t)&&(n.label||n)}),F=
/**
     * Picks the browser name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected browser name.
     */
function(e){return b(e,function(e,n){return e||RegExp("\\b"+(n.pattern||y(n))+"\\b","i").exec(t)&&(n.label||n)})}
/**
     * Picks the OS name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected OS name.
     */(["Adobe AIR","Arora","Avant Browser","Breach","Camino","Electron","Epiphany","Fennec","Flock","Galeon","GreenBrowser","iCab","Iceweasel","K-Meleon","Konqueror","Lunascape","Maxthon",{label:"Microsoft Edge",pattern:"(?:Edge|Edg|EdgA|EdgiOS)"},"Midori","Nook Browser","PaleMoon","PhantomJS","Raven","Rekonq","RockMelt",{label:"Samsung Internet",pattern:"SamsungBrowser"},"SeaMonkey",{label:"Silk",pattern:"(?:Cloud9|Silk-Accelerated)"},"Sleipnir","SlimBrowser",{label:"SRWare Iron",pattern:"Iron"},"Sunrise","Swiftfox","Vivaldi","Waterfox","WebPositive",{label:"Yandex Browser",pattern:"YaBrowser"},{label:"UC Browser",pattern:"UCBrowser"},"Opera Mini",{label:"Opera Mini",pattern:"OPiOS"},"Opera",{label:"Opera",pattern:"OPR"},"Chromium","Chrome",{label:"Chrome",pattern:"(?:HeadlessChrome)"},{label:"Chrome Mobile",pattern:"(?:CriOS|CrMo)"},{label:"Firefox",pattern:"(?:Firefox|Minefield)"},{label:"Firefox for iOS",pattern:"FxiOS"},{label:"IE",pattern:"IEMobile"},{label:"IE",pattern:"MSIE"},"Safari"]),N=W([{label:"BlackBerry",pattern:"BB10"},"BlackBerry",{label:"Galaxy S",pattern:"GT-I9000"},{label:"Galaxy S2",pattern:"GT-I9100"},{label:"Galaxy S3",pattern:"GT-I9300"},{label:"Galaxy S4",pattern:"GT-I9500"},{label:"Galaxy S5",pattern:"SM-G900"},{label:"Galaxy S6",pattern:"SM-G920"},{label:"Galaxy S6 Edge",pattern:"SM-G925"},{label:"Galaxy S7",pattern:"SM-G930"},{label:"Galaxy S7 Edge",pattern:"SM-G935"},"Google TV","Lumia","iPad","iPod","iPhone","Kindle",{label:"Kindle Fire",pattern:"(?:Cloud9|Silk-Accelerated)"},"Nexus","Nook","PlayBook","PlayStation Vita","PlayStation","TouchPad","Transformer",{label:"Wii U",pattern:"WiiU"},"Wii","Xbox One",{label:"Xbox 360",pattern:"Xbox"},"Xoom"]),$=
/**
     * Picks the manufacturer from an array of guesses.
     *
     * @private
     * @param {Array} guesses An object of guesses.
     * @returns {null|string} The detected manufacturer.
     */
function(e){return b(e,function(e,n,i){
// Lookup the manufacturer by product or scan the UA for the manufacturer.
return e||(n[N]||n[/^[a-z]+(?: +[a-z]+\b)*/i.exec(N)]||RegExp("\\b"+y(i)+"(?:\\b|\\w*\\d)","i").exec(t))&&i})}({Apple:{iPad:1,iPhone:1,iPod:1},Alcatel:{},Archos:{},Amazon:{Kindle:1,"Kindle Fire":1},Asus:{Transformer:1},"Barnes & Noble":{Nook:1},BlackBerry:{PlayBook:1},Google:{"Google TV":1,Nexus:1},HP:{TouchPad:1},HTC:{},Huawei:{},Lenovo:{},LG:{},Microsoft:{Xbox:1,"Xbox One":1},Motorola:{Xoom:1},Nintendo:{"Wii U":1,Wii:1},Nokia:{Lumia:1},Oppo:{},Samsung:{"Galaxy S":1,"Galaxy S2":1,"Galaxy S3":1,"Galaxy S4":1},Sony:{PlayStation:1,"PlayStation Vita":1},Xiaomi:{Mi:1,Redmi:1}}),U=function(e){return b(e,function(e,n){var i=n.pattern||y(n);return!e&&(e=RegExp("\\b"+i+"(?:/[\\d.]+|[ \\w.]*)","i").exec(t))&&(e=function(e,t,n){
// Platform tokens are defined at:
// http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
// http://web.archive.org/web/20081122053950/http://msdn.microsoft.com/en-us/library/ms537503(VS.85).aspx
var i={"10.0":"10",6.4:"10 Technical Preview",6.3:"8.1",6.2:"8",6.1:"Server 2008 R2 / 7","6.0":"Server 2008 / Vista",5.2:"Server 2003 / XP 64-bit",5.1:"XP",5.01:"2000 SP1","5.0":"2000","4.0":"NT","4.90":"ME"};
// Detect Windows version from platform tokens.
return t&&n&&/^Win/i.test(e)&&!/^Windows Phone /i.test(e)&&(i=i[/[\d.]+$/.exec(e)])&&(e="Windows "+i),
// Correct character case and cleanup string.
e=String(e),t&&n&&(e=e.replace(RegExp(t,"i"),n)),e=p(e.replace(/ ce$/i," CE").replace(/\bhpw/i,"web").replace(/\bMacintosh\b/,"Mac OS").replace(/_PowerPC\b/i," OS").replace(/\b(OS X) [^ \d]+/i,"$1").replace(/\bMac (OS X)\b/,"$1").replace(/\/(\d)/," $1").replace(/_/g,".").replace(/(?: BePC|[ .]*fc[ \d.]+)$/i,"").replace(/\bx86\.64\b/gi,"x86_64").replace(/\b(Windows Phone) OS\b/,"$1").replace(/\b(Chrome OS \w+) [\d.]+\b/,"$1").split(" on ")[0])}(e,i,n.label||n)),e})}
/**
     * Picks the product name from an array of guesses.
     *
     * @private
     * @param {Array} guesses An array of guesses.
     * @returns {null|string} The detected product name.
     */(["Windows Phone","KaiOS","Android","CentOS",{label:"Chrome OS",pattern:"CrOS"},"Debian",{label:"DragonFly BSD",pattern:"DragonFly"},"Fedora","FreeBSD","Gentoo","Haiku","Kubuntu","Linux Mint","OpenBSD","Red Hat","SuSE","Ubuntu","Xubuntu","Cygwin","Symbian OS","hpwOS","webOS ","webOS","Tablet OS","Tizen","Linux","Mac OS X","Macintosh","Mac","Windows 98;","Windows "]);
/** Used to detect if browser is like Chrome. */function W(e){return b(e,function(e,n){var i=n.pattern||y(n);return!e&&(e=RegExp("\\b"+i+" *\\d+[.\\w_]*","i").exec(t)||RegExp("\\b"+i+" *\\w+-[\\w]*","i").exec(t)||RegExp("\\b"+i+"(?:; *(?:[a-z]+[_-])?[a-z]+\\d+|[^ ();-]*)","i").exec(t))&&(
// Split by forward slash and append product version if needed.
(e=String(n.label&&!RegExp(i,"i").test(n.label)?n.label:e).split("/"))[1]&&!/[\d.]+/.test(e[0])&&(e[0]+=" "+e[1]),
// Correct character case and cleanup string.
n=n.label||n,e=p(e[0].replace(RegExp(i,"i"),n).replace(RegExp("; *(?:"+n+"[_-])?","i")," ").replace(RegExp("("+n+")[-_.]?(\\w)","i"),"$1 $2"))),e})}
/**
     * Resolves the version using an array of UA patterns.
     *
     * @private
     * @param {Array} patterns An array of UA patterns.
     * @returns {null|string} The detected version.
     */function z(e){return b(e,function(e,n){return e||(RegExp(n+"(?:-[\\d.]+/|(?: for [\\w-]+)?[ /-])([\\d.]+[^ ();/_-]*)","i").exec(t)||0)[1]||null})}
/**
     * Returns `platform.description` when the platform object is coerced to a string.
     *
     * @name toString
     * @memberOf platform
     * @returns {string} Returns `platform.description` if available, else an empty string.
     */
// Leverage environment features.
if(
/*------------------------------------------------------------------------*/
// Convert layout to an array so we can add extra details.
B&&(B=[B]),
// Detect Android products.
// Browsers on Android devices typically provide their product IDS after "Android;"
// up to "Build" or ") AppleWebKit".
// Example:
// "Mozilla/5.0 (Linux; Android 8.1.0; Moto G (5) Plus) AppleWebKit/537.36
// (KHTML, like Gecko) Chrome/70.0.3538.80 Mobile Safari/537.36"
/\bAndroid\b/.test(U)&&!N&&(a=/\bAndroid[^;]*;(.*?)(?:Build|\) AppleWebKit)\b/i.exec(t))&&(N=v(a[1]).replace(/^[a-z]{2}-[a-z]{2};\s*/i,"")||null),
// Detect product names that contain their manufacturer's name.
$&&!N?N=W([$]):$&&N&&(N=N.replace(RegExp("^("+y($)+")[-_.\\s]","i"),$+" ").replace(RegExp("^("+y($)+")[-_.]?(\\w)","i"),$+" $2")),
// Clean up Google TV.
(a=/\bGoogle TV\b/.exec(N))&&(N=a[0]),
// Detect simulators.
/\bSimulator\b/i.test(t)&&(N=(N?N+" ":"")+"Simulator"),
// Detect Opera Mini 8+ running in Turbo/Uncompressed mode on iOS.
"Opera Mini"==F&&/\bOPiOS\b/.test(t)&&j.push("running in Turbo/Uncompressed mode"),
// Detect IE Mobile 11.
"IE"==F&&/\blike iPhone OS\b/.test(t)?($=(a=e(t.replace(/like iPhone OS/,""))).manufacturer,N=a.product):/^iP/.test(N)?(F||(F="Safari"),U="iOS"+((a=/ OS ([\d_]+)/i.exec(t))?" "+a[1].replace(/_/g,"."):"")):"Konqueror"==F&&/^Linux\b/i.test(U)?U="Kubuntu":$&&"Google"!=$&&(/Chrome/.test(F)&&!/\bMobile Safari\b/i.test(t)||/\bVita\b/.test(N))||/\bAndroid\b/.test(U)&&/^Chrome/.test(F)&&/\bVersion\//i.test(t)?(F="Android Browser",U=/\bAndroid\b/.test(U)?U:"Android"):"Silk"==F?(/\bMobi/i.test(t)||(U="Android",j.unshift("desktop mode")),/Accelerated *= *true/i.test(t)&&j.unshift("accelerated")):"UC Browser"==F&&/\bUCWEB\b/.test(t)?j.push("speed mode"):"PaleMoon"==F&&(a=/\bFirefox\/([\d.]+)\b/.exec(t))?j.push("identifying as Firefox "+a[1]):"Firefox"==F&&(a=/\b(Mobile|Tablet|TV)\b/i.exec(t))?(U||(U="Firefox OS"),N||(N=a[1])):!F||(a=!/\bMinefield\b/i.test(t)&&/\b(?:Firefox|Safari)\b/.exec(F))?(
// Escape the `/` for Firefox 1.
F&&!N&&/[\/,]|^[^(]+?\)/.test(t.slice(t.indexOf(a+"/")+8))&&(
// Clear name of false positives.
F=null),
// Reassign a generic name.
(a=N||$||U)&&(N||$||/\b(?:Android|Symbian OS|Tablet OS|webOS)\b/.test(U))&&(F=/[a-z]+(?: Hat)?/i.exec(/\bAndroid\b/.test(U)?U:a)+" Browser")):"Electron"==F&&(a=(/\bChrome\/([\d.]+)\b/.exec(t)||0)[1])&&j.push("Chromium "+a),
// Detect non-Opera (Presto-based) versions (order is important).
L||(L=z(["(?:Cloud9|CriOS|CrMo|Edge|Edg|EdgA|EdgiOS|FxiOS|HeadlessChrome|IEMobile|Iron|Opera ?Mini|OPiOS|OPR|Raven|SamsungBrowser|Silk(?!/[\\d.]+$)|UCBrowser|YaBrowser)","Version",y(F),"(?:Firefox|Minefield|NetFront)"])),
// Detect stubborn layout engines.
(a=("iCab"==B&&parseFloat(L)>3?"WebKit":/\bOpera\b/.test(F)&&(/\bOPR\b/.test(t)?"Blink":"Presto"))||/\b(?:Midori|Nook|Safari)\b/i.test(t)&&!/^(?:Trident|EdgeHTML)$/.test(B)&&"WebKit"||!B&&/\bMSIE\b/i.test(t)&&("Mac OS"==U?"Tasman":"Trident")||"WebKit"==B&&/\bPlayStation\b(?! Vita\b)/i.test(F)&&"NetFront")&&(B=[a]),
// Detect Windows Phone 7 desktop mode.
"IE"==F&&(a=(/; *(?:XBLWP|ZuneWP)(\d+)/i.exec(t)||0)[1])?(F+=" Mobile",U="Windows Phone "+(/\+$/.test(a)?a:a+".x"),j.unshift("desktop mode")):/\bWPDesktop\b/i.test(t)?(F="IE Mobile",U="Windows Phone 8.x",j.unshift("desktop mode"),L||(L=(/\brv:([\d.]+)/.exec(t)||0)[1])):"IE"!=F&&"Trident"==B&&(a=/\brv:([\d.]+)/.exec(t))&&(F&&j.push("identifying as "+F+(L?" "+L:"")),F="IE",L=a[1]),D){
// Detect server-side environments.
// Rhino has a global function while others have a global object.
if(d="global",f=null!=(u=n)?typeof u[d]:"number",/^(?:boolean|number|string|undefined)$/.test(f)||"object"==f&&!u[d])g(a=n.runtime)==k?(F="Adobe AIR",U=a.flash.system.Capabilities.os):g(a=n.phantom)==E?(F="PhantomJS",L=(a=a.version||null)&&a.major+"."+a.minor+"."+a.patch):"number"==typeof P.documentMode&&(a=/\bTrident\/(\d+)/i.exec(t))?(
// We're in compatibility mode when the Trident version + 4 doesn't
// equal the document mode.
L=[L,P.documentMode],(a=+a[1]+4)!=L[1]&&(j.push("IE "+L[1]+" mode"),B&&(B[1]=""),L[1]=a),L="IE"==F?String(L[1].toFixed(1)):L[0]):"number"==typeof P.documentMode&&/^(?:Chrome|Firefox)\b/.test(F)&&(j.push("masking as "+F+" "+L),F="IE",L="11.0",B=["Trident"],U="Windows");else if(x&&(I=(a=x.lang.System).getProperty("os.arch"),U=U||a.getProperty("os.name")+" "+a.getProperty("os.version")),C){try{L=n.require("ringo/engine").version.join("."),F="RingoJS"}catch(e){(a=n.system)&&a.global.system==n.system&&(F="Narwhal",U||(U=a[0].os||null))}F||(F="Rhino")}else"object"==typeof n.process&&!n.process.browser&&(a=n.process)&&("object"==typeof a.versions&&("string"==typeof a.versions.electron?(j.push("Node "+a.versions.node),F="Electron",L=a.versions.electron):"string"==typeof a.versions.nw&&(j.push("Chromium "+L,"Node "+a.versions.node),F="NW.js",L=a.versions.nw)),F||(F="Node.js",I=a.arch,U=a.platform,L=(L=/[\d.]+/.exec(a.version))?L[0]:null));U=U&&p(U)}
// Detect prerelease phases.
// Detect Firefox Mobile.
if(L&&(a=/(?:[ab]|dp|pre|[ab]\d+pre)(?:\d+\+?)?$/i.exec(L)||/(?:alpha|beta)(?: ?\d)?/i.exec(t+";"+(D&&s.appMinorVersion))||/\bMinefield\b/i.test(t)&&"a")&&(A=/b/i.test(a)?"beta":"alpha",L=L.replace(RegExp(a+"\\+?$"),"")+("beta"==A?O:_)+(/\d+\+?/.exec(a)||"")),"Fennec"==F||"Firefox"==F&&/\b(?:Android|Firefox OS|KaiOS)\b/.test(U))F="Firefox Mobile";else if("Maxthon"==F&&L)L=L.replace(/\.[\d.]+/,".x");else if(/\bXbox\b/i.test(N))"Xbox 360"==N&&(U=null),"Xbox 360"==N&&/\bIEMobile\b/.test(t)&&j.unshift("mobile mode");else if(!/^(?:Chrome|IE|Opera)$/.test(F)&&(!F||N||/Browser|Mobi/.test(F))||"Windows CE"!=U&&!/Mobi/i.test(t))if("IE"==F&&D)try{null===n.external&&j.unshift("platform preview")}catch(e){j.unshift("embedded")}else(/\bBlackBerry\b/.test(N)||/\bBB10\b/.test(t))&&(a=(RegExp(N.replace(/ +/g," *")+"/([.\\d]+)","i").exec(t)||0)[1]||L)?(U=((a=[a,/BB10/.test(t)])[1]?(N=null,$="BlackBerry"):"Device Software")+" "+a[0],L=null):this!=m&&"Wii"!=N&&(D&&M||/Opera/.test(F)&&/\b(?:MSIE|Firefox)\b/i.test(t)||"Firefox"==F&&/\bOS X (?:\d+\.){2,}/.test(U)||"IE"==F&&(U&&!/^Win/.test(U)&&L>5.5||/\bWindows XP\b/.test(U)&&L>8||8==L&&!/\bTrident\b/.test(t)))&&!l.test(a=e.call(m,t.replace(l,"")+";"))&&a.name&&(
// When "identifying", the UA contains both Opera and the other browser's name.
a="ing as "+a.name+((a=a.version)?" "+a:""),l.test(F)?(/\bIE\b/.test(a)&&"Mac OS"==U&&(U=null),a="identify"+a):(a="mask"+a,F=R?p(R.replace(/([a-z])([A-Z])/g,"$1 $2")):"Opera",/\bIE\b/.test(a)&&(U=null),D||(L=null)),B=["Presto"],j.push(a));
// Detect WebKit Nightly and approximate Chrome/Safari versions.
else F+=" Mobile";(a=(/\bAppleWebKit\/([\d.]+\+?)/i.exec(t)||0)[1])&&(
// Correct build number for numeric comparison.
// (e.g. "532.5" becomes "532.05")
a=[parseFloat(a.replace(/\.(\d)$/,".0$1")),a],
// Nightly builds are postfixed with a "+".
"Safari"==F&&"+"==a[1].slice(-1)?(F="WebKit Nightly",A="alpha",L=a[1].slice(0,-1)):L!=a[1]&&L!=(a[2]=(/\bSafari\/([\d.]+\+?)/i.exec(t)||0)[1])||(L=null),
// Use the full Chrome version when available.
a[1]=(/\b(?:Headless)?Chrome\/([\d.]+)/i.exec(t)||0)[1],
// Detect Blink layout engine.
537.36==a[0]&&537.36==a[2]&&parseFloat(a[1])>=28&&"WebKit"==B&&(B=["Blink"]),
// Detect JavaScriptCore.
// http://stackoverflow.com/questions/6768474/how-can-i-detect-which-javascript-engine-v8-or-jsc-is-used-at-runtime-in-androi
D&&(w||a[1])?(B&&(B[1]="like Chrome"),a=a[1]||((a=a[0])<530?1:a<532?2:a<532.05?3:a<533?4:a<534.03?5:a<534.07?6:a<534.1?7:a<534.13?8:a<534.16?9:a<534.24?10:a<534.3?11:a<535.01?12:a<535.02?"13+":a<535.07?15:a<535.11?16:a<535.19?17:a<536.05?18:a<536.1?19:a<537.01?20:a<537.11?"21+":a<537.13?23:a<537.18?24:a<537.24?25:a<537.36?26:"Blink"!=B?"27":"28")):(B&&(B[1]="like Safari"),a=(a=a[0])<400?1:a<500?2:a<526?3:a<533?4:a<534?"4+":a<535?5:a<537?6:a<538?7:a<601?8:a<602?9:a<604?10:a<606?11:a<608?12:"12"),
// Add the postfix of ".x" or "+" for approximate versions.
B&&(B[1]+=" "+(a+="number"==typeof a?".x":/[.+]/.test(a)?"":"+")),
// Obscure version for some Safari 1-2 releases.
"Safari"==F&&(!L||parseInt(L)>45)?L=a:"Chrome"==F&&/\bHeadlessChrome/i.test(t)&&j.unshift("headless")),
// Detect Opera desktop modes.
"Opera"==F&&(a=/\bzbov|zvav$/.exec(U))?(F+=" ",j.unshift("desktop mode"),"zvav"==a?(F+="Mini",L=null):F+="Mobile",U=U.replace(RegExp(" *"+a+"$"),"")):"Safari"==F&&/\bChrome\b/.exec(B&&B[1])?(j.unshift("desktop mode"),F="Chrome Mobile",L=null,/\bOS X\b/.test(U)?($="Apple",U="iOS 4.3+"):U=null):/\bSRWare Iron\b/.test(F)&&!L&&(L=z("Chrome")),
// Strip incorrect OS versions.
L&&0==L.indexOf(a=/[\d.]+$/.exec(U))&&t.indexOf("/"+a+"-")>-1&&(U=v(U.replace(a,""))),
// Ensure OS does not include the browser name.
U&&-1!=U.indexOf(F)&&!RegExp(F+" OS").test(U)&&(U=U.replace(RegExp(" *"+y(F)+" *"),"")),
// Add layout engine.
B&&!/\b(?:Avant|Nook)\b/.test(F)&&(/Browser|Lunascape|Maxthon/.test(F)||"Safari"!=F&&/^iOS/.test(U)&&/\bSafari\b/.test(B[1])||/^(?:Adobe|Arora|Breach|Midori|Opera|Phantom|Rekonq|Rock|Samsung Internet|Sleipnir|SRWare Iron|Vivaldi|Web)/.test(F)&&B[1])&&(
// Don't add layout details to description if they are falsey.
a=B[B.length-1])&&j.push(a),
// Combine contextual information.
j.length&&(j=["("+j.join("; ")+")"]),
// Append manufacturer to description.
$&&N&&N.indexOf($)<0&&j.push("on "+$),
// Append product to description.
N&&j.push((/^on /.test(j[j.length-1])?"":"on ")+N),
// Parse the OS into an object.
U&&(a=/ ([\d.+]+)$/.exec(U),c=a&&"/"==U.charAt(U.length-a[0].length-1),U={architecture:32,family:a&&!c?U.replace(a[0],""):U,version:a?a[1]:null,toString:function(){var e=this.version;return this.family+(e&&!c?" "+e:"")+(64==this.architecture?" 64-bit":"")}}),
// Add browser/OS architecture.
(a=/\b(?:AMD|IA|Win|WOW|x86_|x)64\b/i.exec(I))&&!/\bi686\b/i.test(I)?(U&&(U.architecture=64,U.family=U.family.replace(RegExp(" *"+a),"")),F&&(/\bWOW64\b/i.test(t)||D&&/\w(?:86|32)$/.test(s.cpuClass||s.platform)&&!/\bWin64; x64\b/i.test(t))&&j.unshift("32-bit")):U&&/^OS X/.test(U.family)&&"Chrome"==F&&parseFloat(L)>=39&&(U.architecture=64),t||(t=null);
/*------------------------------------------------------------------------*/
/**
     * The platform object.
     *
     * @name platform
     * @type Object
     */
var G={};
/**
     * The platform description.
     *
     * @memberOf platform
     * @type string|null
     */return G.description=t,
/**
     * The name of the browser's layout engine.
     *
     * The list of common layout engines include:
     * "Blink", "EdgeHTML", "Gecko", "Trident" and "WebKit"
     *
     * @memberOf platform
     * @type string|null
     */
G.layout=B&&B[0],
/**
     * The name of the product's manufacturer.
     *
     * The list of manufacturers include:
     * "Apple", "Archos", "Amazon", "Asus", "Barnes & Noble", "BlackBerry",
     * "Google", "HP", "HTC", "LG", "Microsoft", "Motorola", "Nintendo",
     * "Nokia", "Samsung" and "Sony"
     *
     * @memberOf platform
     * @type string|null
     */
G.manufacturer=$,
/**
     * The name of the browser/environment.
     *
     * The list of common browser names include:
     * "Chrome", "Electron", "Firefox", "Firefox for iOS", "IE",
     * "Microsoft Edge", "PhantomJS", "Safari", "SeaMonkey", "Silk",
     * "Opera Mini" and "Opera"
     *
     * Mobile versions of some browsers have "Mobile" appended to their name:
     * eg. "Chrome Mobile", "Firefox Mobile", "IE Mobile" and "Opera Mobile"
     *
     * @memberOf platform
     * @type string|null
     */
G.name=F,
/**
     * The alpha/beta release indicator.
     *
     * @memberOf platform
     * @type string|null
     */
G.prerelease=A,
/**
     * The name of the product hosting the browser.
     *
     * The list of common products include:
     *
     * "BlackBerry", "Galaxy S4", "Lumia", "iPad", "iPod", "iPhone", "Kindle",
     * "Kindle Fire", "Nexus", "Nook", "PlayBook", "TouchPad" and "Transformer"
     *
     * @memberOf platform
     * @type string|null
     */
G.product=N,
/**
     * The browser's user agent string.
     *
     * @memberOf platform
     * @type string|null
     */
G.ua=t,
/**
     * The browser/environment version.
     *
     * @memberOf platform
     * @type string|null
     */
G.version=F&&L,
/**
     * The name of the operating system.
     *
     * @memberOf platform
     * @type Object
     */
G.os=U||{
/**
       * The CPU architecture the OS is built for.
       *
       * @memberOf platform.os
       * @type number|null
       */
architecture:null,
/**
       * The family of the OS.
       *
       * Common values include:
       * "Windows", "Windows Server 2008 R2 / 7", "Windows Server 2008 / Vista",
       * "Windows XP", "OS X", "Linux", "Ubuntu", "Debian", "Fedora", "Red Hat",
       * "SuSE", "Android", "iOS" and "Windows Phone"
       *
       * @memberOf platform.os
       * @type string|null
       */
family:null,
/**
       * The version of the OS.
       *
       * @memberOf platform.os
       * @type string|null
       */
version:null,
/**
       * Returns the OS string.
       *
       * @memberOf platform.os
       * @returns {string} The OS string.
       */
toString:function(){return"null"}},G.parse=e,G.toString=function(){return this.description||""},G.version&&j.unshift(L),G.name&&j.unshift(F),U&&F&&(U!=String(U).split(" ")[0]||U!=F.split(" ")[0]&&!N)&&j.push(N?"("+U+")":"on "+U),j.length&&(G.description=j.join(" ")),G}();
// Some AMD build optimizers, like r.js, check for condition patterns like the following:
s&&o?
// Export for CommonJS support.
m(w,function(e,t){s[t]=e}):
// Export to the global object.
r.platform=w}).call(this)}).call(this,"undefined"!=typeof global?global:"undefined"!=typeof self?self:"undefined"!=typeof window?window:{})},{}],38:[function(e,t,n){var i=e("./v1"),r=e("./v4"),s=r;s.v1=i,s.v4=r,t.exports=s},{"./v1":41,"./v4":42}],39:[function(e,t,n){for(
/**
 * Convert array of 16 byte values to UUID string format of the form:
 * XXXXXXXX-XXXX-XXXX-XXXX-XXXXXXXXXXXX
 */
var i=[],r=0;r<256;++r)i[r]=(r+256).toString(16).substr(1);t.exports=function(e,t){var n=t||0,r=i;
// join used to fix memory issue caused by concatenation: https://bugs.chromium.org/p/v8/issues/detail?id=3175#c4
return[r[e[n++]],r[e[n++]],r[e[n++]],r[e[n++]],"-",r[e[n++]],r[e[n++]],"-",r[e[n++]],r[e[n++]],"-",r[e[n++]],r[e[n++]],"-",r[e[n++]],r[e[n++]],r[e[n++]],r[e[n++]],r[e[n++]],r[e[n++]]].join("")}},{}],40:[function(e,t,n){
// Unique ID creation requires a high quality random # generator.  In the
// browser this is a little complicated due to unknown quality of Math.random()
// and inconsistent support for the `crypto` API.  We do the best we can via
// feature-detection
// getRandomValues needs to be invoked in a context where "this" is a Crypto
// implementation. Also, find the complete implementation of crypto on IE11.
var i="undefined"!=typeof crypto&&crypto.getRandomValues&&crypto.getRandomValues.bind(crypto)||"undefined"!=typeof msCrypto&&"function"==typeof window.msCrypto.getRandomValues&&msCrypto.getRandomValues.bind(msCrypto);if(i){
// WHATWG crypto RNG - http://wiki.whatwg.org/wiki/Crypto
var r=new Uint8Array(16);// eslint-disable-line no-undef
t.exports=function(){return i(r),r}}else{
// Math.random()-based (RNG)
//
// If all else fails, use Math.random().  It's fast, but is of unspecified
// quality.
var s=new Array(16);t.exports=function(){for(var e,t=0;t<16;t++)0==(3&t)&&(e=4294967296*Math.random()),s[t]=e>>>((3&t)<<3)&255;return s}}},{}],41:[function(e,t,n){var i,r,s=e("./lib/rng"),o=e("./lib/bytesToUuid"),a=0,c=0;t.exports=
// See https://github.com/uuidjs/uuid for API details
function(e,t,n){var l=t&&n||0,u=t||[],d=(e=e||{}).node||i,h=void 0!==e.clockseq?e.clockseq:r;
// node and clockseq need to be initialized to random values if they're not
// specified.  We do this lazily to minimize issues related to insufficient
// system entropy.  See #189
if(null==d||null==h){var f=s();null==d&&(
// Per 4.5, create and 48-bit node id, (47 random bits + multicast bit = 1)
d=i=[1|f[0],f[1],f[2],f[3],f[4],f[5]]),null==h&&(
// Per 4.2.2, randomize (14 bit) clockseq
h=r=16383&(f[6]<<8|f[7]))}
// UUID timestamps are 100 nano-second units since the Gregorian epoch,
// (1582-10-15 00:00).  JSNumbers aren't precise enough for this, so
// time is handled internally as 'msecs' (integer milliseconds) and 'nsecs'
// (100-nanoseconds offset from msecs) since unix epoch, 1970-01-01 00:00.
var p=void 0!==e.msecs?e.msecs:(new Date).getTime(),m=void 0!==e.nsecs?e.nsecs:c+1,g=p-a+(m-c)/1e4;
// Per 4.2.1.2, use count of uuid's generated during the current clock
// cycle to simulate higher resolution clock
// Per 4.2.1.2 Throw error if too many uuids are requested
if(
// Per 4.2.1.2, Bump clockseq on clock regression
g<0&&void 0===e.clockseq&&(h=h+1&16383),
// Reset nsecs if clock regresses (new clockseq) or we've moved onto a new
// time interval
(g<0||p>a)&&void 0===e.nsecs&&(m=0),m>=1e4)throw new Error("uuid.v1(): Can't create more than 10M uuids/sec");a=p,c=m,r=h;
// `time_low`
var y=(1e4*(268435455&(
// Per 4.1.4 - Convert from unix epoch to Gregorian epoch
p+=122192928e5))+m)%4294967296;u[l++]=y>>>24&255,u[l++]=y>>>16&255,u[l++]=y>>>8&255,u[l++]=255&y;
// `time_mid`
var b=p/4294967296*1e4&268435455;u[l++]=b>>>8&255,u[l++]=255&b,
// `time_high_and_version`
u[l++]=b>>>24&15|16,// include version
u[l++]=b>>>16&255,
// `clock_seq_hi_and_reserved` (Per 4.2.2 - include variant)
u[l++]=h>>>8|128,
// `clock_seq_low`
u[l++]=255&h;
// `node`
for(var v=0;v<6;++v)u[l+v]=d[v];return t||o(u)}},{"./lib/bytesToUuid":39,"./lib/rng":40}],42:[function(e,t,n){var i=e("./lib/rng"),r=e("./lib/bytesToUuid");t.exports=function(e,t,n){var s=t&&n||0;"string"==typeof e&&(t="binary"===e?new Array(16):null,e=null);var o=(e=e||{}).random||(e.rng||i)();
// Per 4.4, set bits for version and `clock_seq_hi_and_reserved`
// Copy bytes to buffer, if provided
if(o[6]=15&o[6]|64,o[8]=63&o[8]|128,t)for(var a=0;a<16;++a)t[s+a]=o[a];return t||r(o)}},{"./lib/bytesToUuid":39,"./lib/rng":40}]},{},[9])(9)});