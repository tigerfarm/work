const gulp = require('gulp');
const gutil = require('gulp-util');
const browserify = require('browserify');
const source = require('vinyl-source-stream');
const buffer = require('vinyl-buffer');
const insert = require('gulp-insert');
const del = require('del');
const fs = require('fs');
const rename = require('gulp-rename');
const uglify = require('gulp-uglify-es').default;
const cheerio = require('cheerio');
const tap = require('gulp-tap');
const derequire = require('gulp-derequire');
const tslint = require('gulp-tslint');
const typescript = require('gulp-typescript');
const replace = require('gulp-replace');
const cp = require('child_process');

const pkg = require('./package');
pkg.name = 'twilsock';

const product = {
  version: pkg.version,
  compiled: {
    destination: 'lib',
    entrypoint: 'lib/index.js'
  },
  packaged: {
    dir: 'dist',
    name: pkg.name + '.js',
    minified: pkg.name + '.min.js'
  },
  bundled: {
    dir: 'build',
    name: pkg.name + '-bundle.js'
  },
  license: 'LICENSE'
};

const tests = {
  lint: {
    files: ['src/*.ts', 'src/**/*.ts', '!src/test/**']
  },
  unit: {
    index: 'src/test/unit/index.ts'
  },
  integration: {
    index: 'src/test/integration/index.ts'
  }
};

const coverage = {
  dir: 'coverage',
  unit: 'coverage/unit',
  integration: 'coverage/integration'
};

const docs = {
  dir: product.packaged.dir + '/docs',
  conf: 'jsdoc.json',
  files: [
    'lib/client.js'
  ],
  publicConstructors: ['TwilsockClient'],
  privateConstructors: ['TwilsockConfig', 'PacketInterface', 'TwilsockChannel']
};

gulp.task('lint', () => {
  return gulp.src(tests.lint.files)
    .pipe(tslint({
      formatter: 'prose'
    }))
    .pipe(tslint.report({
      allowWarnings: false,
      emitError: true,
      summarizeFailureOutput: true
    }));
});


function runMochaInNYC(cb, coverageDir, testIndex) {
    cp.exec(['env', 'FORCE_COLOR=1', 'NODE_ENV=test', 'npx', 'nyc',
        '--report-dir', coverageDir,
        './node_modules/mocha/bin/mocha', testIndex
    ].join(' '), cb).stdout.pipe(process.stdout);
}

gulp.task('clean-unit-test-coverage', function() {
    return del([
        coverage.unit
    ]);
});

gulp.task('clean-integration-tests-coverage', function() {
    return del([
        coverage.integration
    ]);
});

gulp.task('unit-test',
    gulp.series('clean-unit-test-coverage',
        function runUnitTests(cb) {
            runMochaInNYC(cb, coverage.unit, tests.unit.index);
        }));


gulp.task('integration-test',
    gulp.series('clean-integration-tests-coverage',
        function runIntegrationTests(cb) {
            runMochaInNYC(cb, coverage.integration, tests.integration.index);
        }));

gulp.task('build-node', () => {
  const placeholder = '__TWILSOCK_CLIENT_VERSION_PLACEHOLDER__';
  const project = typescript.createProject('tsconfig.json');
  return project.src()
    .pipe(project())
    .once("error", function () {
      this.once("finish", () => process.exit(1));
    })
    .pipe(replace(placeholder, product.version))
    .pipe(gulp.dest(product.compiled.destination));
});

gulp.task('bundle', () => {
  const licenseContents = fs.readFileSync(product.license);
  return browserify({
      debug: false,
      standalone: 'Twilio.Twilsock',
      entries: [product.compiled.entrypoint],
      transform: []
    })
    .bundle()
    .pipe(source(product.packaged.name))
    .pipe(buffer())
    .pipe(derequire())
    .pipe(insert.prepend(`/* ${pkg.name}.js ${pkg.version}\n${licenseContents}*/\n\n`))
    .pipe(gulp.dest(product.packaged.dir));
});

gulp.task('minify', () => {
  return gulp.src(product.packaged.dir + '/' + product.packaged.name)
    .pipe(uglify({
      output: {
        ascii_only: true,
        comments: 'license'
      }
    }).on('error', gutil.log))
    .pipe(rename(product.packaged.minified))
    .pipe(gulp.dest(product.packaged.dir));
});

gulp.task('build', gulp.series(
  'build-node',
  'bundle'));

gulp.task('package', gulp.series('minify'));

gulp.task('generate-doc', function (cb) {
  cp.exec(['npx', 'jsdoc',
    '-d', docs.dir,
    '-c', docs.conf,
    docs.files.join(' '),
    './README.md',
    '-t ./node_modules/ink-docstrap/template'
  ].join(' '), cb);
});

gulp.task('prettify-doc', () => {
  return gulp.src(docs.dir + '/*.html')
    .pipe(tap(function (file) {
      var $ = cheerio.load(file.contents.toString());
      var filename = file.path.slice(file.base.length);
      var className = filename.split('.html')[0];
      var div;

      // Prefix public constructors.
      if (docs.publicConstructors.indexOf(className) > -1) {
        div = $('.container-overview');
        var name = $('h4.name', div);
        name.html(name.html().replace(/new /, 'new <span style="color: #999">Twilio.Twilsock.</span>'));
      }

      // Remove private constructors.
      if (docs.privateConstructors.indexOf(className) > -1) {
        div = $('.container-overview');
        $('h2', div).remove();
        $('h4.name', div).remove();
        $('div.description', div).remove();
        $('h5:contains(Parameters:)', div).remove();
        $('table.params', div).remove();
      }

      file.contents = Buffer.from($.html());
      return file;
    }))
    .pipe(gulp.dest(docs.dir));
});


gulp.task('doc', gulp.series(
  'build-node',
  'generate-doc',
  'prettify-doc'));

gulp.task('clean', () => del([
    product.packaged.dir + '/' + product.packaged.name,
    product.packaged.dir + '/' + product.packaged.minified,
    docs.dir,
    product.bundled.dir + '/' + product.bundled.name,
    coverage.dir
  ]));

gulp.task('default', gulp.series(
    'clean',
    'lint',
    'unit-test',
    'build',
    'package',
    'doc'));
