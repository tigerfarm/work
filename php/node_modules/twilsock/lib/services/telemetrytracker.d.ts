import { Configuration } from '../configuration';
import { PacketInterface } from '../packetinterface';
import { TelemetryEvent } from '../protocol/messages/telemetry';
declare class TelemetryEventDescription {
    readonly title: string;
    readonly details: string;
    readonly start: Date;
    readonly type?: string;
    readonly id?: string;
    end: Date;
    constructor(title: string, details: string, start: Date, end?: Date, type?: string, id?: string);
    toTelemetryEvent(): TelemetryEvent;
}
declare enum TelemetryPoint {
    Start = 0,
    End = 1
}
declare enum EventSendingLimitation {
    MinEventsPortion = 0,
    AnyEvents = 1,
    AnyEventsIncludingUnfinished = 2
}
declare class TelemetryTracker {
    private readonly minEventsPortionToSend;
    private readonly maxEventsPortionToSend;
    private readonly config;
    private readonly packetInterface;
    private pendingEvents;
    private readyEvents;
    private hasInitializationFinished;
    private _canSendTelemetry;
    constructor(config: Configuration, packetInterface: PacketInterface);
    get isTelemetryEnabled(): boolean;
    get canSendTelemetry(): boolean;
    set canSendTelemetry(enable: boolean);
    addTelemetryEvent(event: TelemetryEventDescription): void;
    addPartialEvent(incompleteEvent: TelemetryEventDescription, eventKey: string, point: TelemetryPoint): void;
    getTelemetryToSend(sendingLimit: EventSendingLimitation): TelemetryEventDescription[];
    private getTelemetryPortion;
    private merge;
    sendTelemetryIfMinimalPortionCollected(): void;
    sendTelemetry(limit: EventSendingLimitation): void;
}
export { TelemetryTracker, TelemetryEventDescription, TelemetryPoint, EventSendingLimitation };
