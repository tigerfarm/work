"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const telemetry_1 = require("../protocol/messages/telemetry");
const logger_1 = require("../logger");
class TelemetryEventDescription {
    constructor(title, details, start, end, type, id) {
        this.title = title;
        this.details = details;
        this.start = start;
        this.type = type;
        this.id = id;
        this.end = end;
    }
    // Prepare telemetry event right before sending it.
    // Convert times to relative.
    toTelemetryEvent() {
        // Fix dates
        const now = new Date();
        let actualStart = this.start;
        let actualEnd = this.end ? this.end : now;
        if (actualEnd < actualStart) {
            let tmp = actualEnd;
            actualEnd = actualStart;
            actualStart = tmp;
        }
        // Converting dates to relative offset from current moment in ms
        const startOffset = actualStart.getTime() - now.getTime();
        const endOffset = actualEnd.getTime() - now.getTime();
        const result = new telemetry_1.TelemetryEvent(startOffset, endOffset, this.title, this.details, this.id, this.type);
        return result;
    }
}
exports.TelemetryEventDescription = TelemetryEventDescription;
var TelemetryPoint;
(function (TelemetryPoint) {
    TelemetryPoint[TelemetryPoint["Start"] = 0] = "Start";
    TelemetryPoint[TelemetryPoint["End"] = 1] = "End";
})(TelemetryPoint || (TelemetryPoint = {}));
exports.TelemetryPoint = TelemetryPoint;
var EventSendingLimitation;
(function (EventSendingLimitation) {
    EventSendingLimitation[EventSendingLimitation["MinEventsPortion"] = 0] = "MinEventsPortion";
    EventSendingLimitation[EventSendingLimitation["AnyEvents"] = 1] = "AnyEvents";
    EventSendingLimitation[EventSendingLimitation["AnyEventsIncludingUnfinished"] = 2] = "AnyEventsIncludingUnfinished";
})(EventSendingLimitation || (EventSendingLimitation = {}));
exports.EventSendingLimitation = EventSendingLimitation;
class TelemetryTracker {
    constructor(config, packetInterface) {
        // accumulated events count that is big enough to be sent out of schedule (not on timer but on new event registration)
        this.minEventsPortionToSend = 50;
        // max events batch size to be sent in a single Telemetry message
        this.maxEventsPortionToSend = 100;
        this.pendingEvents = new Map(); // started events: have TelemetryEvent::startTime only
        this.readyEvents = []; // events ready to send
        this.hasInitializationFinished = false;
        this._canSendTelemetry = false;
        this.config = config;
        this.packetInterface = packetInterface;
    }
    // Keeping this private prevents the type declaration from being generated properly.
    // Ideally, this should be private.
    get isTelemetryEnabled() {
        return this.config.confirmedCapabilities.has('telemetry.v1');
    }
    get canSendTelemetry() {
        return this._canSendTelemetry && this.isTelemetryEnabled;
    }
    set canSendTelemetry(enable) {
        logger_1.log.debug(`TelemetryTracker.canSendTelemetry: ${enable} TelemetryTracker.isTelemetryEnabled: ${this.isTelemetryEnabled}`);
        // We want to keep telemetry events added in advance but
        // we need to purge events from previous connection when being disconnected
        if (this._canSendTelemetry && !enable) {
            this.pendingEvents.clear();
            this.readyEvents = [];
        }
        this._canSendTelemetry = enable;
        if (enable) {
            this.sendTelemetry(EventSendingLimitation.AnyEvents);
        }
        if (enable && !this.hasInitializationFinished) {
            this.hasInitializationFinished = true;
        }
    }
    // Add complete event
    addTelemetryEvent(event) {
        // Allow adding events before initialization.
        if (!this.canSendTelemetry && this.hasInitializationFinished) {
            return;
        }
        this.readyEvents.push(event);
    }
    // Add incomplete event (with either starting or ending time point)
    addPartialEvent(incompleteEvent, eventKey, point) {
        logger_1.log.debug(`Adding ${point === TelemetryPoint.Start ? 'starting' : 'ending'} timepoint for '${eventKey}' event`);
        let exists = this.pendingEvents.has(eventKey);
        if (point === TelemetryPoint.Start) {
            if (exists) {
                logger_1.log.debug(`Overwriting starting point for '${eventKey}' event`);
            }
            this.pendingEvents.set(eventKey, incompleteEvent);
        }
        else {
            if (!exists) {
                logger_1.log.info(`Could not find started event for '${eventKey}' event`);
                return;
            }
            this.addTelemetryEvent(this.merge(this.pendingEvents.get(eventKey), incompleteEvent));
            this.pendingEvents.delete(eventKey);
        }
    }
    getTelemetryToSend(sendingLimit) {
        if (!this.canSendTelemetry || this.readyEvents.length == 0) {
            return []; // Events are collected but not sent until telemetry is enabled
        }
        if (sendingLimit == EventSendingLimitation.MinEventsPortion && this.readyEvents.length < this.minEventsPortionToSend) {
            return [];
        }
        return this.getTelemetryPortion(sendingLimit == EventSendingLimitation.AnyEventsIncludingUnfinished);
    }
    getTelemetryPortion(includeUnfinished) {
        const eventsPortionToSend = Math.min(this.readyEvents.length, this.maxEventsPortionToSend);
        let res = this.readyEvents.splice(0, eventsPortionToSend);
        if (includeUnfinished && res.length < this.maxEventsPortionToSend) {
            this.pendingEvents.forEach((value, key) => {
                if (res.length >= this.maxEventsPortionToSend) {
                    return; // @fixme does not end the loop early
                }
                let event = this.pendingEvents.get(key);
                this.pendingEvents.delete(key);
                res.push(new TelemetryEventDescription(`[UNFINISHED] ${event.title}`, // add prefix title to mark unfinished events for CleanSock
                event.details, event.start, null, // Not ended, on sending will be replaced with now
                event.type, event.id));
            });
        }
        return res;
    }
    // Merging 2 partial events:
    //   use start.startTime & end.endTime.
    // For other fields,
    //   if there are values in end, use them,
    //   else use values from start.
    merge(start, end) {
        return new TelemetryEventDescription(end.title ? end.title : start.title, end.details ? end.details : start.details, start.start, end.end, end.type ? end.type : start.type, end.id ? end.id : start.id);
    }
    sendTelemetryIfMinimalPortionCollected() {
        this.sendTelemetry(EventSendingLimitation.MinEventsPortion);
    }
    // NB: getTelemetryToSend will return non-empty array only if we have already received initReply
    // and telemetry.v1 capability is enabled there.
    sendTelemetry(limit) {
        const events = this.getTelemetryToSend(limit);
        if (events.length === 0) {
            return; // not enough telemetry data collected
        }
        try {
            this.packetInterface.send(new telemetry_1.Telemetry(events.map(e => e.toTelemetryEvent())));
        }
        catch (err) {
            logger_1.log.debug(`Error while sending ${events.length} telemetry events due to ${err}; they will be resubmitted`);
            this.readyEvents = this.readyEvents.concat(events);
        }
    }
}
exports.TelemetryTracker = TelemetryTracker;
